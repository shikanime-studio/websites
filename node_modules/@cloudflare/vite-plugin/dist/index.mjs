import module$1, { builtinModules, createRequire } from "node:module";
import assert from "node:assert";
import { CoreHeaders, Log, LogLevel, Miniflare, Request as Request$1, Response as Response$1, coupleWebSocket, getDefaultDevRegistryPath, getNodeCompat, getWorkerRegistry, kUnsafeEphemeralUniqueKey } from "miniflare";
import * as wrangler from "wrangler";
import * as nodePath from "node:path";
import path4, { relative, resolve } from "node:path";
import * as util$1 from "node:util";
import { format, inspect } from "node:util";
import { createHeaders, createRequest, sendResponse } from "@remix-run/node-fetch-server";
import * as vite from "vite";
import { version } from "vite";
import * as fs$1 from "node:fs";
import fs, { existsSync, readFileSync, realpathSync, statSync } from "node:fs";
import { URL as URL$1, fileURLToPath, pathToFileURL } from "node:url";
import process2 from "node:process";
import os from "node:os";
import { defu } from "defu";
import { getCloudflarePreset } from "@cloudflare/unenv-preset";
import v8 from "node:v8";
import { defineEnv } from "unenv";
import * as fsp from "node:fs/promises";
import colors from "picocolors";
import getPort, { portNumbers } from "get-port";
import { execFileSync, spawn } from "node:child_process";
import { randomUUID } from "node:crypto";
import { globSync } from "tinyglobby";
import { WebSocketServer } from "ws";

//#region rolldown:runtime
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __getProtoOf$1 = Object.getPrototypeOf;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __commonJS$1 = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames$1(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$1 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames$1(from), i$1 = 0, n$1 = keys.length, key; i$1 < n$1; i$1++) {
		key = keys[i$1];
		if (!__hasOwnProp$1.call(to, key) && key !== except) __defProp$1(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$1 = (mod, isNodeMode, target$1) => (target$1 = mod != null ? __create$1(__getProtoOf$1(mod)) : {}, __copyProps$1(isNodeMode || !mod || !mod.__esModule ? __defProp$1(target$1, "default", {
	value: mod,
	enumerable: true
}) : target$1, mod));
var __require$1 = /* @__PURE__ */ createRequire(import.meta.url);

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/constants.js
var require_constants = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/constants.js": ((exports, module) => {
	const SEMVER_SPEC_VERSION = "2.0.0";
	const MAX_LENGTH$2 = 256;
	const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
	const MAX_SAFE_COMPONENT_LENGTH$1 = 16;
	const MAX_SAFE_BUILD_LENGTH$1 = MAX_LENGTH$2 - 6;
	const RELEASE_TYPES = [
		"major",
		"premajor",
		"minor",
		"preminor",
		"patch",
		"prepatch",
		"prerelease"
	];
	module.exports = {
		MAX_LENGTH: MAX_LENGTH$2,
		MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH$1,
		MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH$1,
		MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
		RELEASE_TYPES,
		SEMVER_SPEC_VERSION,
		FLAG_INCLUDE_PRERELEASE: 1,
		FLAG_LOOSE: 2
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/debug.js
var require_debug = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/debug.js": ((exports, module) => {
	const debug$4 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
	module.exports = debug$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/re.js
var require_re = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/re.js": ((exports, module) => {
	const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH: MAX_LENGTH$1 } = require_constants();
	const debug$3 = require_debug();
	exports = module.exports = {};
	const re$4 = exports.re = [];
	const safeRe = exports.safeRe = [];
	const src = exports.src = [];
	const safeSrc = exports.safeSrc = [];
	const t$4 = exports.t = {};
	let R = 0;
	const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
	const safeRegexReplacements = [
		["\\s", 1],
		["\\d", MAX_LENGTH$1],
		[LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
	];
	const makeSafeRegex = (value) => {
		for (const [token, max] of safeRegexReplacements) value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
		return value;
	};
	const createToken = (name, value, isGlobal) => {
		const safe = makeSafeRegex(value);
		const index = R++;
		debug$3(name, index, value);
		t$4[name] = index;
		src[index] = value;
		safeSrc[index] = safe;
		re$4[index] = new RegExp(value, isGlobal ? "g" : void 0);
		safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
	};
	createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
	createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
	createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
	createToken("MAINVERSION", `(${src[t$4.NUMERICIDENTIFIER]})\\.(${src[t$4.NUMERICIDENTIFIER]})\\.(${src[t$4.NUMERICIDENTIFIER]})`);
	createToken("MAINVERSIONLOOSE", `(${src[t$4.NUMERICIDENTIFIERLOOSE]})\\.(${src[t$4.NUMERICIDENTIFIERLOOSE]})\\.(${src[t$4.NUMERICIDENTIFIERLOOSE]})`);
	createToken("PRERELEASEIDENTIFIER", `(?:${src[t$4.NONNUMERICIDENTIFIER]}|${src[t$4.NUMERICIDENTIFIER]})`);
	createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t$4.NONNUMERICIDENTIFIER]}|${src[t$4.NUMERICIDENTIFIERLOOSE]})`);
	createToken("PRERELEASE", `(?:-(${src[t$4.PRERELEASEIDENTIFIER]}(?:\\.${src[t$4.PRERELEASEIDENTIFIER]})*))`);
	createToken("PRERELEASELOOSE", `(?:-?(${src[t$4.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t$4.PRERELEASEIDENTIFIERLOOSE]})*))`);
	createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
	createToken("BUILD", `(?:\\+(${src[t$4.BUILDIDENTIFIER]}(?:\\.${src[t$4.BUILDIDENTIFIER]})*))`);
	createToken("FULLPLAIN", `v?${src[t$4.MAINVERSION]}${src[t$4.PRERELEASE]}?${src[t$4.BUILD]}?`);
	createToken("FULL", `^${src[t$4.FULLPLAIN]}$`);
	createToken("LOOSEPLAIN", `[v=\\s]*${src[t$4.MAINVERSIONLOOSE]}${src[t$4.PRERELEASELOOSE]}?${src[t$4.BUILD]}?`);
	createToken("LOOSE", `^${src[t$4.LOOSEPLAIN]}$`);
	createToken("GTLT", "((?:<|>)?=?)");
	createToken("XRANGEIDENTIFIERLOOSE", `${src[t$4.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
	createToken("XRANGEIDENTIFIER", `${src[t$4.NUMERICIDENTIFIER]}|x|X|\\*`);
	createToken("XRANGEPLAIN", `[v=\\s]*(${src[t$4.XRANGEIDENTIFIER]})(?:\\.(${src[t$4.XRANGEIDENTIFIER]})(?:\\.(${src[t$4.XRANGEIDENTIFIER]})(?:${src[t$4.PRERELEASE]})?${src[t$4.BUILD]}?)?)?`);
	createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t$4.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t$4.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t$4.XRANGEIDENTIFIERLOOSE]})(?:${src[t$4.PRERELEASELOOSE]})?${src[t$4.BUILD]}?)?)?`);
	createToken("XRANGE", `^${src[t$4.GTLT]}\\s*${src[t$4.XRANGEPLAIN]}$`);
	createToken("XRANGELOOSE", `^${src[t$4.GTLT]}\\s*${src[t$4.XRANGEPLAINLOOSE]}$`);
	createToken("COERCEPLAIN", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
	createToken("COERCE", `${src[t$4.COERCEPLAIN]}(?:$|[^\\d])`);
	createToken("COERCEFULL", src[t$4.COERCEPLAIN] + `(?:${src[t$4.PRERELEASE]})?(?:${src[t$4.BUILD]})?(?:$|[^\\d])`);
	createToken("COERCERTL", src[t$4.COERCE], true);
	createToken("COERCERTLFULL", src[t$4.COERCEFULL], true);
	createToken("LONETILDE", "(?:~>?)");
	createToken("TILDETRIM", `(\\s*)${src[t$4.LONETILDE]}\\s+`, true);
	exports.tildeTrimReplace = "$1~";
	createToken("TILDE", `^${src[t$4.LONETILDE]}${src[t$4.XRANGEPLAIN]}$`);
	createToken("TILDELOOSE", `^${src[t$4.LONETILDE]}${src[t$4.XRANGEPLAINLOOSE]}$`);
	createToken("LONECARET", "(?:\\^)");
	createToken("CARETTRIM", `(\\s*)${src[t$4.LONECARET]}\\s+`, true);
	exports.caretTrimReplace = "$1^";
	createToken("CARET", `^${src[t$4.LONECARET]}${src[t$4.XRANGEPLAIN]}$`);
	createToken("CARETLOOSE", `^${src[t$4.LONECARET]}${src[t$4.XRANGEPLAINLOOSE]}$`);
	createToken("COMPARATORLOOSE", `^${src[t$4.GTLT]}\\s*(${src[t$4.LOOSEPLAIN]})$|^$`);
	createToken("COMPARATOR", `^${src[t$4.GTLT]}\\s*(${src[t$4.FULLPLAIN]})$|^$`);
	createToken("COMPARATORTRIM", `(\\s*)${src[t$4.GTLT]}\\s*(${src[t$4.LOOSEPLAIN]}|${src[t$4.XRANGEPLAIN]})`, true);
	exports.comparatorTrimReplace = "$1$2$3";
	createToken("HYPHENRANGE", `^\\s*(${src[t$4.XRANGEPLAIN]})\\s+-\\s+(${src[t$4.XRANGEPLAIN]})\\s*$`);
	createToken("HYPHENRANGELOOSE", `^\\s*(${src[t$4.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t$4.XRANGEPLAINLOOSE]})\\s*$`);
	createToken("STAR", "(<|>)?=?\\s*\\*");
	createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
	createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/parse-options.js
var require_parse_options = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/parse-options.js": ((exports, module) => {
	const looseOption = Object.freeze({ loose: true });
	const emptyOpts = Object.freeze({});
	const parseOptions$3 = (options) => {
		if (!options) return emptyOpts;
		if (typeof options !== "object") return looseOption;
		return options;
	};
	module.exports = parseOptions$3;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/identifiers.js
var require_identifiers = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/identifiers.js": ((exports, module) => {
	const numeric = /^[0-9]+$/;
	const compareIdentifiers$1 = (a, b) => {
		if (typeof a === "number" && typeof b === "number") return a === b ? 0 : a < b ? -1 : 1;
		const anum = numeric.test(a);
		const bnum = numeric.test(b);
		if (anum && bnum) {
			a = +a;
			b = +b;
		}
		return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
	};
	const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
	module.exports = {
		compareIdentifiers: compareIdentifiers$1,
		rcompareIdentifiers
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/semver.js
var require_semver$1 = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/semver.js": ((exports, module) => {
	const debug$2 = require_debug();
	const { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
	const { safeRe: re$3, t: t$3 } = require_re();
	const parseOptions$2 = require_parse_options();
	const { compareIdentifiers } = require_identifiers();
	var SemVer$15 = class SemVer$15 {
		constructor(version$2, options) {
			options = parseOptions$2(options);
			if (version$2 instanceof SemVer$15) if (version$2.loose === !!options.loose && version$2.includePrerelease === !!options.includePrerelease) return version$2;
			else version$2 = version$2.version;
			else if (typeof version$2 !== "string") throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version$2}".`);
			if (version$2.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
			debug$2("SemVer", version$2, options);
			this.options = options;
			this.loose = !!options.loose;
			this.includePrerelease = !!options.includePrerelease;
			const m = version$2.trim().match(options.loose ? re$3[t$3.LOOSE] : re$3[t$3.FULL]);
			if (!m) throw new TypeError(`Invalid Version: ${version$2}`);
			this.raw = version$2;
			this.major = +m[1];
			this.minor = +m[2];
			this.patch = +m[3];
			if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
			if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
			if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
			if (!m[4]) this.prerelease = [];
			else this.prerelease = m[4].split(".").map((id) => {
				if (/^[0-9]+$/.test(id)) {
					const num = +id;
					if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
				}
				return id;
			});
			this.build = m[5] ? m[5].split(".") : [];
			this.format();
		}
		format() {
			this.version = `${this.major}.${this.minor}.${this.patch}`;
			if (this.prerelease.length) this.version += `-${this.prerelease.join(".")}`;
			return this.version;
		}
		toString() {
			return this.version;
		}
		compare(other) {
			debug$2("SemVer.compare", this.version, this.options, other);
			if (!(other instanceof SemVer$15)) {
				if (typeof other === "string" && other === this.version) return 0;
				other = new SemVer$15(other, this.options);
			}
			if (other.version === this.version) return 0;
			return this.compareMain(other) || this.comparePre(other);
		}
		compareMain(other) {
			if (!(other instanceof SemVer$15)) other = new SemVer$15(other, this.options);
			if (this.major < other.major) return -1;
			if (this.major > other.major) return 1;
			if (this.minor < other.minor) return -1;
			if (this.minor > other.minor) return 1;
			if (this.patch < other.patch) return -1;
			if (this.patch > other.patch) return 1;
			return 0;
		}
		comparePre(other) {
			if (!(other instanceof SemVer$15)) other = new SemVer$15(other, this.options);
			if (this.prerelease.length && !other.prerelease.length) return -1;
			else if (!this.prerelease.length && other.prerelease.length) return 1;
			else if (!this.prerelease.length && !other.prerelease.length) return 0;
			let i$1 = 0;
			do {
				const a = this.prerelease[i$1];
				const b = other.prerelease[i$1];
				debug$2("prerelease compare", i$1, a, b);
				if (a === void 0 && b === void 0) return 0;
				else if (b === void 0) return 1;
				else if (a === void 0) return -1;
				else if (a === b) continue;
				else return compareIdentifiers(a, b);
			} while (++i$1);
		}
		compareBuild(other) {
			if (!(other instanceof SemVer$15)) other = new SemVer$15(other, this.options);
			let i$1 = 0;
			do {
				const a = this.build[i$1];
				const b = other.build[i$1];
				debug$2("build compare", i$1, a, b);
				if (a === void 0 && b === void 0) return 0;
				else if (b === void 0) return 1;
				else if (a === void 0) return -1;
				else if (a === b) continue;
				else return compareIdentifiers(a, b);
			} while (++i$1);
		}
		inc(release, identifier, identifierBase) {
			if (release.startsWith("pre")) {
				if (!identifier && identifierBase === false) throw new Error("invalid increment argument: identifier is empty");
				if (identifier) {
					const match = `-${identifier}`.match(this.options.loose ? re$3[t$3.PRERELEASELOOSE] : re$3[t$3.PRERELEASE]);
					if (!match || match[1] !== identifier) throw new Error(`invalid identifier: ${identifier}`);
				}
			}
			switch (release) {
				case "premajor":
					this.prerelease.length = 0;
					this.patch = 0;
					this.minor = 0;
					this.major++;
					this.inc("pre", identifier, identifierBase);
					break;
				case "preminor":
					this.prerelease.length = 0;
					this.patch = 0;
					this.minor++;
					this.inc("pre", identifier, identifierBase);
					break;
				case "prepatch":
					this.prerelease.length = 0;
					this.inc("patch", identifier, identifierBase);
					this.inc("pre", identifier, identifierBase);
					break;
				case "prerelease":
					if (this.prerelease.length === 0) this.inc("patch", identifier, identifierBase);
					this.inc("pre", identifier, identifierBase);
					break;
				case "release":
					if (this.prerelease.length === 0) throw new Error(`version ${this.raw} is not a prerelease`);
					this.prerelease.length = 0;
					break;
				case "major":
					if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
					this.minor = 0;
					this.patch = 0;
					this.prerelease = [];
					break;
				case "minor":
					if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
					this.patch = 0;
					this.prerelease = [];
					break;
				case "patch":
					if (this.prerelease.length === 0) this.patch++;
					this.prerelease = [];
					break;
				case "pre": {
					const base = Number(identifierBase) ? 1 : 0;
					if (this.prerelease.length === 0) this.prerelease = [base];
					else {
						let i$1 = this.prerelease.length;
						while (--i$1 >= 0) if (typeof this.prerelease[i$1] === "number") {
							this.prerelease[i$1]++;
							i$1 = -2;
						}
						if (i$1 === -1) {
							if (identifier === this.prerelease.join(".") && identifierBase === false) throw new Error("invalid increment argument: identifier already exists");
							this.prerelease.push(base);
						}
					}
					if (identifier) {
						let prerelease$2 = [identifier, base];
						if (identifierBase === false) prerelease$2 = [identifier];
						if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
							if (isNaN(this.prerelease[1])) this.prerelease = prerelease$2;
						} else this.prerelease = prerelease$2;
					}
					break;
				}
				default: throw new Error(`invalid increment argument: ${release}`);
			}
			this.raw = this.format();
			if (this.build.length) this.raw += `+${this.build.join(".")}`;
			return this;
		}
	};
	module.exports = SemVer$15;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/parse.js
var require_parse = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/parse.js": ((exports, module) => {
	const SemVer$14 = require_semver$1();
	const parse$7 = (version$2, options, throwErrors = false) => {
		if (version$2 instanceof SemVer$14) return version$2;
		try {
			return new SemVer$14(version$2, options);
		} catch (er) {
			if (!throwErrors) return null;
			throw er;
		}
	};
	module.exports = parse$7;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/valid.js
var require_valid$1 = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/valid.js": ((exports, module) => {
	const parse$6 = require_parse();
	const valid$1 = (version$2, options) => {
		const v = parse$6(version$2, options);
		return v ? v.version : null;
	};
	module.exports = valid$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/clean.js
var require_clean = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/clean.js": ((exports, module) => {
	const parse$5 = require_parse();
	const clean$1 = (version$2, options) => {
		const s = parse$5(version$2.trim().replace(/^[=v]+/, ""), options);
		return s ? s.version : null;
	};
	module.exports = clean$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/inc.js
var require_inc = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/inc.js": ((exports, module) => {
	const SemVer$13 = require_semver$1();
	const inc$1 = (version$2, release, options, identifier, identifierBase) => {
		if (typeof options === "string") {
			identifierBase = identifier;
			identifier = options;
			options = void 0;
		}
		try {
			return new SemVer$13(version$2 instanceof SemVer$13 ? version$2.version : version$2, options).inc(release, identifier, identifierBase).version;
		} catch (er) {
			return null;
		}
	};
	module.exports = inc$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/diff.js
var require_diff = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/diff.js": ((exports, module) => {
	const parse$4 = require_parse();
	const diff$1 = (version1, version2) => {
		const v1 = parse$4(version1, null, true);
		const v2 = parse$4(version2, null, true);
		const comparison = v1.compare(v2);
		if (comparison === 0) return null;
		const v1Higher = comparison > 0;
		const highVersion = v1Higher ? v1 : v2;
		const lowVersion = v1Higher ? v2 : v1;
		const highHasPre = !!highVersion.prerelease.length;
		if (!!lowVersion.prerelease.length && !highHasPre) {
			if (!lowVersion.patch && !lowVersion.minor) return "major";
			if (lowVersion.compareMain(highVersion) === 0) {
				if (lowVersion.minor && !lowVersion.patch) return "minor";
				return "patch";
			}
		}
		const prefix = highHasPre ? "pre" : "";
		if (v1.major !== v2.major) return prefix + "major";
		if (v1.minor !== v2.minor) return prefix + "minor";
		if (v1.patch !== v2.patch) return prefix + "patch";
		return "prerelease";
	};
	module.exports = diff$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/major.js
var require_major = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/major.js": ((exports, module) => {
	const SemVer$12 = require_semver$1();
	const major$1 = (a, loose) => new SemVer$12(a, loose).major;
	module.exports = major$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/minor.js
var require_minor = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/minor.js": ((exports, module) => {
	const SemVer$11 = require_semver$1();
	const minor$1 = (a, loose) => new SemVer$11(a, loose).minor;
	module.exports = minor$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/patch.js
var require_patch = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/patch.js": ((exports, module) => {
	const SemVer$10 = require_semver$1();
	const patch$1 = (a, loose) => new SemVer$10(a, loose).patch;
	module.exports = patch$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/prerelease.js
var require_prerelease = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/prerelease.js": ((exports, module) => {
	const parse$3 = require_parse();
	const prerelease$1 = (version$2, options) => {
		const parsed = parse$3(version$2, options);
		return parsed && parsed.prerelease.length ? parsed.prerelease : null;
	};
	module.exports = prerelease$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare.js
var require_compare = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare.js": ((exports, module) => {
	const SemVer$9 = require_semver$1();
	const compare$11 = (a, b, loose) => new SemVer$9(a, loose).compare(new SemVer$9(b, loose));
	module.exports = compare$11;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rcompare.js
var require_rcompare = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rcompare.js": ((exports, module) => {
	const compare$10 = require_compare();
	const rcompare$1 = (a, b, loose) => compare$10(b, a, loose);
	module.exports = rcompare$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-loose.js
var require_compare_loose = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-loose.js": ((exports, module) => {
	const compare$9 = require_compare();
	const compareLoose$1 = (a, b) => compare$9(a, b, true);
	module.exports = compareLoose$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-build.js
var require_compare_build = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-build.js": ((exports, module) => {
	const SemVer$8 = require_semver$1();
	const compareBuild$3 = (a, b, loose) => {
		const versionA = new SemVer$8(a, loose);
		const versionB = new SemVer$8(b, loose);
		return versionA.compare(versionB) || versionA.compareBuild(versionB);
	};
	module.exports = compareBuild$3;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/sort.js
var require_sort = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/sort.js": ((exports, module) => {
	const compareBuild$2 = require_compare_build();
	const sort$1 = (list$1, loose) => list$1.sort((a, b) => compareBuild$2(a, b, loose));
	module.exports = sort$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rsort.js
var require_rsort = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rsort.js": ((exports, module) => {
	const compareBuild$1 = require_compare_build();
	const rsort$1 = (list$1, loose) => list$1.sort((a, b) => compareBuild$1(b, a, loose));
	module.exports = rsort$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gt.js
var require_gt = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gt.js": ((exports, module) => {
	const compare$8 = require_compare();
	const gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
	module.exports = gt$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lt.js
var require_lt = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lt.js": ((exports, module) => {
	const compare$7 = require_compare();
	const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
	module.exports = lt$3;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/eq.js
var require_eq = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/eq.js": ((exports, module) => {
	const compare$6 = require_compare();
	const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
	module.exports = eq$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/neq.js
var require_neq = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/neq.js": ((exports, module) => {
	const compare$5 = require_compare();
	const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
	module.exports = neq$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gte.js
var require_gte = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gte.js": ((exports, module) => {
	const compare$4 = require_compare();
	const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
	module.exports = gte$3;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lte.js
var require_lte = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lte.js": ((exports, module) => {
	const compare$3 = require_compare();
	const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
	module.exports = lte$3;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/cmp.js
var require_cmp = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/cmp.js": ((exports, module) => {
	const eq$1 = require_eq();
	const neq$1 = require_neq();
	const gt$3 = require_gt();
	const gte$2 = require_gte();
	const lt$2 = require_lt();
	const lte$2 = require_lte();
	const cmp$2 = (a, op, b, loose) => {
		switch (op) {
			case "===":
				if (typeof a === "object") a = a.version;
				if (typeof b === "object") b = b.version;
				return a === b;
			case "!==":
				if (typeof a === "object") a = a.version;
				if (typeof b === "object") b = b.version;
				return a !== b;
			case "":
			case "=":
			case "==": return eq$1(a, b, loose);
			case "!=": return neq$1(a, b, loose);
			case ">": return gt$3(a, b, loose);
			case ">=": return gte$2(a, b, loose);
			case "<": return lt$2(a, b, loose);
			case "<=": return lte$2(a, b, loose);
			default: throw new TypeError(`Invalid operator: ${op}`);
		}
	};
	module.exports = cmp$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/coerce.js
var require_coerce = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/coerce.js": ((exports, module) => {
	const SemVer$7 = require_semver$1();
	const parse$2 = require_parse();
	const { safeRe: re$2, t: t$2 } = require_re();
	const coerce$1 = (version$2, options) => {
		if (version$2 instanceof SemVer$7) return version$2;
		if (typeof version$2 === "number") version$2 = String(version$2);
		if (typeof version$2 !== "string") return null;
		options = options || {};
		let match = null;
		if (!options.rtl) match = version$2.match(options.includePrerelease ? re$2[t$2.COERCEFULL] : re$2[t$2.COERCE]);
		else {
			const coerceRtlRegex = options.includePrerelease ? re$2[t$2.COERCERTLFULL] : re$2[t$2.COERCERTL];
			let next;
			while ((next = coerceRtlRegex.exec(version$2)) && (!match || match.index + match[0].length !== version$2.length)) {
				if (!match || next.index + next[0].length !== match.index + match[0].length) match = next;
				coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
			}
			coerceRtlRegex.lastIndex = -1;
		}
		if (match === null) return null;
		const major$2 = match[2];
		return parse$2(`${major$2}.${match[3] || "0"}.${match[4] || "0"}${options.includePrerelease && match[5] ? `-${match[5]}` : ""}${options.includePrerelease && match[6] ? `+${match[6]}` : ""}`, options);
	};
	module.exports = coerce$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/lrucache.js
var require_lrucache = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/lrucache.js": ((exports, module) => {
	var LRUCache = class {
		constructor() {
			this.max = 1e3;
			this.map = /* @__PURE__ */ new Map();
		}
		get(key) {
			const value = this.map.get(key);
			if (value === void 0) return;
			else {
				this.map.delete(key);
				this.map.set(key, value);
				return value;
			}
		}
		delete(key) {
			return this.map.delete(key);
		}
		set(key, value) {
			if (!this.delete(key) && value !== void 0) {
				if (this.map.size >= this.max) {
					const firstKey = this.map.keys().next().value;
					this.delete(firstKey);
				}
				this.map.set(key, value);
			}
			return this;
		}
	};
	module.exports = LRUCache;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/range.js
var require_range = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/range.js": ((exports, module) => {
	const SPACE_CHARACTERS = /\s+/g;
	var Range$11 = class Range$11 {
		constructor(range, options) {
			options = parseOptions$1(options);
			if (range instanceof Range$11) if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) return range;
			else return new Range$11(range.raw, options);
			if (range instanceof Comparator$4) {
				this.raw = range.value;
				this.set = [[range]];
				this.formatted = void 0;
				return this;
			}
			this.options = options;
			this.loose = !!options.loose;
			this.includePrerelease = !!options.includePrerelease;
			this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
			this.set = this.raw.split("||").map((r$1) => this.parseRange(r$1.trim())).filter((c) => c.length);
			if (!this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
			if (this.set.length > 1) {
				const first = this.set[0];
				this.set = this.set.filter((c) => !isNullSet(c[0]));
				if (this.set.length === 0) this.set = [first];
				else if (this.set.length > 1) {
					for (const c of this.set) if (c.length === 1 && isAny(c[0])) {
						this.set = [c];
						break;
					}
				}
			}
			this.formatted = void 0;
		}
		get range() {
			if (this.formatted === void 0) {
				this.formatted = "";
				for (let i$1 = 0; i$1 < this.set.length; i$1++) {
					if (i$1 > 0) this.formatted += "||";
					const comps = this.set[i$1];
					for (let k = 0; k < comps.length; k++) {
						if (k > 0) this.formatted += " ";
						this.formatted += comps[k].toString().trim();
					}
				}
			}
			return this.formatted;
		}
		format() {
			return this.range;
		}
		toString() {
			return this.range;
		}
		parseRange(range) {
			const memoKey = ((this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE)) + ":" + range;
			const cached = cache$1.get(memoKey);
			if (cached) return cached;
			const loose = this.options.loose;
			const hr = loose ? re$1[t$1.HYPHENRANGELOOSE] : re$1[t$1.HYPHENRANGE];
			range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
			debug$1("hyphen replace", range);
			range = range.replace(re$1[t$1.COMPARATORTRIM], comparatorTrimReplace);
			debug$1("comparator trim", range);
			range = range.replace(re$1[t$1.TILDETRIM], tildeTrimReplace);
			debug$1("tilde trim", range);
			range = range.replace(re$1[t$1.CARETTRIM], caretTrimReplace);
			debug$1("caret trim", range);
			let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
			if (loose) rangeList = rangeList.filter((comp) => {
				debug$1("loose invalid filter", comp, this.options);
				return !!comp.match(re$1[t$1.COMPARATORLOOSE]);
			});
			debug$1("range list", rangeList);
			const rangeMap = /* @__PURE__ */ new Map();
			const comparators = rangeList.map((comp) => new Comparator$4(comp, this.options));
			for (const comp of comparators) {
				if (isNullSet(comp)) return [comp];
				rangeMap.set(comp.value, comp);
			}
			if (rangeMap.size > 1 && rangeMap.has("")) rangeMap.delete("");
			const result = [...rangeMap.values()];
			cache$1.set(memoKey, result);
			return result;
		}
		intersects(range, options) {
			if (!(range instanceof Range$11)) throw new TypeError("a Range is required");
			return this.set.some((thisComparators) => {
				return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
					return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
						return rangeComparators.every((rangeComparator) => {
							return thisComparator.intersects(rangeComparator, options);
						});
					});
				});
			});
		}
		test(version$2) {
			if (!version$2) return false;
			if (typeof version$2 === "string") try {
				version$2 = new SemVer$6(version$2, this.options);
			} catch (er) {
				return false;
			}
			for (let i$1 = 0; i$1 < this.set.length; i$1++) if (testSet(this.set[i$1], version$2, this.options)) return true;
			return false;
		}
	};
	module.exports = Range$11;
	const cache$1 = new (require_lrucache())();
	const parseOptions$1 = require_parse_options();
	const Comparator$4 = require_comparator();
	const debug$1 = require_debug();
	const SemVer$6 = require_semver$1();
	const { safeRe: re$1, t: t$1, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = require_re();
	const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
	const isNullSet = (c) => c.value === "<0.0.0-0";
	const isAny = (c) => c.value === "";
	const isSatisfiable = (comparators, options) => {
		let result = true;
		const remainingComparators = comparators.slice();
		let testComparator = remainingComparators.pop();
		while (result && remainingComparators.length) {
			result = remainingComparators.every((otherComparator) => {
				return testComparator.intersects(otherComparator, options);
			});
			testComparator = remainingComparators.pop();
		}
		return result;
	};
	const parseComparator = (comp, options) => {
		comp = comp.replace(re$1[t$1.BUILD], "");
		debug$1("comp", comp, options);
		comp = replaceCarets(comp, options);
		debug$1("caret", comp);
		comp = replaceTildes(comp, options);
		debug$1("tildes", comp);
		comp = replaceXRanges(comp, options);
		debug$1("xrange", comp);
		comp = replaceStars(comp, options);
		debug$1("stars", comp);
		return comp;
	};
	const isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
	const replaceTildes = (comp, options) => {
		return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
	};
	const replaceTilde = (comp, options) => {
		const r$1 = options.loose ? re$1[t$1.TILDELOOSE] : re$1[t$1.TILDE];
		return comp.replace(r$1, (_, M, m, p, pr) => {
			debug$1("tilde", comp, _, M, m, p, pr);
			let ret;
			if (isX(M)) ret = "";
			else if (isX(m)) ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
			else if (isX(p)) ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
			else if (pr) {
				debug$1("replaceTilde pr", pr);
				ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
			} else ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
			debug$1("tilde return", ret);
			return ret;
		});
	};
	const replaceCarets = (comp, options) => {
		return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
	};
	const replaceCaret = (comp, options) => {
		debug$1("caret", comp, options);
		const r$1 = options.loose ? re$1[t$1.CARETLOOSE] : re$1[t$1.CARET];
		const z = options.includePrerelease ? "-0" : "";
		return comp.replace(r$1, (_, M, m, p, pr) => {
			debug$1("caret", comp, _, M, m, p, pr);
			let ret;
			if (isX(M)) ret = "";
			else if (isX(m)) ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
			else if (isX(p)) if (M === "0") ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
			else ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
			else if (pr) {
				debug$1("replaceCaret pr", pr);
				if (M === "0") if (m === "0") ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
				else ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
				else ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
			} else {
				debug$1("no pr");
				if (M === "0") if (m === "0") ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
				else ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
				else ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
			}
			debug$1("caret return", ret);
			return ret;
		});
	};
	const replaceXRanges = (comp, options) => {
		debug$1("replaceXRanges", comp, options);
		return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
	};
	const replaceXRange = (comp, options) => {
		comp = comp.trim();
		const r$1 = options.loose ? re$1[t$1.XRANGELOOSE] : re$1[t$1.XRANGE];
		return comp.replace(r$1, (ret, gtlt, M, m, p, pr) => {
			debug$1("xRange", comp, ret, gtlt, M, m, p, pr);
			const xM = isX(M);
			const xm = xM || isX(m);
			const xp = xm || isX(p);
			const anyX = xp;
			if (gtlt === "=" && anyX) gtlt = "";
			pr = options.includePrerelease ? "-0" : "";
			if (xM) if (gtlt === ">" || gtlt === "<") ret = "<0.0.0-0";
			else ret = "*";
			else if (gtlt && anyX) {
				if (xm) m = 0;
				p = 0;
				if (gtlt === ">") {
					gtlt = ">=";
					if (xm) {
						M = +M + 1;
						m = 0;
						p = 0;
					} else {
						m = +m + 1;
						p = 0;
					}
				} else if (gtlt === "<=") {
					gtlt = "<";
					if (xm) M = +M + 1;
					else m = +m + 1;
				}
				if (gtlt === "<") pr = "-0";
				ret = `${gtlt + M}.${m}.${p}${pr}`;
			} else if (xm) ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
			else if (xp) ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
			debug$1("xRange return", ret);
			return ret;
		});
	};
	const replaceStars = (comp, options) => {
		debug$1("replaceStars", comp, options);
		return comp.trim().replace(re$1[t$1.STAR], "");
	};
	const replaceGTE0 = (comp, options) => {
		debug$1("replaceGTE0", comp, options);
		return comp.trim().replace(re$1[options.includePrerelease ? t$1.GTE0PRE : t$1.GTE0], "");
	};
	const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
		if (isX(fM)) from = "";
		else if (isX(fm)) from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
		else if (isX(fp)) from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
		else if (fpr) from = `>=${from}`;
		else from = `>=${from}${incPr ? "-0" : ""}`;
		if (isX(tM)) to = "";
		else if (isX(tm)) to = `<${+tM + 1}.0.0-0`;
		else if (isX(tp)) to = `<${tM}.${+tm + 1}.0-0`;
		else if (tpr) to = `<=${tM}.${tm}.${tp}-${tpr}`;
		else if (incPr) to = `<${tM}.${tm}.${+tp + 1}-0`;
		else to = `<=${to}`;
		return `${from} ${to}`.trim();
	};
	const testSet = (set, version$2, options) => {
		for (let i$1 = 0; i$1 < set.length; i$1++) if (!set[i$1].test(version$2)) return false;
		if (version$2.prerelease.length && !options.includePrerelease) {
			for (let i$1 = 0; i$1 < set.length; i$1++) {
				debug$1(set[i$1].semver);
				if (set[i$1].semver === Comparator$4.ANY) continue;
				if (set[i$1].semver.prerelease.length > 0) {
					const allowed = set[i$1].semver;
					if (allowed.major === version$2.major && allowed.minor === version$2.minor && allowed.patch === version$2.patch) return true;
				}
			}
			return false;
		}
		return true;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/comparator.js
var require_comparator = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/comparator.js": ((exports, module) => {
	const ANY$2 = Symbol("SemVer ANY");
	var Comparator$3 = class Comparator$3 {
		static get ANY() {
			return ANY$2;
		}
		constructor(comp, options) {
			options = parseOptions(options);
			if (comp instanceof Comparator$3) if (comp.loose === !!options.loose) return comp;
			else comp = comp.value;
			comp = comp.trim().split(/\s+/).join(" ");
			debug("comparator", comp, options);
			this.options = options;
			this.loose = !!options.loose;
			this.parse(comp);
			if (this.semver === ANY$2) this.value = "";
			else this.value = this.operator + this.semver.version;
			debug("comp", this);
		}
		parse(comp) {
			const r$1 = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
			const m = comp.match(r$1);
			if (!m) throw new TypeError(`Invalid comparator: ${comp}`);
			this.operator = m[1] !== void 0 ? m[1] : "";
			if (this.operator === "=") this.operator = "";
			if (!m[2]) this.semver = ANY$2;
			else this.semver = new SemVer$5(m[2], this.options.loose);
		}
		toString() {
			return this.value;
		}
		test(version$2) {
			debug("Comparator.test", version$2, this.options.loose);
			if (this.semver === ANY$2 || version$2 === ANY$2) return true;
			if (typeof version$2 === "string") try {
				version$2 = new SemVer$5(version$2, this.options);
			} catch (er) {
				return false;
			}
			return cmp$1(version$2, this.operator, this.semver, this.options);
		}
		intersects(comp, options) {
			if (!(comp instanceof Comparator$3)) throw new TypeError("a Comparator is required");
			if (this.operator === "") {
				if (this.value === "") return true;
				return new Range$10(comp.value, options).test(this.value);
			} else if (comp.operator === "") {
				if (comp.value === "") return true;
				return new Range$10(this.value, options).test(comp.semver);
			}
			options = parseOptions(options);
			if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) return false;
			if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) return false;
			if (this.operator.startsWith(">") && comp.operator.startsWith(">")) return true;
			if (this.operator.startsWith("<") && comp.operator.startsWith("<")) return true;
			if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) return true;
			if (cmp$1(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) return true;
			if (cmp$1(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) return true;
			return false;
		}
	};
	module.exports = Comparator$3;
	const parseOptions = require_parse_options();
	const { safeRe: re, t } = require_re();
	const cmp$1 = require_cmp();
	const debug = require_debug();
	const SemVer$5 = require_semver$1();
	const Range$10 = require_range();
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/satisfies.js
var require_satisfies = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/satisfies.js": ((exports, module) => {
	const Range$9 = require_range();
	const satisfies$5 = (version$2, range, options) => {
		try {
			range = new Range$9(range, options);
		} catch (er) {
			return false;
		}
		return range.test(version$2);
	};
	module.exports = satisfies$5;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/to-comparators.js": ((exports, module) => {
	const Range$8 = require_range();
	const toComparators$1 = (range, options) => new Range$8(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
	module.exports = toComparators$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/max-satisfying.js": ((exports, module) => {
	const SemVer$4 = require_semver$1();
	const Range$7 = require_range();
	const maxSatisfying$1 = (versions, range, options) => {
		let max = null;
		let maxSV = null;
		let rangeObj = null;
		try {
			rangeObj = new Range$7(range, options);
		} catch (er) {
			return null;
		}
		versions.forEach((v) => {
			if (rangeObj.test(v)) {
				if (!max || maxSV.compare(v) === -1) {
					max = v;
					maxSV = new SemVer$4(max, options);
				}
			}
		});
		return max;
	};
	module.exports = maxSatisfying$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-satisfying.js": ((exports, module) => {
	const SemVer$3 = require_semver$1();
	const Range$6 = require_range();
	const minSatisfying$1 = (versions, range, options) => {
		let min = null;
		let minSV = null;
		let rangeObj = null;
		try {
			rangeObj = new Range$6(range, options);
		} catch (er) {
			return null;
		}
		versions.forEach((v) => {
			if (rangeObj.test(v)) {
				if (!min || minSV.compare(v) === 1) {
					min = v;
					minSV = new SemVer$3(min, options);
				}
			}
		});
		return min;
	};
	module.exports = minSatisfying$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-version.js
var require_min_version = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-version.js": ((exports, module) => {
	const SemVer$2 = require_semver$1();
	const Range$5 = require_range();
	const gt$2 = require_gt();
	const minVersion$1 = (range, loose) => {
		range = new Range$5(range, loose);
		let minver = new SemVer$2("0.0.0");
		if (range.test(minver)) return minver;
		minver = new SemVer$2("0.0.0-0");
		if (range.test(minver)) return minver;
		minver = null;
		for (let i$1 = 0; i$1 < range.set.length; ++i$1) {
			const comparators = range.set[i$1];
			let setMin = null;
			comparators.forEach((comparator) => {
				const compver = new SemVer$2(comparator.semver.version);
				switch (comparator.operator) {
					case ">":
						if (compver.prerelease.length === 0) compver.patch++;
						else compver.prerelease.push(0);
						compver.raw = compver.format();
					case "":
					case ">=":
						if (!setMin || gt$2(compver, setMin)) setMin = compver;
						break;
					case "<":
					case "<=": break;
					default: throw new Error(`Unexpected operation: ${comparator.operator}`);
				}
			});
			if (setMin && (!minver || gt$2(minver, setMin))) minver = setMin;
		}
		if (minver && range.test(minver)) return minver;
		return null;
	};
	module.exports = minVersion$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/valid.js
var require_valid = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/valid.js": ((exports, module) => {
	const Range$4 = require_range();
	const validRange$1 = (range, options) => {
		try {
			return new Range$4(range, options).range || "*";
		} catch (er) {
			return null;
		}
	};
	module.exports = validRange$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/outside.js
var require_outside = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/outside.js": ((exports, module) => {
	const SemVer$1 = require_semver$1();
	const Comparator$2 = require_comparator();
	const { ANY: ANY$1 } = Comparator$2;
	const Range$3 = require_range();
	const satisfies$4 = require_satisfies();
	const gt$1 = require_gt();
	const lt$1 = require_lt();
	const lte$1 = require_lte();
	const gte$1 = require_gte();
	const outside$3 = (version$2, range, hilo, options) => {
		version$2 = new SemVer$1(version$2, options);
		range = new Range$3(range, options);
		let gtfn, ltefn, ltfn, comp, ecomp;
		switch (hilo) {
			case ">":
				gtfn = gt$1;
				ltefn = lte$1;
				ltfn = lt$1;
				comp = ">";
				ecomp = ">=";
				break;
			case "<":
				gtfn = lt$1;
				ltefn = gte$1;
				ltfn = gt$1;
				comp = "<";
				ecomp = "<=";
				break;
			default: throw new TypeError("Must provide a hilo val of \"<\" or \">\"");
		}
		if (satisfies$4(version$2, range, options)) return false;
		for (let i$1 = 0; i$1 < range.set.length; ++i$1) {
			const comparators = range.set[i$1];
			let high = null;
			let low = null;
			comparators.forEach((comparator) => {
				if (comparator.semver === ANY$1) comparator = new Comparator$2(">=0.0.0");
				high = high || comparator;
				low = low || comparator;
				if (gtfn(comparator.semver, high.semver, options)) high = comparator;
				else if (ltfn(comparator.semver, low.semver, options)) low = comparator;
			});
			if (high.operator === comp || high.operator === ecomp) return false;
			if ((!low.operator || low.operator === comp) && ltefn(version$2, low.semver)) return false;
			else if (low.operator === ecomp && ltfn(version$2, low.semver)) return false;
		}
		return true;
	};
	module.exports = outside$3;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/gtr.js
var require_gtr = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/gtr.js": ((exports, module) => {
	const outside$2 = require_outside();
	const gtr$1 = (version$2, range, options) => outside$2(version$2, range, ">", options);
	module.exports = gtr$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/ltr.js
var require_ltr = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/ltr.js": ((exports, module) => {
	const outside$1 = require_outside();
	const ltr$1 = (version$2, range, options) => outside$1(version$2, range, "<", options);
	module.exports = ltr$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/intersects.js
var require_intersects = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/intersects.js": ((exports, module) => {
	const Range$2 = require_range();
	const intersects$1 = (r1, r2, options) => {
		r1 = new Range$2(r1, options);
		r2 = new Range$2(r2, options);
		return r1.intersects(r2, options);
	};
	module.exports = intersects$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/simplify.js
var require_simplify = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/simplify.js": ((exports, module) => {
	const satisfies$3 = require_satisfies();
	const compare$2 = require_compare();
	module.exports = (versions, range, options) => {
		const set = [];
		let first = null;
		let prev = null;
		const v = versions.sort((a, b) => compare$2(a, b, options));
		for (const version$2 of v) if (satisfies$3(version$2, range, options)) {
			prev = version$2;
			if (!first) first = version$2;
		} else {
			if (prev) set.push([first, prev]);
			prev = null;
			first = null;
		}
		if (first) set.push([first, null]);
		const ranges = [];
		for (const [min, max] of set) if (min === max) ranges.push(min);
		else if (!max && min === v[0]) ranges.push("*");
		else if (!max) ranges.push(`>=${min}`);
		else if (min === v[0]) ranges.push(`<=${max}`);
		else ranges.push(`${min} - ${max}`);
		const simplified = ranges.join(" || ");
		const original = typeof range.raw === "string" ? range.raw : String(range);
		return simplified.length < original.length ? simplified : range;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/subset.js
var require_subset = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/subset.js": ((exports, module) => {
	const Range$1 = require_range();
	const Comparator$1 = require_comparator();
	const { ANY } = Comparator$1;
	const satisfies$2 = require_satisfies();
	const compare$1 = require_compare();
	const subset$1 = (sub, dom, options = {}) => {
		if (sub === dom) return true;
		sub = new Range$1(sub, options);
		dom = new Range$1(dom, options);
		let sawNonNull = false;
		OUTER: for (const simpleSub of sub.set) {
			for (const simpleDom of dom.set) {
				const isSub = simpleSubset(simpleSub, simpleDom, options);
				sawNonNull = sawNonNull || isSub !== null;
				if (isSub) continue OUTER;
			}
			if (sawNonNull) return false;
		}
		return true;
	};
	const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
	const minimumVersion = [new Comparator$1(">=0.0.0")];
	const simpleSubset = (sub, dom, options) => {
		if (sub === dom) return true;
		if (sub.length === 1 && sub[0].semver === ANY) if (dom.length === 1 && dom[0].semver === ANY) return true;
		else if (options.includePrerelease) sub = minimumVersionWithPreRelease;
		else sub = minimumVersion;
		if (dom.length === 1 && dom[0].semver === ANY) if (options.includePrerelease) return true;
		else dom = minimumVersion;
		const eqSet = /* @__PURE__ */ new Set();
		let gt$5, lt$4;
		for (const c of sub) if (c.operator === ">" || c.operator === ">=") gt$5 = higherGT(gt$5, c, options);
		else if (c.operator === "<" || c.operator === "<=") lt$4 = lowerLT(lt$4, c, options);
		else eqSet.add(c.semver);
		if (eqSet.size > 1) return null;
		let gtltComp;
		if (gt$5 && lt$4) {
			gtltComp = compare$1(gt$5.semver, lt$4.semver, options);
			if (gtltComp > 0) return null;
			else if (gtltComp === 0 && (gt$5.operator !== ">=" || lt$4.operator !== "<=")) return null;
		}
		for (const eq$3 of eqSet) {
			if (gt$5 && !satisfies$2(eq$3, String(gt$5), options)) return null;
			if (lt$4 && !satisfies$2(eq$3, String(lt$4), options)) return null;
			for (const c of dom) if (!satisfies$2(eq$3, String(c), options)) return false;
			return true;
		}
		let higher, lower;
		let hasDomLT, hasDomGT;
		let needDomLTPre = lt$4 && !options.includePrerelease && lt$4.semver.prerelease.length ? lt$4.semver : false;
		let needDomGTPre = gt$5 && !options.includePrerelease && gt$5.semver.prerelease.length ? gt$5.semver : false;
		if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt$4.operator === "<" && needDomLTPre.prerelease[0] === 0) needDomLTPre = false;
		for (const c of dom) {
			hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
			hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
			if (gt$5) {
				if (needDomGTPre) {
					if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) needDomGTPre = false;
				}
				if (c.operator === ">" || c.operator === ">=") {
					higher = higherGT(gt$5, c, options);
					if (higher === c && higher !== gt$5) return false;
				} else if (gt$5.operator === ">=" && !satisfies$2(gt$5.semver, String(c), options)) return false;
			}
			if (lt$4) {
				if (needDomLTPre) {
					if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) needDomLTPre = false;
				}
				if (c.operator === "<" || c.operator === "<=") {
					lower = lowerLT(lt$4, c, options);
					if (lower === c && lower !== lt$4) return false;
				} else if (lt$4.operator === "<=" && !satisfies$2(lt$4.semver, String(c), options)) return false;
			}
			if (!c.operator && (lt$4 || gt$5) && gtltComp !== 0) return false;
		}
		if (gt$5 && hasDomLT && !lt$4 && gtltComp !== 0) return false;
		if (lt$4 && hasDomGT && !gt$5 && gtltComp !== 0) return false;
		if (needDomGTPre || needDomLTPre) return false;
		return true;
	};
	const higherGT = (a, b, options) => {
		if (!a) return b;
		const comp = compare$1(a.semver, b.semver, options);
		return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
	};
	const lowerLT = (a, b, options) => {
		if (!a) return b;
		const comp = compare$1(a.semver, b.semver, options);
		return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
	};
	module.exports = subset$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/index.js
var require_semver = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/semver@7.7.3/node_modules/semver/index.js": ((exports, module) => {
	const internalRe = require_re();
	const constants = require_constants();
	const SemVer = require_semver$1();
	const identifiers = require_identifiers();
	const parse$1 = require_parse();
	const valid = require_valid$1();
	const clean = require_clean();
	const inc = require_inc();
	const diff = require_diff();
	const major = require_major();
	const minor = require_minor();
	const patch = require_patch();
	const prerelease = require_prerelease();
	const compare = require_compare();
	const rcompare = require_rcompare();
	const compareLoose = require_compare_loose();
	const compareBuild = require_compare_build();
	const sort = require_sort();
	const rsort = require_rsort();
	const gt = require_gt();
	const lt = require_lt();
	const eq = require_eq();
	const neq = require_neq();
	const gte = require_gte();
	const lte = require_lte();
	const cmp = require_cmp();
	const coerce = require_coerce();
	const Comparator = require_comparator();
	const Range = require_range();
	const satisfies$1 = require_satisfies();
	const toComparators = require_to_comparators();
	const maxSatisfying = require_max_satisfying();
	const minSatisfying = require_min_satisfying();
	const minVersion = require_min_version();
	const validRange = require_valid();
	const outside = require_outside();
	const gtr = require_gtr();
	const ltr = require_ltr();
	const intersects = require_intersects();
	const simplifyRange = require_simplify();
	const subset = require_subset();
	module.exports = {
		parse: parse$1,
		valid,
		clean,
		inc,
		diff,
		major,
		minor,
		patch,
		prerelease,
		compare,
		rcompare,
		compareLoose,
		compareBuild,
		sort,
		rsort,
		gt,
		lt,
		eq,
		neq,
		gte,
		lte,
		cmp,
		coerce,
		Comparator,
		Range,
		satisfies: satisfies$1,
		toComparators,
		maxSatisfying,
		minSatisfying,
		minVersion,
		validRange,
		outside,
		gtr,
		ltr,
		intersects,
		simplifyRange,
		subset,
		SemVer,
		re: internalRe.re,
		src: internalRe.src,
		tokens: internalRe.t,
		SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
		RELEASE_TYPES: constants.RELEASE_TYPES,
		compareIdentifiers: identifiers.compareIdentifiers,
		rcompareIdentifiers: identifiers.rcompareIdentifiers
	};
}) });

//#endregion
//#region src/assert-wrangler-version.ts
var import_semver = require_semver();
/**
* Asserts that the installed version of Wrangler that gets pulled in at runtime by the `@cloudflare/vite-plugin`
* matches the version that `@cloudflare/vite-plugin` actually depends upon.
*
* This can sometime be broken by package managers that deduplicate dependencies, such as `pnpm`.
*/
async function assertWranglerVersion() {
	const installedVersion = (await import("wrangler/package.json", { with: { type: "json" } })).default.version;
	const peerDependency = (await import("../package.json", { with: { type: "json" } })).default.peerDependencies.wrangler;
	if (peerDependency.startsWith("workspace:")) return;
	if (!(0, import_semver.satisfies)(installedVersion, peerDependency)) throw new Error(`The installed version of Wrangler (${installedVersion}) does not satisfy the peer dependency required by @cloudflare/vite-plugin (${peerDependency}).\nPlease install wrangler@${peerDependency}.`);
}

//#endregion
//#region src/utils.ts
var import_gte = /* @__PURE__ */ __toESM$1(require_gte(), 1);
const debuglog = util$1.debuglog("@cloudflare:vite-plugin");
/**
* Creates an internal plugin to be used inside the main `vite-plugin-cloudflare` plugin.
* The provided `name` will be prefixed with `vite-plugin-cloudflare:`.
*/
function createPlugin(name, pluginFactory) {
	return (ctx) => {
		return {
			name: `vite-plugin-cloudflare:${name}`,
			sharedDuringBuild: true,
			...pluginFactory(ctx)
		};
	};
}
function getOutputDirectory(userConfig, environmentName) {
	const rootOutputDirectory = userConfig.build?.outDir ?? "dist";
	return userConfig.environments?.[environmentName]?.build?.outDir ?? nodePath.join(rootOutputDirectory, environmentName);
}
const postfixRE = /[?#].*$/;
function cleanUrl(url) {
	return url.replace(postfixRE, "");
}
function withTrailingSlash(path) {
	return path.endsWith("/") ? path : `${path}/`;
}
function createRequestHandler(handler) {
	return async (req, res, next) => {
		let request$1;
		try {
			if (req.originalUrl) req.url = req.originalUrl;
			request$1 = createRequest(req, res);
			let response = await handler(toMiniflareRequest(request$1), req);
			if (req.httpVersionMajor === 2) {
				response = new Response$1(response.body, response);
				response.headers.delete("transfer-encoding");
			}
			await sendResponse(res, response);
		} catch (error) {
			if (request$1?.signal.aborted) return;
			next(error);
		}
	};
}
function satisfiesViteVersion(minVersion$2) {
	return (0, import_gte.default)(version, minVersion$2);
}
function toMiniflareRequest(request$1) {
	const host = request$1.headers.get("Host");
	const xForwardedHost = request$1.headers.get("X-Forwarded-Host");
	if (host && !xForwardedHost) request$1.headers.set("X-Forwarded-Host", host);
	const secFetchMode = request$1.headers.get("Sec-Fetch-Mode");
	if (secFetchMode) request$1.headers.set(CoreHeaders.SEC_FETCH_MODE, secFetchMode);
	return new Request$1(request$1.url, {
		method: request$1.method,
		headers: [["accept-encoding", "identity"], ...request$1.headers],
		body: request$1.body,
		duplex: "half",
		signal: request$1.signal
	});
}

//#endregion
//#region src/export-types.ts
function getWorkerNameToWorkerEntrypointExportsMap(workers) {
	const workerNameToWorkerEntrypointExportsMap = new Map(workers.map((worker) => [worker.config.name, /* @__PURE__ */ new Set()]));
	for (const worker of workers) for (const value of worker.config.services ?? []) if (value.entrypoint !== void 0 && value.entrypoint !== "default") workerNameToWorkerEntrypointExportsMap.get(value.service)?.add(value.entrypoint);
	return workerNameToWorkerEntrypointExportsMap;
}
function getWorkerNameToDurableObjectExportsMap(workers) {
	const workerNameToDurableObjectExportsMap = new Map(workers.map((worker) => [worker.config.name, new Set(wrangler.unstable_getDurableObjectClassNameToUseSQLiteMap(worker.config.migrations).keys())]));
	for (const worker of workers) for (const value of worker.config.durable_objects.bindings) if (value.script_name) workerNameToDurableObjectExportsMap.get(value.script_name)?.add(value.class_name);
	else workerNameToDurableObjectExportsMap.get(worker.config.name)?.add(value.class_name);
	return workerNameToDurableObjectExportsMap;
}
function getWorkerNameToWorkflowEntrypointExportsMap(workers) {
	const workerNameToWorkflowEntrypointExportsMap = new Map(workers.map((worker) => [worker.config.name, /* @__PURE__ */ new Set()]));
	for (const worker of workers) for (const value of worker.config.workflows) if (value.script_name) workerNameToWorkflowEntrypointExportsMap.get(value.script_name)?.add(value.class_name);
	else workerNameToWorkflowEntrypointExportsMap.get(worker.config.name)?.add(value.class_name);
	return workerNameToWorkflowEntrypointExportsMap;
}
/**
* Derives initial export types for all Workers from the Worker config files and returns them in a Map
*/
function getInitialWorkerNameToExportTypesMap(resolvedPluginConfig) {
	const workers = [...resolvedPluginConfig.environmentNameToWorkerMap.values()];
	const workerNameToWorkerEntrypointExportsMap = getWorkerNameToWorkerEntrypointExportsMap(workers);
	const workerNameToDurableObjectExportsMap = getWorkerNameToDurableObjectExportsMap(workers);
	const workerNameToWorkflowEntrypointExportsMap = getWorkerNameToWorkflowEntrypointExportsMap(workers);
	return new Map(workers.map((worker) => {
		const workerEntrypointExports = workerNameToWorkerEntrypointExportsMap.get(worker.config.name);
		assert(workerEntrypointExports, `WorkerEntrypoint exports not found for Worker "${worker.config.name}"`);
		const durableObjectExports = workerNameToDurableObjectExportsMap.get(worker.config.name);
		assert(durableObjectExports, `DurableObject exports not found for Worker "${worker.config.name}"`);
		const workflowEntrypointExports = workerNameToWorkflowEntrypointExportsMap.get(worker.config.name);
		assert(workflowEntrypointExports, `WorkflowEntrypoint exports not found for Worker "${worker.config.name}"`);
		const exportTypes = {};
		for (const exportName of workerEntrypointExports) exportTypes[exportName] = "WorkerEntrypoint";
		for (const exportName of durableObjectExports) exportTypes[exportName] = "DurableObject";
		for (const exportName of workflowEntrypointExports) exportTypes[exportName] = "WorkflowEntrypoint";
		return [worker.config.name, exportTypes];
	}));
}
/**
* Fetches the export types for all Workers and returns them in a Map
*/
async function getCurrentWorkerNameToExportTypesMap(resolvedPluginConfig, viteDevServer, miniflare) {
	await viteDevServer.environments.client.pluginContainer.buildStart();
	const results = await Promise.all([...resolvedPluginConfig.environmentNameToWorkerMap].map(async ([environmentName, worker]) => {
		debuglog(`Fetching export types for worker "${worker.config.name}"`);
		const exportTypes = await viteDevServer.environments[environmentName].fetchWorkerExportTypes(miniflare, worker.config);
		return [worker.config.name, exportTypes];
	}));
	return new Map(results);
}
/**
* Compares the export types for all Workers and returns `true` if any have changed
*/
function compareWorkerNameToExportTypesMaps(oldWorkerNameToExportTypesMap, newWorkerNameToExportTypesMap) {
	for (const workerName of newWorkerNameToExportTypesMap.keys()) {
		const oldExportTypes = oldWorkerNameToExportTypesMap.get(workerName);
		assert(oldExportTypes, "Expected old export types to be defined");
		const newExportTypes = newWorkerNameToExportTypesMap.get(workerName);
		assert(newExportTypes, "Expected new export types to be defined");
		if (compareExportTypes(oldExportTypes, newExportTypes)) return true;
	}
	return false;
}
/**
* Compares two `ExportTypes` objects and returns true if they do not match.
* Checks for added/removed exports and changed export types.
*/
function compareExportTypes(oldExportTypes, newExportTypes) {
	const oldKeys = Object.keys(oldExportTypes);
	const newKeys = Object.keys(newExportTypes);
	if (oldKeys.length !== newKeys.length) return true;
	for (const key of newKeys) if (!(key in oldExportTypes) || oldExportTypes[key] !== newExportTypes[key]) return true;
	return false;
}

//#endregion
//#region src/context.ts
/**
* Used to provide context to internal plugins.
* It should be reinstantiated each time the main plugin is created.
*/
var PluginContext = class {
	#sharedContext;
	#resolvedPluginConfig;
	#resolvedViteConfig;
	constructor(sharedContext$1) {
		this.#sharedContext = sharedContext$1;
	}
	/** Creates a new Miniflare instance or updates the existing instance */
	async startOrUpdateMiniflare(options) {
		if (!this.#sharedContext.miniflare) {
			debuglog("Creating new Miniflare instance");
			this.#sharedContext.miniflare = new Miniflare(options);
		} else {
			debuglog("Updating the existing Miniflare instance");
			await this.#sharedContext.miniflare.setOptions(options);
		}
		debuglog("Miniflare is ready");
	}
	async disposeMiniflare() {
		await this.#sharedContext.miniflare?.dispose();
		this.#sharedContext.miniflare = void 0;
	}
	get miniflare() {
		assert(this.#sharedContext.miniflare, "Expected `miniflare` to be defined");
		return this.#sharedContext.miniflare;
	}
	/**
	* Gets the resolved inspector port provided by Miniflare
	*/
	async getResolvedInspectorPort() {
		if (this.resolvedPluginConfig.inspectorPort === false || !this.#sharedContext.miniflare) return null;
		const miniflareInspectorUrl = await this.#sharedContext.miniflare.getInspectorURL();
		return Number.parseInt(miniflareInspectorUrl.port);
	}
	setWorkerNameToExportTypesMap(workerNameToExportTypesMap) {
		this.#sharedContext.workerNameToExportTypesMap = workerNameToExportTypesMap;
	}
	get workerNameToExportTypesMap() {
		if (!this.#sharedContext.workerNameToExportTypesMap) {
			if (this.resolvedPluginConfig.type !== "workers") return /* @__PURE__ */ new Map();
			return getInitialWorkerNameToExportTypesMap(this.resolvedPluginConfig);
		}
		return this.#sharedContext.workerNameToExportTypesMap;
	}
	setHasShownWorkerConfigWarnings(hasShownWorkerConfigWarnings) {
		this.#sharedContext.hasShownWorkerConfigWarnings = hasShownWorkerConfigWarnings;
	}
	get hasShownWorkerConfigWarnings() {
		return this.#sharedContext.hasShownWorkerConfigWarnings;
	}
	setIsRestartingDevServer(isRestartingDevServer) {
		this.#sharedContext.isRestartingDevServer = isRestartingDevServer;
	}
	get isRestartingDevServer() {
		return this.#sharedContext.isRestartingDevServer;
	}
	setResolvedPluginConfig(resolvedPluginConfig) {
		this.#resolvedPluginConfig = resolvedPluginConfig;
	}
	get resolvedPluginConfig() {
		assert(this.#resolvedPluginConfig, "Expected `resolvedPluginConfig` to be defined");
		return this.#resolvedPluginConfig;
	}
	setResolvedViteConfig(resolvedViteConfig) {
		this.#resolvedViteConfig = resolvedViteConfig;
	}
	get resolvedViteConfig() {
		assert(this.#resolvedViteConfig, "Expected `resolvedViteConfig` to be defined");
		return this.#resolvedViteConfig;
	}
	getWorkerConfig(environmentName) {
		return this.resolvedPluginConfig.type === "workers" ? this.resolvedPluginConfig.environmentNameToWorkerMap.get(environmentName)?.config : void 0;
	}
	get allWorkerConfigs() {
		switch (this.resolvedPluginConfig.type) {
			case "workers": return Array.from(this.resolvedPluginConfig.environmentNameToWorkerMap.values()).map((worker) => worker.config);
			case "preview": return this.resolvedPluginConfig.workers;
			default: return [];
		}
	}
	get entryWorkerConfig() {
		if (this.resolvedPluginConfig.type !== "workers") return;
		return this.resolvedPluginConfig.environmentNameToWorkerMap.get(this.resolvedPluginConfig.entryWorkerEnvironmentName)?.config;
	}
	getNodeJsCompat(environmentName) {
		return this.resolvedPluginConfig.type === "workers" ? this.resolvedPluginConfig.environmentNameToWorkerMap.get(environmentName)?.nodeJsCompat : void 0;
	}
};
function assertIsNotPreview(ctx) {
	assert(ctx.resolvedPluginConfig.type !== "preview", `Expected "assets-only" or "workers" plugin config`);
}
function assertIsPreview(ctx) {
	assert(ctx.resolvedPluginConfig.type === "preview", `Expected "preview" plugin config`);
}

//#endregion
//#region ../workers-shared/utils/configuration/constants.ts
const REDIRECTS_VERSION = 1;
const HEADERS_VERSION = 2;
const PERMITTED_STATUS_CODES = new Set([
	200,
	301,
	302,
	303,
	307,
	308
]);
const HEADER_SEPARATOR = ":";
const MAX_LINE_LENGTH = 2e3;
const MAX_HEADER_RULES = 100;
const MAX_DYNAMIC_REDIRECT_RULES = 100;
const MAX_STATIC_REDIRECT_RULES = 2e3;
const UNSET_OPERATOR = "! ";
const SPLAT_REGEX = /\*/g;
const PLACEHOLDER_REGEX = /:[A-Za-z]\w*/g;
/** Max number of rules in `run_worker_first` */
const MAX_ROUTES_RULES = 100;
/** Max char length of each rule in `run_worker_first` */
const MAX_ROUTES_RULE_LENGTH = 100;

//#endregion
//#region ../workers-shared/utils/configuration/parseStaticRouting.ts
function parseStaticRouting(input) {
	if (input.length === 0) throw new Error("No `run_worker_first` rules were provided; must provide at least 1 rule.");
	if (input.length > MAX_ROUTES_RULES) throw new Error(`Too many \`run_worker_first\` rules were provided; ${input.length} rules provided exceeds max of ${MAX_ROUTES_RULES}.`);
	const rawAssetWorkerRules = [];
	const assetWorkerRules = [];
	const userWorkerRules = [];
	const invalidRules = [];
	for (const rule of input) if (rule.startsWith("!/")) {
		assetWorkerRules.push(rule.slice(1));
		rawAssetWorkerRules.push(rule);
	} else if (rule.startsWith("/")) userWorkerRules.push(rule);
	else if (rule.startsWith("!")) invalidRules.push(`'${rule}': negative rules must start with '!/'`);
	else invalidRules.push(`'${rule}': rules must start with '/' or '!/'`);
	if (assetWorkerRules.length > 0 && userWorkerRules.length === 0) throw new Error("Only negative `run_worker_first` rules were provided; must provide at least 1 non-negative rule");
	const invalidAssetWorkerRules = validateStaticRoutingRules(rawAssetWorkerRules);
	const invalidUserWorkerRules = validateStaticRoutingRules(userWorkerRules);
	const errorMessage = formatInvalidRoutes([
		...invalidRules,
		...invalidUserWorkerRules,
		...invalidAssetWorkerRules
	]);
	if (errorMessage) throw new Error(errorMessage);
	return {
		asset_worker: assetWorkerRules,
		user_worker: userWorkerRules
	};
}
function validateStaticRoutingRules(rules) {
	const invalid = [];
	const seen = /* @__PURE__ */ new Set();
	for (const rule of rules) {
		if (rule.length > MAX_ROUTES_RULE_LENGTH) invalid.push(`'${rule}': all rules must be less than ${MAX_ROUTES_RULE_LENGTH} characters in length`);
		if (seen.has(rule)) invalid.push(`'${rule}': rule is a duplicate; rules must be unique`);
		if (rule.endsWith("*")) {
			for (const otherRule of rules) if (otherRule !== rule && otherRule.startsWith(rule.slice(0, -1))) invalid.push(`'${otherRule}': rule '${rule}' makes it redundant`);
		}
		seen.add(rule);
	}
	return invalid;
}
const formatInvalidRoutes = (invalidRules) => {
	if (invalidRules.length === 0) return;
	return `Invalid routes in \`run_worker_first\`:\n` + invalidRules.join("\n");
};

//#endregion
//#region ../workers-utils/dist/chunk-UB4QLUTD.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target$1, value) => __defProp(target$1, "name", {
	value,
	configurable: true
});
var __require = /* @__PURE__ */ ((x) => typeof __require$1 !== "undefined" ? __require$1 : typeof Proxy !== "undefined" ? new Proxy(x, { get: (a, b) => (typeof __require$1 !== "undefined" ? __require$1 : a)[b] }) : x)(function(x) {
	if (typeof __require$1 !== "undefined") return __require$1.apply(this, arguments);
	throw Error("Dynamic require of \"" + x + "\" is not supported");
});
var __commonJS = (cb, mod) => function __require2() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target$1, all$1) => {
	for (var name in all$1) __defProp(target$1, name, {
		get: all$1[name],
		enumerable: true
	});
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: () => from[key],
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __reExport = (target$1, mod, secondTarget) => (__copyProps(target$1, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target$1) => (target$1 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target$1, "default", {
	value: mod,
	enumerable: true
}) : target$1, mod));
var INHERIT_SYMBOL = Symbol.for("inherit_binding");
var SERVICE_TAG_PREFIX = "cf:service=";
var ENVIRONMENT_TAG_PREFIX = "cf:environment=";
var PATH_TO_DEPLOY_CONFIG = ".wrangler/deploy/config.json";

//#endregion
//#region ../workers-utils/dist/chunk-Y5D2J4RL.mjs
function getLocalWorkerdCompatibilityDate({ projectPath = process.cwd() } = {}) {
	try {
		const miniflareEntry = module$1.createRequire(projectPath).resolve("miniflare");
		const workerdDate = module$1.createRequire(miniflareEntry)("workerd").compatibilityDate;
		return {
			date: toSafeCompatibilityDate(new Date(workerdDate)),
			source: "workerd"
		};
	} catch {}
	return {
		date: "2025-09-27",
		source: "fallback"
	};
}
__name(getLocalWorkerdCompatibilityDate, "getLocalWorkerdCompatibilityDate");
function toSafeCompatibilityDate(date) {
	if (date.getTime() > Date.now()) return formatCompatibilityDate(/* @__PURE__ */ new Date());
	return formatCompatibilityDate(date);
}
__name(toSafeCompatibilityDate, "toSafeCompatibilityDate");
function isCompatDate(str) {
	return /^\d{4}-\d{2}-\d{2}$/.test(str);
}
__name(isCompatDate, "isCompatDate");
function formatCompatibilityDate(date) {
	const compatDate = date.toISOString().slice(0, 10);
	assert(isCompatDate(compatDate));
	return compatDate;
}
__name(formatCompatibilityDate, "formatCompatibilityDate");
function assertNever(_value) {}
__name(assertNever, "assertNever");
function mapWorkerMetadataBindings(bindings) {
	return bindings.filter((binding) => binding.type !== "secret_text").reduce((configObj, binding) => {
		switch (binding.type) {
			case "plain_text":
				configObj.vars = {
					...configObj.vars ?? {},
					[binding.name]: binding.text
				};
				break;
			case "json":
				configObj.vars = {
					...configObj.vars ?? {},
					name: binding.name,
					json: binding.json
				};
				break;
			case "kv_namespace":
				configObj.kv_namespaces = [...configObj.kv_namespaces ?? [], {
					id: binding.namespace_id,
					binding: binding.name
				}];
				break;
			case "durable_object_namespace":
				configObj.durable_objects = { bindings: [...configObj.durable_objects?.bindings ?? [], {
					name: binding.name,
					class_name: binding.class_name,
					script_name: binding.script_name,
					environment: binding.environment
				}] };
				break;
			case "d1":
				configObj.d1_databases = [...configObj.d1_databases ?? [], {
					binding: binding.name,
					database_id: binding.id
				}];
				break;
			case "browser":
				configObj.browser = { binding: binding.name };
				break;
			case "ai":
				configObj.ai = { binding: binding.name };
				break;
			case "images":
				configObj.images = { binding: binding.name };
				break;
			case "media":
				configObj.media = { binding: binding.name };
				break;
			case "r2_bucket":
				configObj.r2_buckets = [...configObj.r2_buckets ?? [], {
					binding: binding.name,
					bucket_name: binding.bucket_name,
					jurisdiction: binding.jurisdiction
				}];
				break;
			case "secrets_store_secret":
				configObj.secrets_store_secrets = [...configObj.secrets_store_secrets ?? [], {
					binding: binding.name,
					store_id: binding.store_id,
					secret_name: binding.secret_name
				}];
				break;
			case "unsafe_hello_world":
				configObj.unsafe_hello_world = [...configObj.unsafe_hello_world ?? [], {
					binding: binding.name,
					enable_timer: binding.enable_timer
				}];
				break;
			case "service":
				configObj.services = [...configObj.services ?? [], {
					binding: binding.name,
					service: binding.service,
					environment: binding.environment,
					entrypoint: binding.entrypoint
				}];
				break;
			case "analytics_engine":
				configObj.analytics_engine_datasets = [...configObj.analytics_engine_datasets ?? [], {
					binding: binding.name,
					dataset: binding.dataset
				}];
				break;
			case "dispatch_namespace":
				configObj.dispatch_namespaces = [...configObj.dispatch_namespaces ?? [], {
					binding: binding.name,
					namespace: binding.namespace,
					...binding.outbound && { outbound: {
						service: binding.outbound.worker.service,
						environment: binding.outbound.worker.environment,
						parameters: binding.outbound.params?.map((p) => p.name) ?? []
					} }
				}];
				break;
			case "logfwdr":
				configObj.logfwdr = { bindings: [...configObj.logfwdr?.bindings ?? [], {
					name: binding.name,
					destination: binding.destination
				}] };
				break;
			case "wasm_module":
				configObj.wasm_modules = {
					...configObj.wasm_modules ?? {},
					[binding.name]: binding.part
				};
				break;
			case "text_blob":
				configObj.text_blobs = {
					...configObj.text_blobs ?? {},
					[binding.name]: binding.part
				};
				break;
			case "data_blob":
				configObj.data_blobs = {
					...configObj.data_blobs ?? {},
					[binding.name]: binding.part
				};
				break;
			case "secret_text": break;
			case "version_metadata":
				configObj.version_metadata = { binding: binding.name };
				break;
			case "send_email":
				configObj.send_email = [...configObj.send_email ?? [], {
					name: binding.name,
					destination_address: binding.destination_address,
					allowed_destination_addresses: binding.allowed_destination_addresses,
					allowed_sender_addresses: binding.allowed_sender_addresses
				}];
				break;
			case "queue":
				configObj.queues ??= { producers: [] };
				configObj.queues.producers = [...configObj.queues.producers ?? [], {
					binding: binding.name,
					queue: binding.queue_name,
					delivery_delay: binding.delivery_delay
				}];
				break;
			case "vectorize":
				configObj.vectorize = [...configObj.vectorize ?? [], {
					binding: binding.name,
					index_name: binding.index_name
				}];
				break;
			case "hyperdrive":
				configObj.hyperdrive = [...configObj.hyperdrive ?? [], {
					binding: binding.name,
					id: binding.id
				}];
				break;
			case "mtls_certificate":
				configObj.mtls_certificates = [...configObj.mtls_certificates ?? [], {
					binding: binding.name,
					certificate_id: binding.certificate_id
				}];
				break;
			case "pipelines":
				configObj.pipelines = [...configObj.pipelines ?? [], {
					binding: binding.name,
					pipeline: binding.pipeline
				}];
				break;
			case "assets":
				configObj.assets = { binding: binding.name };
				break;
			case "inherit":
				configObj.unsafe = {
					bindings: [...configObj.unsafe?.bindings ?? [], binding],
					metadata: configObj.unsafe?.metadata ?? void 0
				};
				break;
			case "workflow":
				configObj.workflows = [...configObj.workflows ?? [], {
					binding: binding.name,
					name: binding.workflow_name,
					class_name: binding.class_name,
					script_name: binding.script_name
				}];
				break;
			case "worker_loader":
				configObj.worker_loaders = [...configObj.worker_loaders ?? [], { binding: binding.name }];
				break;
			case "ratelimit":
				configObj.ratelimits = [...configObj.ratelimits ?? [], {
					name: binding.name,
					namespace_id: binding.namespace_id,
					simple: {
						limit: binding.simple.limit,
						period: binding.simple.period
					}
				}];
				break;
			case "vpc_service":
				configObj.vpc_services = [...configObj.vpc_services ?? [], {
					binding: binding.name,
					service_id: binding.service_id
				}];
				break;
			default: configObj.unsafe = {
				bindings: [...configObj.unsafe?.bindings ?? [], binding],
				metadata: configObj.unsafe?.metadata ?? void 0
			};
		}
		return configObj;
	}, {});
}
__name(mapWorkerMetadataBindings, "mapWorkerMetadataBindings");
function convertWorkerToWranglerConfig(config) {
	const mappedBindings = mapWorkerMetadataBindings(config.bindings);
	const durableObjectClassNames = config.bindings.filter((binding) => binding.type === "durable_object_namespace" && binding.script_name === config.name).map((durableObject) => durableObject.class_name);
	const allRoutes = [...config.routes.map((r$1) => ({
		pattern: r$1.pattern,
		zone_name: r$1.zone_name
	})), ...config.domains.map((c) => ({
		pattern: c.hostname,
		zone_name: c.zone_name,
		custom_domain: true
	}))];
	return {
		name: config.name,
		main: config.entrypoint,
		workers_dev: config.subdomain.enabled,
		preview_urls: config.subdomain.previews_enabled,
		compatibility_date: config.compatibility_date ?? formatCompatibilityDate(/* @__PURE__ */ new Date()),
		compatibility_flags: config.compatibility_flags,
		...allRoutes.length ? { routes: allRoutes } : {},
		placement: config.placement?.mode === "smart" ? { mode: "smart" } : void 0,
		limits: config.limits,
		...durableObjectClassNames.length && config.migration_tag ? { migrations: [{
			tag: config.migration_tag,
			new_classes: durableObjectClassNames
		}] } : {},
		...config.schedules.length ? { triggers: { crons: config.schedules.map((scheduled) => scheduled.cron) } } : {},
		tail_consumers: config.tail_consumers ?? void 0,
		observability: config.observability,
		...mappedBindings
	};
}
__name(convertWorkerToWranglerConfig, "convertWorkerToWranglerConfig");
function constructWranglerConfig(workerOrWorkers) {
	let workers;
	if (Array.isArray(workerOrWorkers)) workers = workerOrWorkers;
	else workers = [workerOrWorkers];
	const topLevelEnv = workers.find((w) => !w.tags?.some((t$5) => t$5.startsWith(ENVIRONMENT_TAG_PREFIX)));
	const workerName = topLevelEnv?.name ?? workers[0].name;
	const entrypoint = topLevelEnv?.entrypoint ?? workers[0].entrypoint;
	let combinedConfig;
	if (topLevelEnv) combinedConfig = convertWorkerToWranglerConfig(topLevelEnv);
	else combinedConfig = {
		name: workerName,
		main: entrypoint
	};
	for (const env of workers) {
		const serviceTag = env.tags?.find((t$5) => t$5 === `${SERVICE_TAG_PREFIX}${workerName}`);
		const envTag = env.tags?.find((t$5) => t$5.startsWith(ENVIRONMENT_TAG_PREFIX));
		if (serviceTag !== `${SERVICE_TAG_PREFIX}${workerName}` || envTag === void 0) continue;
		const [_, envName] = envTag.split("=");
		combinedConfig.env ??= {};
		combinedConfig.env[envName] = convertWorkerToWranglerConfig(env);
	}
	return combinedConfig;
}
__name(constructWranglerConfig, "constructWranglerConfig");

//#endregion
//#region ../workers-utils/dist/chunk-6T3PMLAP.mjs
var UserError$1 = class extends Error {
	static {
		__name(this, "UserError");
	}
	telemetryMessage;
	constructor(message, options) {
		super(message, options);
		Object.setPrototypeOf(this, new.target.prototype);
		this.telemetryMessage = options?.telemetryMessage === true ? message : options?.telemetryMessage;
	}
};
var DeprecationError = class extends UserError$1 {
	static {
		__name(this, "DeprecationError");
	}
	constructor(message, options) {
		super(`Deprecation:
${message}`, options);
	}
};
var FatalError = class extends UserError$1 {
	constructor(message, code, options) {
		super(message, options);
		this.code = code;
	}
	static {
		__name(this, "FatalError");
	}
};
var CommandLineArgsError = class extends UserError$1 {
	static {
		__name(this, "CommandLineArgsError");
	}
};
var JsonFriendlyFatalError = class extends FatalError {
	constructor(message, code, options) {
		super(message, code, options);
		this.code = code;
	}
	static {
		__name(this, "JsonFriendlyFatalError");
	}
};
var MissingConfigError = class extends Error {
	static {
		__name(this, "MissingConfigError");
	}
	telemetryMessage;
	constructor(key) {
		super(`Missing config value for ${key}`);
		this.telemetryMessage = `Missing config value for ${key}`;
	}
};
function createFatalError(message, isJson, code, telemetryMessage) {
	if (isJson) return new JsonFriendlyFatalError(JSON.stringify(message), code, telemetryMessage);
	else return new FatalError(`${message}`, code, telemetryMessage);
}
__name(createFatalError, "createFatalError");
function createScanner(text, ignoreTrivia = false) {
	const len = text.length;
	let pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
	function scanHexDigits(count, exact) {
		let digits = 0;
		let value2 = 0;
		while (digits < count || !exact) {
			let ch = text.charCodeAt(pos);
			if (ch >= 48 && ch <= 57) value2 = value2 * 16 + ch - 48;
			else if (ch >= 65 && ch <= 70) value2 = value2 * 16 + ch - 65 + 10;
			else if (ch >= 97 && ch <= 102) value2 = value2 * 16 + ch - 97 + 10;
			else break;
			pos++;
			digits++;
		}
		if (digits < count) value2 = -1;
		return value2;
	}
	__name(scanHexDigits, "scanHexDigits");
	function setPosition(newPosition) {
		pos = newPosition;
		value = "";
		tokenOffset = 0;
		token = 16;
		scanError = 0;
	}
	__name(setPosition, "setPosition");
	function scanNumber() {
		let start = pos;
		if (text.charCodeAt(pos) === 48) pos++;
		else {
			pos++;
			while (pos < text.length && isDigit(text.charCodeAt(pos))) pos++;
		}
		if (pos < text.length && text.charCodeAt(pos) === 46) {
			pos++;
			if (pos < text.length && isDigit(text.charCodeAt(pos))) {
				pos++;
				while (pos < text.length && isDigit(text.charCodeAt(pos))) pos++;
			} else {
				scanError = 3;
				return text.substring(start, pos);
			}
		}
		let end = pos;
		if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
			pos++;
			if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) pos++;
			if (pos < text.length && isDigit(text.charCodeAt(pos))) {
				pos++;
				while (pos < text.length && isDigit(text.charCodeAt(pos))) pos++;
				end = pos;
			} else scanError = 3;
		}
		return text.substring(start, end);
	}
	__name(scanNumber, "scanNumber");
	function scanString() {
		let result = "", start = pos;
		while (true) {
			if (pos >= len) {
				result += text.substring(start, pos);
				scanError = 2;
				break;
			}
			const ch = text.charCodeAt(pos);
			if (ch === 34) {
				result += text.substring(start, pos);
				pos++;
				break;
			}
			if (ch === 92) {
				result += text.substring(start, pos);
				pos++;
				if (pos >= len) {
					scanError = 2;
					break;
				}
				switch (text.charCodeAt(pos++)) {
					case 34:
						result += "\"";
						break;
					case 92:
						result += "\\";
						break;
					case 47:
						result += "/";
						break;
					case 98:
						result += "\b";
						break;
					case 102:
						result += "\f";
						break;
					case 110:
						result += "\n";
						break;
					case 114:
						result += "\r";
						break;
					case 116:
						result += "	";
						break;
					case 117:
						const ch3 = scanHexDigits(4, true);
						if (ch3 >= 0) result += String.fromCharCode(ch3);
						else scanError = 4;
						break;
					default: scanError = 5;
				}
				start = pos;
				continue;
			}
			if (ch >= 0 && ch <= 31) if (isLineBreak(ch)) {
				result += text.substring(start, pos);
				scanError = 2;
				break;
			} else scanError = 6;
			pos++;
		}
		return result;
	}
	__name(scanString, "scanString");
	function scanNext() {
		value = "";
		scanError = 0;
		tokenOffset = pos;
		lineStartOffset = lineNumber;
		prevTokenLineStartOffset = tokenLineStartOffset;
		if (pos >= len) {
			tokenOffset = len;
			return token = 17;
		}
		let code = text.charCodeAt(pos);
		if (isWhiteSpace(code)) {
			do {
				pos++;
				value += String.fromCharCode(code);
				code = text.charCodeAt(pos);
			} while (isWhiteSpace(code));
			return token = 15;
		}
		if (isLineBreak(code)) {
			pos++;
			value += String.fromCharCode(code);
			if (code === 13 && text.charCodeAt(pos) === 10) {
				pos++;
				value += "\n";
			}
			lineNumber++;
			tokenLineStartOffset = pos;
			return token = 14;
		}
		switch (code) {
			case 123:
				pos++;
				return token = 1;
			case 125:
				pos++;
				return token = 2;
			case 91:
				pos++;
				return token = 3;
			case 93:
				pos++;
				return token = 4;
			case 58:
				pos++;
				return token = 6;
			case 44:
				pos++;
				return token = 5;
			case 34:
				pos++;
				value = scanString();
				return token = 10;
			case 47:
				const start = pos - 1;
				if (text.charCodeAt(pos + 1) === 47) {
					pos += 2;
					while (pos < len) {
						if (isLineBreak(text.charCodeAt(pos))) break;
						pos++;
					}
					value = text.substring(start, pos);
					return token = 12;
				}
				if (text.charCodeAt(pos + 1) === 42) {
					pos += 2;
					const safeLength = len - 1;
					let commentClosed = false;
					while (pos < safeLength) {
						const ch = text.charCodeAt(pos);
						if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
							pos += 2;
							commentClosed = true;
							break;
						}
						pos++;
						if (isLineBreak(ch)) {
							if (ch === 13 && text.charCodeAt(pos) === 10) pos++;
							lineNumber++;
							tokenLineStartOffset = pos;
						}
					}
					if (!commentClosed) {
						pos++;
						scanError = 1;
					}
					value = text.substring(start, pos);
					return token = 13;
				}
				value += String.fromCharCode(code);
				pos++;
				return token = 16;
			case 45:
				value += String.fromCharCode(code);
				pos++;
				if (pos === len || !isDigit(text.charCodeAt(pos))) return token = 16;
			case 48:
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57:
				value += scanNumber();
				return token = 11;
			default:
				while (pos < len && isUnknownContentCharacter(code)) {
					pos++;
					code = text.charCodeAt(pos);
				}
				if (tokenOffset !== pos) {
					value = text.substring(tokenOffset, pos);
					switch (value) {
						case "true": return token = 8;
						case "false": return token = 9;
						case "null": return token = 7;
					}
					return token = 16;
				}
				value += String.fromCharCode(code);
				pos++;
				return token = 16;
		}
	}
	__name(scanNext, "scanNext");
	function isUnknownContentCharacter(code) {
		if (isWhiteSpace(code) || isLineBreak(code)) return false;
		switch (code) {
			case 125:
			case 93:
			case 123:
			case 91:
			case 34:
			case 58:
			case 44:
			case 47: return false;
		}
		return true;
	}
	__name(isUnknownContentCharacter, "isUnknownContentCharacter");
	function scanNextNonTrivia() {
		let result;
		do
			result = scanNext();
		while (result >= 12 && result <= 15);
		return result;
	}
	__name(scanNextNonTrivia, "scanNextNonTrivia");
	return {
		setPosition,
		getPosition: /* @__PURE__ */ __name(() => pos, "getPosition"),
		scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
		getToken: /* @__PURE__ */ __name(() => token, "getToken"),
		getTokenValue: /* @__PURE__ */ __name(() => value, "getTokenValue"),
		getTokenOffset: /* @__PURE__ */ __name(() => tokenOffset, "getTokenOffset"),
		getTokenLength: /* @__PURE__ */ __name(() => pos - tokenOffset, "getTokenLength"),
		getTokenStartLine: /* @__PURE__ */ __name(() => lineStartOffset, "getTokenStartLine"),
		getTokenStartCharacter: /* @__PURE__ */ __name(() => tokenOffset - prevTokenLineStartOffset, "getTokenStartCharacter"),
		getTokenError: /* @__PURE__ */ __name(() => scanError, "getTokenError")
	};
}
__name(createScanner, "createScanner");
function isWhiteSpace(ch) {
	return ch === 32 || ch === 9;
}
__name(isWhiteSpace, "isWhiteSpace");
function isLineBreak(ch) {
	return ch === 10 || ch === 13;
}
__name(isLineBreak, "isLineBreak");
function isDigit(ch) {
	return ch >= 48 && ch <= 57;
}
__name(isDigit, "isDigit");
var CharacterCodes;
(function(CharacterCodes2) {
	CharacterCodes2[CharacterCodes2["lineFeed"] = 10] = "lineFeed";
	CharacterCodes2[CharacterCodes2["carriageReturn"] = 13] = "carriageReturn";
	CharacterCodes2[CharacterCodes2["space"] = 32] = "space";
	CharacterCodes2[CharacterCodes2["_0"] = 48] = "_0";
	CharacterCodes2[CharacterCodes2["_1"] = 49] = "_1";
	CharacterCodes2[CharacterCodes2["_2"] = 50] = "_2";
	CharacterCodes2[CharacterCodes2["_3"] = 51] = "_3";
	CharacterCodes2[CharacterCodes2["_4"] = 52] = "_4";
	CharacterCodes2[CharacterCodes2["_5"] = 53] = "_5";
	CharacterCodes2[CharacterCodes2["_6"] = 54] = "_6";
	CharacterCodes2[CharacterCodes2["_7"] = 55] = "_7";
	CharacterCodes2[CharacterCodes2["_8"] = 56] = "_8";
	CharacterCodes2[CharacterCodes2["_9"] = 57] = "_9";
	CharacterCodes2[CharacterCodes2["a"] = 97] = "a";
	CharacterCodes2[CharacterCodes2["b"] = 98] = "b";
	CharacterCodes2[CharacterCodes2["c"] = 99] = "c";
	CharacterCodes2[CharacterCodes2["d"] = 100] = "d";
	CharacterCodes2[CharacterCodes2["e"] = 101] = "e";
	CharacterCodes2[CharacterCodes2["f"] = 102] = "f";
	CharacterCodes2[CharacterCodes2["g"] = 103] = "g";
	CharacterCodes2[CharacterCodes2["h"] = 104] = "h";
	CharacterCodes2[CharacterCodes2["i"] = 105] = "i";
	CharacterCodes2[CharacterCodes2["j"] = 106] = "j";
	CharacterCodes2[CharacterCodes2["k"] = 107] = "k";
	CharacterCodes2[CharacterCodes2["l"] = 108] = "l";
	CharacterCodes2[CharacterCodes2["m"] = 109] = "m";
	CharacterCodes2[CharacterCodes2["n"] = 110] = "n";
	CharacterCodes2[CharacterCodes2["o"] = 111] = "o";
	CharacterCodes2[CharacterCodes2["p"] = 112] = "p";
	CharacterCodes2[CharacterCodes2["q"] = 113] = "q";
	CharacterCodes2[CharacterCodes2["r"] = 114] = "r";
	CharacterCodes2[CharacterCodes2["s"] = 115] = "s";
	CharacterCodes2[CharacterCodes2["t"] = 116] = "t";
	CharacterCodes2[CharacterCodes2["u"] = 117] = "u";
	CharacterCodes2[CharacterCodes2["v"] = 118] = "v";
	CharacterCodes2[CharacterCodes2["w"] = 119] = "w";
	CharacterCodes2[CharacterCodes2["x"] = 120] = "x";
	CharacterCodes2[CharacterCodes2["y"] = 121] = "y";
	CharacterCodes2[CharacterCodes2["z"] = 122] = "z";
	CharacterCodes2[CharacterCodes2["A"] = 65] = "A";
	CharacterCodes2[CharacterCodes2["B"] = 66] = "B";
	CharacterCodes2[CharacterCodes2["C"] = 67] = "C";
	CharacterCodes2[CharacterCodes2["D"] = 68] = "D";
	CharacterCodes2[CharacterCodes2["E"] = 69] = "E";
	CharacterCodes2[CharacterCodes2["F"] = 70] = "F";
	CharacterCodes2[CharacterCodes2["G"] = 71] = "G";
	CharacterCodes2[CharacterCodes2["H"] = 72] = "H";
	CharacterCodes2[CharacterCodes2["I"] = 73] = "I";
	CharacterCodes2[CharacterCodes2["J"] = 74] = "J";
	CharacterCodes2[CharacterCodes2["K"] = 75] = "K";
	CharacterCodes2[CharacterCodes2["L"] = 76] = "L";
	CharacterCodes2[CharacterCodes2["M"] = 77] = "M";
	CharacterCodes2[CharacterCodes2["N"] = 78] = "N";
	CharacterCodes2[CharacterCodes2["O"] = 79] = "O";
	CharacterCodes2[CharacterCodes2["P"] = 80] = "P";
	CharacterCodes2[CharacterCodes2["Q"] = 81] = "Q";
	CharacterCodes2[CharacterCodes2["R"] = 82] = "R";
	CharacterCodes2[CharacterCodes2["S"] = 83] = "S";
	CharacterCodes2[CharacterCodes2["T"] = 84] = "T";
	CharacterCodes2[CharacterCodes2["U"] = 85] = "U";
	CharacterCodes2[CharacterCodes2["V"] = 86] = "V";
	CharacterCodes2[CharacterCodes2["W"] = 87] = "W";
	CharacterCodes2[CharacterCodes2["X"] = 88] = "X";
	CharacterCodes2[CharacterCodes2["Y"] = 89] = "Y";
	CharacterCodes2[CharacterCodes2["Z"] = 90] = "Z";
	CharacterCodes2[CharacterCodes2["asterisk"] = 42] = "asterisk";
	CharacterCodes2[CharacterCodes2["backslash"] = 92] = "backslash";
	CharacterCodes2[CharacterCodes2["closeBrace"] = 125] = "closeBrace";
	CharacterCodes2[CharacterCodes2["closeBracket"] = 93] = "closeBracket";
	CharacterCodes2[CharacterCodes2["colon"] = 58] = "colon";
	CharacterCodes2[CharacterCodes2["comma"] = 44] = "comma";
	CharacterCodes2[CharacterCodes2["dot"] = 46] = "dot";
	CharacterCodes2[CharacterCodes2["doubleQuote"] = 34] = "doubleQuote";
	CharacterCodes2[CharacterCodes2["minus"] = 45] = "minus";
	CharacterCodes2[CharacterCodes2["openBrace"] = 123] = "openBrace";
	CharacterCodes2[CharacterCodes2["openBracket"] = 91] = "openBracket";
	CharacterCodes2[CharacterCodes2["plus"] = 43] = "plus";
	CharacterCodes2[CharacterCodes2["slash"] = 47] = "slash";
	CharacterCodes2[CharacterCodes2["formFeed"] = 12] = "formFeed";
	CharacterCodes2[CharacterCodes2["tab"] = 9] = "tab";
})(CharacterCodes || (CharacterCodes = {}));
function format$1(documentText, range, options) {
	let initialIndentLevel;
	let formatText;
	let formatTextStart;
	let rangeStart;
	let rangeEnd;
	if (range) {
		rangeStart = range.offset;
		rangeEnd = rangeStart + range.length;
		formatTextStart = rangeStart;
		while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) formatTextStart--;
		let endOffset = rangeEnd;
		while (endOffset < documentText.length && !isEOL(documentText, endOffset)) endOffset++;
		formatText = documentText.substring(formatTextStart, endOffset);
		initialIndentLevel = computeIndentLevel(formatText, options);
	} else {
		formatText = documentText;
		initialIndentLevel = 0;
		formatTextStart = 0;
		rangeStart = 0;
		rangeEnd = documentText.length;
	}
	const eol = getEOL(options, documentText);
	let numberLineBreaks = 0;
	let indentLevel = 0;
	let indentValue;
	if (options.insertSpaces) indentValue = repeat(" ", options.tabSize || 4);
	else indentValue = "	";
	let scanner = createScanner(formatText, false);
	let hasError = false;
	function newLinesAndIndent() {
		if (numberLineBreaks > 1) return repeat(eol, numberLineBreaks) + repeat(indentValue, initialIndentLevel + indentLevel);
		else return eol + repeat(indentValue, initialIndentLevel + indentLevel);
	}
	__name(newLinesAndIndent, "newLinesAndIndent");
	function scanNext() {
		let token = scanner.scan();
		numberLineBreaks = 0;
		while (token === 15 || token === 14) {
			if (token === 14 && options.keepLines) numberLineBreaks += 1;
			else if (token === 14) numberLineBreaks = 1;
			token = scanner.scan();
		}
		hasError = token === 16 || scanner.getTokenError() !== 0;
		return token;
	}
	__name(scanNext, "scanNext");
	const editOperations = [];
	function addEdit(text, startOffset, endOffset) {
		if (!hasError && (!range || startOffset < rangeEnd && endOffset > rangeStart) && documentText.substring(startOffset, endOffset) !== text) editOperations.push({
			offset: startOffset,
			length: endOffset - startOffset,
			content: text
		});
	}
	__name(addEdit, "addEdit");
	let firstToken = scanNext();
	if (options.keepLines && numberLineBreaks > 0) addEdit(repeat(eol, numberLineBreaks), 0, 0);
	if (firstToken !== 17) {
		let firstTokenStart = scanner.getTokenOffset() + formatTextStart;
		addEdit(repeat(indentValue, initialIndentLevel), formatTextStart, firstTokenStart);
	}
	while (firstToken !== 17) {
		let firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
		let secondToken = scanNext();
		let replaceContent = "";
		let needsLineBreak = false;
		while (numberLineBreaks === 0 && (secondToken === 12 || secondToken === 13)) {
			let commentTokenStart = scanner.getTokenOffset() + formatTextStart;
			addEdit(" ", firstTokenEnd, commentTokenStart);
			firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
			needsLineBreak = secondToken === 12;
			replaceContent = needsLineBreak ? newLinesAndIndent() : "";
			secondToken = scanNext();
		}
		if (secondToken === 2) {
			if (firstToken !== 1) indentLevel--;
			if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 1) replaceContent = newLinesAndIndent();
			else if (options.keepLines) replaceContent = " ";
		} else if (secondToken === 4) {
			if (firstToken !== 3) indentLevel--;
			if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 3) replaceContent = newLinesAndIndent();
			else if (options.keepLines) replaceContent = " ";
		} else {
			switch (firstToken) {
				case 3:
				case 1:
					indentLevel++;
					if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) replaceContent = newLinesAndIndent();
					else replaceContent = " ";
					break;
				case 5:
					if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) replaceContent = newLinesAndIndent();
					else replaceContent = " ";
					break;
				case 12:
					replaceContent = newLinesAndIndent();
					break;
				case 13:
					if (numberLineBreaks > 0) replaceContent = newLinesAndIndent();
					else if (!needsLineBreak) replaceContent = " ";
					break;
				case 6:
					if (options.keepLines && numberLineBreaks > 0) replaceContent = newLinesAndIndent();
					else if (!needsLineBreak) replaceContent = " ";
					break;
				case 10:
					if (options.keepLines && numberLineBreaks > 0) replaceContent = newLinesAndIndent();
					else if (secondToken === 6 && !needsLineBreak) replaceContent = "";
					break;
				case 7:
				case 8:
				case 9:
				case 11:
				case 2:
				case 4:
					if (options.keepLines && numberLineBreaks > 0) replaceContent = newLinesAndIndent();
					else if ((secondToken === 12 || secondToken === 13) && !needsLineBreak) replaceContent = " ";
					else if (secondToken !== 5 && secondToken !== 17) hasError = true;
					break;
				case 16:
					hasError = true;
					break;
			}
			if (numberLineBreaks > 0 && (secondToken === 12 || secondToken === 13)) replaceContent = newLinesAndIndent();
		}
		if (secondToken === 17) if (options.keepLines && numberLineBreaks > 0) replaceContent = newLinesAndIndent();
		else replaceContent = options.insertFinalNewline ? eol : "";
		const secondTokenStart = scanner.getTokenOffset() + formatTextStart;
		addEdit(replaceContent, firstTokenEnd, secondTokenStart);
		firstToken = secondToken;
	}
	return editOperations;
}
__name(format$1, "format");
function repeat(s, count) {
	let result = "";
	for (let i$1 = 0; i$1 < count; i$1++) result += s;
	return result;
}
__name(repeat, "repeat");
function computeIndentLevel(content, options) {
	let i$1 = 0;
	let nChars = 0;
	const tabSize = options.tabSize || 4;
	while (i$1 < content.length) {
		let ch = content.charAt(i$1);
		if (ch === " ") nChars++;
		else if (ch === "	") nChars += tabSize;
		else break;
		i$1++;
	}
	return Math.floor(nChars / tabSize);
}
__name(computeIndentLevel, "computeIndentLevel");
function getEOL(options, text) {
	for (let i$1 = 0; i$1 < text.length; i$1++) {
		const ch = text.charAt(i$1);
		if (ch === "\r") {
			if (i$1 + 1 < text.length && text.charAt(i$1 + 1) === "\n") return "\r\n";
			return "\r";
		} else if (ch === "\n") return "\n";
	}
	return options && options.eol || "\n";
}
__name(getEOL, "getEOL");
function isEOL(text, offset) {
	return "\r\n".indexOf(text.charAt(offset)) !== -1;
}
__name(isEOL, "isEOL");
var ParseOptions;
(function(ParseOptions2) {
	ParseOptions2.DEFAULT = { allowTrailingComma: false };
})(ParseOptions || (ParseOptions = {}));
function parse(text, errors = [], options = ParseOptions.DEFAULT) {
	let currentProperty = null;
	let currentParent = [];
	const previousParents = [];
	function onValue(value) {
		if (Array.isArray(currentParent)) currentParent.push(value);
		else if (currentProperty !== null) currentParent[currentProperty] = value;
	}
	__name(onValue, "onValue");
	visit(text, {
		onObjectBegin: /* @__PURE__ */ __name(() => {
			const object = {};
			onValue(object);
			previousParents.push(currentParent);
			currentParent = object;
			currentProperty = null;
		}, "onObjectBegin"),
		onObjectProperty: /* @__PURE__ */ __name((name) => {
			currentProperty = name;
		}, "onObjectProperty"),
		onObjectEnd: /* @__PURE__ */ __name(() => {
			currentParent = previousParents.pop();
		}, "onObjectEnd"),
		onArrayBegin: /* @__PURE__ */ __name(() => {
			const array = [];
			onValue(array);
			previousParents.push(currentParent);
			currentParent = array;
			currentProperty = null;
		}, "onArrayBegin"),
		onArrayEnd: /* @__PURE__ */ __name(() => {
			currentParent = previousParents.pop();
		}, "onArrayEnd"),
		onLiteralValue: onValue,
		onError: /* @__PURE__ */ __name((error, offset, length) => {
			errors.push({
				error,
				offset,
				length
			});
		}, "onError")
	}, options);
	return currentParent[0];
}
__name(parse, "parse");
function parseTree(text, errors = [], options = ParseOptions.DEFAULT) {
	let currentParent = {
		type: "array",
		offset: -1,
		length: -1,
		children: [],
		parent: void 0
	};
	function ensurePropertyComplete(endOffset) {
		if (currentParent.type === "property") {
			currentParent.length = endOffset - currentParent.offset;
			currentParent = currentParent.parent;
		}
	}
	__name(ensurePropertyComplete, "ensurePropertyComplete");
	function onValue(valueNode) {
		currentParent.children.push(valueNode);
		return valueNode;
	}
	__name(onValue, "onValue");
	visit(text, {
		onObjectBegin: /* @__PURE__ */ __name((offset) => {
			currentParent = onValue({
				type: "object",
				offset,
				length: -1,
				parent: currentParent,
				children: []
			});
		}, "onObjectBegin"),
		onObjectProperty: /* @__PURE__ */ __name((name, offset, length) => {
			currentParent = onValue({
				type: "property",
				offset,
				length: -1,
				parent: currentParent,
				children: []
			});
			currentParent.children.push({
				type: "string",
				value: name,
				offset,
				length,
				parent: currentParent
			});
		}, "onObjectProperty"),
		onObjectEnd: /* @__PURE__ */ __name((offset, length) => {
			ensurePropertyComplete(offset + length);
			currentParent.length = offset + length - currentParent.offset;
			currentParent = currentParent.parent;
			ensurePropertyComplete(offset + length);
		}, "onObjectEnd"),
		onArrayBegin: /* @__PURE__ */ __name((offset, length) => {
			currentParent = onValue({
				type: "array",
				offset,
				length: -1,
				parent: currentParent,
				children: []
			});
		}, "onArrayBegin"),
		onArrayEnd: /* @__PURE__ */ __name((offset, length) => {
			currentParent.length = offset + length - currentParent.offset;
			currentParent = currentParent.parent;
			ensurePropertyComplete(offset + length);
		}, "onArrayEnd"),
		onLiteralValue: /* @__PURE__ */ __name((value, offset, length) => {
			onValue({
				type: getNodeType(value),
				offset,
				length,
				parent: currentParent,
				value
			});
			ensurePropertyComplete(offset + length);
		}, "onLiteralValue"),
		onSeparator: /* @__PURE__ */ __name((sep, offset, length) => {
			if (currentParent.type === "property") {
				if (sep === ":") currentParent.colonOffset = offset;
				else if (sep === ",") ensurePropertyComplete(offset);
			}
		}, "onSeparator"),
		onError: /* @__PURE__ */ __name((error, offset, length) => {
			errors.push({
				error,
				offset,
				length
			});
		}, "onError")
	}, options);
	const result = currentParent.children[0];
	if (result) delete result.parent;
	return result;
}
__name(parseTree, "parseTree");
function findNodeAtLocation(root, path4$1) {
	if (!root) return;
	let node = root;
	for (let segment of path4$1) if (typeof segment === "string") {
		if (node.type !== "object" || !Array.isArray(node.children)) return;
		let found = false;
		for (const propertyNode of node.children) if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {
			node = propertyNode.children[1];
			found = true;
			break;
		}
		if (!found) return;
	} else {
		const index = segment;
		if (node.type !== "array" || index < 0 || !Array.isArray(node.children) || index >= node.children.length) return;
		node = node.children[index];
	}
	return node;
}
__name(findNodeAtLocation, "findNodeAtLocation");
function visit(text, visitor, options = ParseOptions.DEFAULT) {
	const _scanner = createScanner(text, false);
	const _jsonPath = [];
	function toNoArgVisit(visitFunction) {
		return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
	}
	__name(toNoArgVisit, "toNoArgVisit");
	function toNoArgVisitWithPath(visitFunction) {
		return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
	}
	__name(toNoArgVisitWithPath, "toNoArgVisitWithPath");
	function toOneArgVisit(visitFunction) {
		return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
	}
	__name(toOneArgVisit, "toOneArgVisit");
	function toOneArgVisitWithPath(visitFunction) {
		return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
	}
	__name(toOneArgVisitWithPath, "toOneArgVisitWithPath");
	const onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
	const disallowComments = options && options.disallowComments;
	const allowTrailingComma = options && options.allowTrailingComma;
	function scanNext() {
		while (true) {
			const token = _scanner.scan();
			switch (_scanner.getTokenError()) {
				case 4:
					handleError(14);
					break;
				case 5:
					handleError(15);
					break;
				case 3:
					handleError(13);
					break;
				case 1:
					if (!disallowComments) handleError(11);
					break;
				case 2:
					handleError(12);
					break;
				case 6:
					handleError(16);
					break;
			}
			switch (token) {
				case 12:
				case 13:
					if (disallowComments) handleError(10);
					else onComment();
					break;
				case 16:
					handleError(1);
					break;
				case 15:
				case 14: break;
				default: return token;
			}
		}
	}
	__name(scanNext, "scanNext");
	function handleError(error, skipUntilAfter = [], skipUntil2 = []) {
		onError(error);
		if (skipUntilAfter.length + skipUntil2.length > 0) {
			let token = _scanner.getToken();
			while (token !== 17) {
				if (skipUntilAfter.indexOf(token) !== -1) {
					scanNext();
					break;
				} else if (skipUntil2.indexOf(token) !== -1) break;
				token = scanNext();
			}
		}
	}
	__name(handleError, "handleError");
	function parseString2(isValue) {
		const value = _scanner.getTokenValue();
		if (isValue) onLiteralValue(value);
		else {
			onObjectProperty(value);
			_jsonPath.push(value);
		}
		scanNext();
		return true;
	}
	__name(parseString2, "parseString");
	function parseLiteral() {
		switch (_scanner.getToken()) {
			case 11:
				const tokenValue = _scanner.getTokenValue();
				let value = Number(tokenValue);
				if (isNaN(value)) {
					handleError(2);
					value = 0;
				}
				onLiteralValue(value);
				break;
			case 7:
				onLiteralValue(null);
				break;
			case 8:
				onLiteralValue(true);
				break;
			case 9:
				onLiteralValue(false);
				break;
			default: return false;
		}
		scanNext();
		return true;
	}
	__name(parseLiteral, "parseLiteral");
	function parseProperty() {
		if (_scanner.getToken() !== 10) {
			handleError(3, [], [2, 5]);
			return false;
		}
		parseString2(false);
		if (_scanner.getToken() === 6) {
			onSeparator(":");
			scanNext();
			if (!parseValue2()) handleError(4, [], [2, 5]);
		} else handleError(5, [], [2, 5]);
		_jsonPath.pop();
		return true;
	}
	__name(parseProperty, "parseProperty");
	function parseObject() {
		onObjectBegin();
		scanNext();
		let needsComma = false;
		while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
			if (_scanner.getToken() === 5) {
				if (!needsComma) handleError(4, [], []);
				onSeparator(",");
				scanNext();
				if (_scanner.getToken() === 2 && allowTrailingComma) break;
			} else if (needsComma) handleError(6, [], []);
			if (!parseProperty()) handleError(4, [], [2, 5]);
			needsComma = true;
		}
		onObjectEnd();
		if (_scanner.getToken() !== 2) handleError(7, [2], []);
		else scanNext();
		return true;
	}
	__name(parseObject, "parseObject");
	function parseArray2() {
		onArrayBegin();
		scanNext();
		let isFirstElement = true;
		let needsComma = false;
		while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
			if (_scanner.getToken() === 5) {
				if (!needsComma) handleError(4, [], []);
				onSeparator(",");
				scanNext();
				if (_scanner.getToken() === 4 && allowTrailingComma) break;
			} else if (needsComma) handleError(6, [], []);
			if (isFirstElement) {
				_jsonPath.push(0);
				isFirstElement = false;
			} else _jsonPath[_jsonPath.length - 1]++;
			if (!parseValue2()) handleError(4, [], [4, 5]);
			needsComma = true;
		}
		onArrayEnd();
		if (!isFirstElement) _jsonPath.pop();
		if (_scanner.getToken() !== 4) handleError(8, [4], []);
		else scanNext();
		return true;
	}
	__name(parseArray2, "parseArray");
	function parseValue2() {
		switch (_scanner.getToken()) {
			case 3: return parseArray2();
			case 1: return parseObject();
			case 10: return parseString2(true);
			default: return parseLiteral();
		}
	}
	__name(parseValue2, "parseValue");
	scanNext();
	if (_scanner.getToken() === 17) {
		if (options.allowEmptyContent) return true;
		handleError(4, [], []);
		return false;
	}
	if (!parseValue2()) {
		handleError(4, [], []);
		return false;
	}
	if (_scanner.getToken() !== 17) handleError(9, [], []);
	return true;
}
__name(visit, "visit");
function getNodeType(value) {
	switch (typeof value) {
		case "boolean": return "boolean";
		case "number": return "number";
		case "string": return "string";
		case "object":
			if (!value) return "null";
			else if (Array.isArray(value)) return "array";
			return "object";
		default: return "null";
	}
}
__name(getNodeType, "getNodeType");
function setProperty(text, originalPath, value, options) {
	const path4$1 = originalPath.slice();
	const root = parseTree(text, []);
	let parent = void 0;
	let lastSegment = void 0;
	while (path4$1.length > 0) {
		lastSegment = path4$1.pop();
		parent = findNodeAtLocation(root, path4$1);
		if (parent === void 0 && value !== void 0) if (typeof lastSegment === "string") value = { [lastSegment]: value };
		else value = [value];
		else break;
	}
	if (!parent) {
		if (value === void 0) throw new Error("Can not delete in empty document");
		return withFormatting(text, {
			offset: root ? root.offset : 0,
			length: root ? root.length : 0,
			content: JSON.stringify(value)
		}, options);
	} else if (parent.type === "object" && typeof lastSegment === "string" && Array.isArray(parent.children)) {
		const existing = findNodeAtLocation(parent, [lastSegment]);
		if (existing !== void 0) if (value === void 0) {
			if (!existing.parent) throw new Error("Malformed AST");
			const propertyIndex = parent.children.indexOf(existing.parent);
			let removeBegin;
			let removeEnd = existing.parent.offset + existing.parent.length;
			if (propertyIndex > 0) {
				let previous = parent.children[propertyIndex - 1];
				removeBegin = previous.offset + previous.length;
			} else {
				removeBegin = parent.offset + 1;
				if (parent.children.length > 1) removeEnd = parent.children[1].offset;
			}
			return withFormatting(text, {
				offset: removeBegin,
				length: removeEnd - removeBegin,
				content: ""
			}, options);
		} else return withFormatting(text, {
			offset: existing.offset,
			length: existing.length,
			content: JSON.stringify(value)
		}, options);
		else {
			if (value === void 0) return [];
			const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;
			const index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map((p) => p.children[0].value)) : parent.children.length;
			let edit;
			if (index > 0) {
				let previous = parent.children[index - 1];
				edit = {
					offset: previous.offset + previous.length,
					length: 0,
					content: "," + newProperty
				};
			} else if (parent.children.length === 0) edit = {
				offset: parent.offset + 1,
				length: 0,
				content: newProperty
			};
			else edit = {
				offset: parent.offset + 1,
				length: 0,
				content: newProperty + ","
			};
			return withFormatting(text, edit, options);
		}
	} else if (parent.type === "array" && typeof lastSegment === "number" && Array.isArray(parent.children)) {
		const insertIndex = lastSegment;
		if (insertIndex === -1) {
			const newProperty = `${JSON.stringify(value)}`;
			let edit;
			if (parent.children.length === 0) edit = {
				offset: parent.offset + 1,
				length: 0,
				content: newProperty
			};
			else {
				const previous = parent.children[parent.children.length - 1];
				edit = {
					offset: previous.offset + previous.length,
					length: 0,
					content: "," + newProperty
				};
			}
			return withFormatting(text, edit, options);
		} else if (value === void 0 && parent.children.length >= 0) {
			const removalIndex = lastSegment;
			const toRemove = parent.children[removalIndex];
			let edit;
			if (parent.children.length === 1) edit = {
				offset: parent.offset + 1,
				length: parent.length - 2,
				content: ""
			};
			else if (parent.children.length - 1 === removalIndex) {
				let previous = parent.children[removalIndex - 1];
				let offset = previous.offset + previous.length;
				edit = {
					offset,
					length: parent.offset + parent.length - 2 - offset,
					content: ""
				};
			} else edit = {
				offset: toRemove.offset,
				length: parent.children[removalIndex + 1].offset - toRemove.offset,
				content: ""
			};
			return withFormatting(text, edit, options);
		} else if (value !== void 0) {
			let edit;
			const newProperty = `${JSON.stringify(value)}`;
			if (!options.isArrayInsertion && parent.children.length > lastSegment) {
				const toModify = parent.children[lastSegment];
				edit = {
					offset: toModify.offset,
					length: toModify.length,
					content: newProperty
				};
			} else if (parent.children.length === 0 || lastSegment === 0) edit = {
				offset: parent.offset + 1,
				length: 0,
				content: parent.children.length === 0 ? newProperty : newProperty + ","
			};
			else {
				const index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
				const previous = parent.children[index - 1];
				edit = {
					offset: previous.offset + previous.length,
					length: 0,
					content: "," + newProperty
				};
			}
			return withFormatting(text, edit, options);
		} else throw new Error(`Can not ${value === void 0 ? "remove" : options.isArrayInsertion ? "insert" : "modify"} Array index ${insertIndex} as length is not sufficient`);
	} else throw new Error(`Can not add ${typeof lastSegment !== "number" ? "index" : "property"} to parent of type ${parent.type}`);
}
__name(setProperty, "setProperty");
function withFormatting(text, edit, options) {
	if (!options.formattingOptions) return [edit];
	let newText = applyEdit(text, edit);
	let begin = edit.offset;
	let end = edit.offset + edit.content.length;
	if (edit.length === 0 || edit.content.length === 0) {
		while (begin > 0 && !isEOL(newText, begin - 1)) begin--;
		while (end < newText.length && !isEOL(newText, end)) end++;
	}
	const edits = format$1(newText, {
		offset: begin,
		length: end - begin
	}, {
		...options.formattingOptions,
		keepLines: false
	});
	for (let i$1 = edits.length - 1; i$1 >= 0; i$1--) {
		const edit2 = edits[i$1];
		newText = applyEdit(newText, edit2);
		begin = Math.min(begin, edit2.offset);
		end = Math.max(end, edit2.offset + edit2.length);
		end += edit2.content.length - edit2.length;
	}
	const editLength = text.length - (newText.length - end) - begin;
	return [{
		offset: begin,
		length: editLength,
		content: newText.substring(begin, end)
	}];
}
__name(withFormatting, "withFormatting");
function applyEdit(text, edit) {
	return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);
}
__name(applyEdit, "applyEdit");
var ScanError;
(function(ScanError2) {
	ScanError2[ScanError2["None"] = 0] = "None";
	ScanError2[ScanError2["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
	ScanError2[ScanError2["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
	ScanError2[ScanError2["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
	ScanError2[ScanError2["InvalidUnicode"] = 4] = "InvalidUnicode";
	ScanError2[ScanError2["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
	ScanError2[ScanError2["InvalidCharacter"] = 6] = "InvalidCharacter";
})(ScanError || (ScanError = {}));
var SyntaxKind;
(function(SyntaxKind2) {
	SyntaxKind2[SyntaxKind2["OpenBraceToken"] = 1] = "OpenBraceToken";
	SyntaxKind2[SyntaxKind2["CloseBraceToken"] = 2] = "CloseBraceToken";
	SyntaxKind2[SyntaxKind2["OpenBracketToken"] = 3] = "OpenBracketToken";
	SyntaxKind2[SyntaxKind2["CloseBracketToken"] = 4] = "CloseBracketToken";
	SyntaxKind2[SyntaxKind2["CommaToken"] = 5] = "CommaToken";
	SyntaxKind2[SyntaxKind2["ColonToken"] = 6] = "ColonToken";
	SyntaxKind2[SyntaxKind2["NullKeyword"] = 7] = "NullKeyword";
	SyntaxKind2[SyntaxKind2["TrueKeyword"] = 8] = "TrueKeyword";
	SyntaxKind2[SyntaxKind2["FalseKeyword"] = 9] = "FalseKeyword";
	SyntaxKind2[SyntaxKind2["StringLiteral"] = 10] = "StringLiteral";
	SyntaxKind2[SyntaxKind2["NumericLiteral"] = 11] = "NumericLiteral";
	SyntaxKind2[SyntaxKind2["LineCommentTrivia"] = 12] = "LineCommentTrivia";
	SyntaxKind2[SyntaxKind2["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
	SyntaxKind2[SyntaxKind2["LineBreakTrivia"] = 14] = "LineBreakTrivia";
	SyntaxKind2[SyntaxKind2["Trivia"] = 15] = "Trivia";
	SyntaxKind2[SyntaxKind2["Unknown"] = 16] = "Unknown";
	SyntaxKind2[SyntaxKind2["EOF"] = 17] = "EOF";
})(SyntaxKind || (SyntaxKind = {}));
var parse2 = parse;
var ParseErrorCode;
(function(ParseErrorCode2) {
	ParseErrorCode2[ParseErrorCode2["InvalidSymbol"] = 1] = "InvalidSymbol";
	ParseErrorCode2[ParseErrorCode2["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
	ParseErrorCode2[ParseErrorCode2["PropertyNameExpected"] = 3] = "PropertyNameExpected";
	ParseErrorCode2[ParseErrorCode2["ValueExpected"] = 4] = "ValueExpected";
	ParseErrorCode2[ParseErrorCode2["ColonExpected"] = 5] = "ColonExpected";
	ParseErrorCode2[ParseErrorCode2["CommaExpected"] = 6] = "CommaExpected";
	ParseErrorCode2[ParseErrorCode2["CloseBraceExpected"] = 7] = "CloseBraceExpected";
	ParseErrorCode2[ParseErrorCode2["CloseBracketExpected"] = 8] = "CloseBracketExpected";
	ParseErrorCode2[ParseErrorCode2["EndOfFileExpected"] = 9] = "EndOfFileExpected";
	ParseErrorCode2[ParseErrorCode2["InvalidCommentToken"] = 10] = "InvalidCommentToken";
	ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
	ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
	ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
	ParseErrorCode2[ParseErrorCode2["InvalidUnicode"] = 14] = "InvalidUnicode";
	ParseErrorCode2[ParseErrorCode2["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
	ParseErrorCode2[ParseErrorCode2["InvalidCharacter"] = 16] = "InvalidCharacter";
})(ParseErrorCode || (ParseErrorCode = {}));
function printParseErrorCode(code) {
	switch (code) {
		case 1: return "InvalidSymbol";
		case 2: return "InvalidNumberFormat";
		case 3: return "PropertyNameExpected";
		case 4: return "ValueExpected";
		case 5: return "ColonExpected";
		case 6: return "CommaExpected";
		case 7: return "CloseBraceExpected";
		case 8: return "CloseBracketExpected";
		case 9: return "EndOfFileExpected";
		case 10: return "InvalidCommentToken";
		case 11: return "UnexpectedEndOfComment";
		case 12: return "UnexpectedEndOfString";
		case 13: return "UnexpectedEndOfNumber";
		case 14: return "InvalidUnicode";
		case 15: return "InvalidEscapeCharacter";
		case 16: return "InvalidCharacter";
	}
	return "<unknown ParseErrorCode>";
}
__name(printParseErrorCode, "printParseErrorCode");
function format2(documentText, range, options) {
	return format$1(documentText, range, options);
}
__name(format2, "format");
function modify(text, path4$1, value, options) {
	return setProperty(text, path4$1, value, options);
}
__name(modify, "modify");
function applyEdits(text, edits) {
	let sortedEdits = edits.slice(0).sort((a, b) => {
		const diff$2 = a.offset - b.offset;
		if (diff$2 === 0) return a.length - b.length;
		return diff$2;
	});
	let lastModifiedOffset = text.length;
	for (let i$1 = sortedEdits.length - 1; i$1 >= 0; i$1--) {
		let e = sortedEdits[i$1];
		if (e.offset + e.length <= lastModifiedOffset) text = applyEdit(text, e);
		else throw new Error("Overlapping edit");
		lastModifiedOffset = e.offset;
	}
	return text;
}
__name(applyEdits, "applyEdits");
function getLineColFromPtr(string, ptr) {
	let lines = string.slice(0, ptr).split(/\r\n|\n|\r/g);
	return [lines.length, lines.pop().length + 1];
}
__name(getLineColFromPtr, "getLineColFromPtr");
function makeCodeBlock(string, line, column) {
	let lines = string.split(/\r\n|\n|\r/g);
	let codeblock = "";
	let numberLen = (Math.log10(line + 1) | 0) + 1;
	for (let i$1 = line - 1; i$1 <= line + 1; i$1++) {
		let l = lines[i$1 - 1];
		if (!l) continue;
		codeblock += i$1.toString().padEnd(numberLen, " ");
		codeblock += ":  ";
		codeblock += l;
		codeblock += "\n";
		if (i$1 === line) {
			codeblock += " ".repeat(numberLen + column + 2);
			codeblock += "^\n";
		}
	}
	return codeblock;
}
__name(makeCodeBlock, "makeCodeBlock");
var TomlError = class extends Error {
	static {
		__name(this, "TomlError");
	}
	line;
	column;
	codeblock;
	constructor(message, options) {
		const [line, column] = getLineColFromPtr(options.toml, options.ptr);
		const codeblock = makeCodeBlock(options.toml, line, column);
		super(`Invalid TOML document: ${message}

${codeblock}`, options);
		this.line = line;
		this.column = column;
		this.codeblock = codeblock;
	}
};
function isEscaped(str, ptr) {
	let i$1 = 0;
	while (str[ptr - ++i$1] === "\\");
	return --i$1 && i$1 % 2;
}
__name(isEscaped, "isEscaped");
function indexOfNewline(str, start = 0, end = str.length) {
	let idx = str.indexOf("\n", start);
	if (str[idx - 1] === "\r") idx--;
	return idx <= end ? idx : -1;
}
__name(indexOfNewline, "indexOfNewline");
function skipComment(str, ptr) {
	for (let i$1 = ptr; i$1 < str.length; i$1++) {
		let c = str[i$1];
		if (c === "\n") return i$1;
		if (c === "\r" && str[i$1 + 1] === "\n") return i$1 + 1;
		if (c < " " && c !== "	" || c === "") throw new TomlError("control characters are not allowed in comments", {
			toml: str,
			ptr
		});
	}
	return str.length;
}
__name(skipComment, "skipComment");
function skipVoid(str, ptr, banNewLines, banComments) {
	let c;
	while ((c = str[ptr]) === " " || c === "	" || !banNewLines && (c === "\n" || c === "\r" && str[ptr + 1] === "\n")) ptr++;
	return banComments || c !== "#" ? ptr : skipVoid(str, skipComment(str, ptr), banNewLines);
}
__name(skipVoid, "skipVoid");
function skipUntil(str, ptr, sep, end, banNewLines = false) {
	if (!end) {
		ptr = indexOfNewline(str, ptr);
		return ptr < 0 ? str.length : ptr;
	}
	for (let i$1 = ptr; i$1 < str.length; i$1++) {
		let c = str[i$1];
		if (c === "#") i$1 = indexOfNewline(str, i$1);
		else if (c === sep) return i$1 + 1;
		else if (c === end || banNewLines && (c === "\n" || c === "\r" && str[i$1 + 1] === "\n")) return i$1;
	}
	throw new TomlError("cannot find end of structure", {
		toml: str,
		ptr
	});
}
__name(skipUntil, "skipUntil");
function getStringEnd(str, seek) {
	let first = str[seek];
	let target$1 = first === str[seek + 1] && str[seek + 1] === str[seek + 2] ? str.slice(seek, seek + 3) : first;
	seek += target$1.length - 1;
	do
		seek = str.indexOf(target$1, ++seek);
	while (seek > -1 && first !== "'" && isEscaped(str, seek));
	if (seek > -1) {
		seek += target$1.length;
		if (target$1.length > 1) {
			if (str[seek] === first) seek++;
			if (str[seek] === first) seek++;
		}
	}
	return seek;
}
__name(getStringEnd, "getStringEnd");
var DATE_TIME_RE = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;
var TomlDate = class _TomlDate extends Date {
	static {
		__name(this, "TomlDate");
	}
	#hasDate = false;
	#hasTime = false;
	#offset = null;
	constructor(date) {
		let hasDate = true;
		let hasTime = true;
		let offset = "Z";
		if (typeof date === "string") {
			let match = date.match(DATE_TIME_RE);
			if (match) {
				if (!match[1]) {
					hasDate = false;
					date = `0000-01-01T${date}`;
				}
				hasTime = !!match[2];
				hasTime && date[10] === " " && (date = date.replace(" ", "T"));
				if (match[2] && +match[2] > 23) date = "";
				else {
					offset = match[3] || null;
					date = date.toUpperCase();
					if (!offset && hasTime) date += "Z";
				}
			} else date = "";
		}
		super(date);
		if (!isNaN(this.getTime())) {
			this.#hasDate = hasDate;
			this.#hasTime = hasTime;
			this.#offset = offset;
		}
	}
	isDateTime() {
		return this.#hasDate && this.#hasTime;
	}
	isLocal() {
		return !this.#hasDate || !this.#hasTime || !this.#offset;
	}
	isDate() {
		return this.#hasDate && !this.#hasTime;
	}
	isTime() {
		return this.#hasTime && !this.#hasDate;
	}
	isValid() {
		return this.#hasDate || this.#hasTime;
	}
	toISOString() {
		let iso = super.toISOString();
		if (this.isDate()) return iso.slice(0, 10);
		if (this.isTime()) return iso.slice(11, 23);
		if (this.#offset === null) return iso.slice(0, -1);
		if (this.#offset === "Z") return iso;
		let offset = +this.#offset.slice(1, 3) * 60 + +this.#offset.slice(4, 6);
		offset = this.#offset[0] === "-" ? offset : -offset;
		return (/* @__PURE__ */ new Date(this.getTime() - offset * 6e4)).toISOString().slice(0, -1) + this.#offset;
	}
	static wrapAsOffsetDateTime(jsDate, offset = "Z") {
		let date = new _TomlDate(jsDate);
		date.#offset = offset;
		return date;
	}
	static wrapAsLocalDateTime(jsDate) {
		let date = new _TomlDate(jsDate);
		date.#offset = null;
		return date;
	}
	static wrapAsLocalDate(jsDate) {
		let date = new _TomlDate(jsDate);
		date.#hasTime = false;
		date.#offset = null;
		return date;
	}
	static wrapAsLocalTime(jsDate) {
		let date = new _TomlDate(jsDate);
		date.#hasDate = false;
		date.#offset = null;
		return date;
	}
};
var INT_REGEX = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/;
var FLOAT_REGEX = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/;
var LEADING_ZERO = /^[+-]?0[0-9_]/;
var ESCAPE_REGEX = /^[0-9a-f]{4,8}$/i;
var ESC_MAP = {
	b: "\b",
	t: "	",
	n: "\n",
	f: "\f",
	r: "\r",
	"\"": "\"",
	"\\": "\\"
};
function parseString(str, ptr = 0, endPtr = str.length) {
	let isLiteral = str[ptr] === "'";
	let isMultiline = str[ptr++] === str[ptr] && str[ptr] === str[ptr + 1];
	if (isMultiline) {
		endPtr -= 2;
		if (str[ptr += 2] === "\r") ptr++;
		if (str[ptr] === "\n") ptr++;
	}
	let tmp = 0;
	let isEscape;
	let parsed = "";
	let sliceStart = ptr;
	while (ptr < endPtr - 1) {
		let c = str[ptr++];
		if (c === "\n" || c === "\r" && str[ptr] === "\n") {
			if (!isMultiline) throw new TomlError("newlines are not allowed in strings", {
				toml: str,
				ptr: ptr - 1
			});
		} else if (c < " " && c !== "	" || c === "") throw new TomlError("control characters are not allowed in strings", {
			toml: str,
			ptr: ptr - 1
		});
		if (isEscape) {
			isEscape = false;
			if (c === "u" || c === "U") {
				let code = str.slice(ptr, ptr += c === "u" ? 4 : 8);
				if (!ESCAPE_REGEX.test(code)) throw new TomlError("invalid unicode escape", {
					toml: str,
					ptr: tmp
				});
				try {
					parsed += String.fromCodePoint(parseInt(code, 16));
				} catch {
					throw new TomlError("invalid unicode escape", {
						toml: str,
						ptr: tmp
					});
				}
			} else if (isMultiline && (c === "\n" || c === " " || c === "	" || c === "\r")) {
				ptr = skipVoid(str, ptr - 1, true);
				if (str[ptr] !== "\n" && str[ptr] !== "\r") throw new TomlError("invalid escape: only line-ending whitespace may be escaped", {
					toml: str,
					ptr: tmp
				});
				ptr = skipVoid(str, ptr);
			} else if (c in ESC_MAP) parsed += ESC_MAP[c];
			else throw new TomlError("unrecognized escape sequence", {
				toml: str,
				ptr: tmp
			});
			sliceStart = ptr;
		} else if (!isLiteral && c === "\\") {
			tmp = ptr - 1;
			isEscape = true;
			parsed += str.slice(sliceStart, tmp);
		}
	}
	return parsed + str.slice(sliceStart, endPtr - 1);
}
__name(parseString, "parseString");
function parseValue(value, toml, ptr, integersAsBigInt) {
	if (value === "true") return true;
	if (value === "false") return false;
	if (value === "-inf") return -Infinity;
	if (value === "inf" || value === "+inf") return Infinity;
	if (value === "nan" || value === "+nan" || value === "-nan") return NaN;
	if (value === "-0") return integersAsBigInt ? 0n : 0;
	let isInt = INT_REGEX.test(value);
	if (isInt || FLOAT_REGEX.test(value)) {
		if (LEADING_ZERO.test(value)) throw new TomlError("leading zeroes are not allowed", {
			toml,
			ptr
		});
		value = value.replace(/_/g, "");
		let numeric$1 = +value;
		if (isNaN(numeric$1)) throw new TomlError("invalid number", {
			toml,
			ptr
		});
		if (isInt) {
			if ((isInt = !Number.isSafeInteger(numeric$1)) && !integersAsBigInt) throw new TomlError("integer value cannot be represented losslessly", {
				toml,
				ptr
			});
			if (isInt || integersAsBigInt === true) numeric$1 = BigInt(value);
		}
		return numeric$1;
	}
	const date = new TomlDate(value);
	if (!date.isValid()) throw new TomlError("invalid value", {
		toml,
		ptr
	});
	return date;
}
__name(parseValue, "parseValue");
function sliceAndTrimEndOf(str, startPtr, endPtr, allowNewLines) {
	let value = str.slice(startPtr, endPtr);
	let commentIdx = value.indexOf("#");
	if (commentIdx > -1) {
		skipComment(str, commentIdx);
		value = value.slice(0, commentIdx);
	}
	let trimmed = value.trimEnd();
	if (!allowNewLines) {
		let newlineIdx = value.indexOf("\n", trimmed.length);
		if (newlineIdx > -1) throw new TomlError("newlines are not allowed in inline tables", {
			toml: str,
			ptr: startPtr + newlineIdx
		});
	}
	return [trimmed, commentIdx];
}
__name(sliceAndTrimEndOf, "sliceAndTrimEndOf");
function extractValue(str, ptr, end, depth, integersAsBigInt) {
	if (depth === 0) throw new TomlError("document contains excessively nested structures. aborting.", {
		toml: str,
		ptr
	});
	let c = str[ptr];
	if (c === "[" || c === "{") {
		let [value, endPtr2] = c === "[" ? parseArray(str, ptr, depth, integersAsBigInt) : parseInlineTable(str, ptr, depth, integersAsBigInt);
		let newPtr = end ? skipUntil(str, endPtr2, ",", end) : endPtr2;
		if (endPtr2 - newPtr && end === "}") {
			let nextNewLine = indexOfNewline(str, endPtr2, newPtr);
			if (nextNewLine > -1) throw new TomlError("newlines are not allowed in inline tables", {
				toml: str,
				ptr: nextNewLine
			});
		}
		return [value, newPtr];
	}
	let endPtr;
	if (c === "\"" || c === "'") {
		endPtr = getStringEnd(str, ptr);
		let parsed = parseString(str, ptr, endPtr);
		if (end) {
			endPtr = skipVoid(str, endPtr, end !== "]");
			if (str[endPtr] && str[endPtr] !== "," && str[endPtr] !== end && str[endPtr] !== "\n" && str[endPtr] !== "\r") throw new TomlError("unexpected character encountered", {
				toml: str,
				ptr: endPtr
			});
			endPtr += +(str[endPtr] === ",");
		}
		return [parsed, endPtr];
	}
	endPtr = skipUntil(str, ptr, ",", end);
	let slice = sliceAndTrimEndOf(str, ptr, endPtr - +(str[endPtr - 1] === ","), end === "]");
	if (!slice[0]) throw new TomlError("incomplete key-value declaration: no value specified", {
		toml: str,
		ptr
	});
	if (end && slice[1] > -1) {
		endPtr = skipVoid(str, ptr + slice[1]);
		endPtr += +(str[endPtr] === ",");
	}
	return [parseValue(slice[0], str, ptr, integersAsBigInt), endPtr];
}
__name(extractValue, "extractValue");
var KEY_PART_RE = /^[a-zA-Z0-9-_]+[ \t]*$/;
function parseKey(str, ptr, end = "=") {
	let dot = ptr - 1;
	let parsed = [];
	let endPtr = str.indexOf(end, ptr);
	if (endPtr < 0) throw new TomlError("incomplete key-value: cannot find end of key", {
		toml: str,
		ptr
	});
	do {
		let c = str[ptr = ++dot];
		if (c !== " " && c !== "	") if (c === "\"" || c === "'") {
			if (c === str[ptr + 1] && c === str[ptr + 2]) throw new TomlError("multiline strings are not allowed in keys", {
				toml: str,
				ptr
			});
			let eos = getStringEnd(str, ptr);
			if (eos < 0) throw new TomlError("unfinished string encountered", {
				toml: str,
				ptr
			});
			dot = str.indexOf(".", eos);
			let strEnd = str.slice(eos, dot < 0 || dot > endPtr ? endPtr : dot);
			let newLine = indexOfNewline(strEnd);
			if (newLine > -1) throw new TomlError("newlines are not allowed in keys", {
				toml: str,
				ptr: ptr + dot + newLine
			});
			if (strEnd.trimStart()) throw new TomlError("found extra tokens after the string part", {
				toml: str,
				ptr: eos
			});
			if (endPtr < eos) {
				endPtr = str.indexOf(end, eos);
				if (endPtr < 0) throw new TomlError("incomplete key-value: cannot find end of key", {
					toml: str,
					ptr
				});
			}
			parsed.push(parseString(str, ptr, eos));
		} else {
			dot = str.indexOf(".", ptr);
			let part = str.slice(ptr, dot < 0 || dot > endPtr ? endPtr : dot);
			if (!KEY_PART_RE.test(part)) throw new TomlError("only letter, numbers, dashes and underscores are allowed in keys", {
				toml: str,
				ptr
			});
			parsed.push(part.trimEnd());
		}
	} while (dot + 1 && dot < endPtr);
	return [parsed, skipVoid(str, endPtr + 1, true, true)];
}
__name(parseKey, "parseKey");
function parseInlineTable(str, ptr, depth, integersAsBigInt) {
	let res = {};
	let seen = /* @__PURE__ */ new Set();
	let c;
	let comma$1 = 0;
	ptr++;
	while ((c = str[ptr++]) !== "}" && c) {
		let err = {
			toml: str,
			ptr: ptr - 1
		};
		if (c === "\n") throw new TomlError("newlines are not allowed in inline tables", err);
		else if (c === "#") throw new TomlError("inline tables cannot contain comments", err);
		else if (c === ",") throw new TomlError("expected key-value, found comma", err);
		else if (c !== " " && c !== "	") {
			let k;
			let t$5 = res;
			let hasOwn$1 = false;
			let [key, keyEndPtr] = parseKey(str, ptr - 1);
			for (let i$1 = 0; i$1 < key.length; i$1++) {
				if (i$1) t$5 = hasOwn$1 ? t$5[k] : t$5[k] = {};
				k = key[i$1];
				if ((hasOwn$1 = Object.hasOwn(t$5, k)) && (typeof t$5[k] !== "object" || seen.has(t$5[k]))) throw new TomlError("trying to redefine an already defined value", {
					toml: str,
					ptr
				});
				if (!hasOwn$1 && k === "__proto__") Object.defineProperty(t$5, k, {
					enumerable: true,
					configurable: true,
					writable: true
				});
			}
			if (hasOwn$1) throw new TomlError("trying to redefine an already defined value", {
				toml: str,
				ptr
			});
			let [value, valueEndPtr] = extractValue(str, keyEndPtr, "}", depth - 1, integersAsBigInt);
			seen.add(value);
			t$5[k] = value;
			ptr = valueEndPtr;
			comma$1 = str[ptr - 1] === "," ? ptr - 1 : 0;
		}
	}
	if (comma$1) throw new TomlError("trailing commas are not allowed in inline tables", {
		toml: str,
		ptr: comma$1
	});
	if (!c) throw new TomlError("unfinished table encountered", {
		toml: str,
		ptr
	});
	return [res, ptr];
}
__name(parseInlineTable, "parseInlineTable");
function parseArray(str, ptr, depth, integersAsBigInt) {
	let res = [];
	let c;
	ptr++;
	while ((c = str[ptr++]) !== "]" && c) if (c === ",") throw new TomlError("expected value, found comma", {
		toml: str,
		ptr: ptr - 1
	});
	else if (c === "#") ptr = skipComment(str, ptr);
	else if (c !== " " && c !== "	" && c !== "\n" && c !== "\r") {
		let e = extractValue(str, ptr - 1, "]", depth - 1, integersAsBigInt);
		res.push(e[0]);
		ptr = e[1];
	}
	if (!c) throw new TomlError("unfinished array encountered", {
		toml: str,
		ptr
	});
	return [res, ptr];
}
__name(parseArray, "parseArray");
function peekTable(key, table, meta, type) {
	let t$5 = table;
	let m = meta;
	let k;
	let hasOwn$1 = false;
	let state;
	for (let i$1 = 0; i$1 < key.length; i$1++) {
		if (i$1) {
			t$5 = hasOwn$1 ? t$5[k] : t$5[k] = {};
			m = (state = m[k]).c;
			if (type === 0 && (state.t === 1 || state.t === 2)) return null;
			if (state.t === 2) {
				let l = t$5.length - 1;
				t$5 = t$5[l];
				m = m[l].c;
			}
		}
		k = key[i$1];
		if ((hasOwn$1 = Object.hasOwn(t$5, k)) && m[k]?.t === 0 && m[k]?.d) return null;
		if (!hasOwn$1) {
			if (k === "__proto__") {
				Object.defineProperty(t$5, k, {
					enumerable: true,
					configurable: true,
					writable: true
				});
				Object.defineProperty(m, k, {
					enumerable: true,
					configurable: true,
					writable: true
				});
			}
			m[k] = {
				t: i$1 < key.length - 1 && type === 2 ? 3 : type,
				d: false,
				i: 0,
				c: {}
			};
		}
	}
	state = m[k];
	if (state.t !== type && !(type === 1 && state.t === 3)) return null;
	if (type === 2) {
		if (!state.d) {
			state.d = true;
			t$5[k] = [];
		}
		t$5[k].push(t$5 = {});
		state.c[state.i++] = state = {
			t: 1,
			d: false,
			i: 0,
			c: {}
		};
	}
	if (state.d) return null;
	state.d = true;
	if (type === 1) t$5 = hasOwn$1 ? t$5[k] : t$5[k] = {};
	else if (type === 0 && hasOwn$1) return null;
	return [
		k,
		t$5,
		state.c
	];
}
__name(peekTable, "peekTable");
function parse3(toml, { maxDepth = 1e3, integersAsBigInt } = {}) {
	let res = {};
	let meta = {};
	let tbl = res;
	let m = meta;
	for (let ptr = skipVoid(toml, 0); ptr < toml.length;) {
		if (toml[ptr] === "[") {
			let isTableArray = toml[++ptr] === "[";
			let k = parseKey(toml, ptr += +isTableArray, "]");
			if (isTableArray) {
				if (toml[k[1] - 1] !== "]") throw new TomlError("expected end of table declaration", {
					toml,
					ptr: k[1] - 1
				});
				k[1]++;
			}
			let p = peekTable(k[0], res, meta, isTableArray ? 2 : 1);
			if (!p) throw new TomlError("trying to redefine an already defined table or value", {
				toml,
				ptr
			});
			m = p[2];
			tbl = p[1];
			ptr = k[1];
		} else {
			let k = parseKey(toml, ptr);
			let p = peekTable(k[0], tbl, m, 0);
			if (!p) throw new TomlError("trying to redefine an already defined table or value", {
				toml,
				ptr
			});
			let v = extractValue(toml, k[1], void 0, maxDepth, integersAsBigInt);
			p[1][p[0]] = v[0];
			ptr = v[1];
		}
		ptr = skipVoid(toml, ptr, true);
		if (toml[ptr] && toml[ptr] !== "\n" && toml[ptr] !== "\r") throw new TomlError("each key-value declaration must be followed by an end-of-line", {
			toml,
			ptr
		});
		ptr = skipVoid(toml, ptr);
	}
	return res;
}
__name(parse3, "parse");
var BARE_KEY = /^[a-z0-9-_]+$/i;
function extendedTypeOf(obj) {
	let type = typeof obj;
	if (type === "object") {
		if (Array.isArray(obj)) return "array";
		if (obj instanceof Date) return "date";
	}
	return type;
}
__name(extendedTypeOf, "extendedTypeOf");
function isArrayOfTables(obj) {
	for (let i$1 = 0; i$1 < obj.length; i$1++) if (extendedTypeOf(obj[i$1]) !== "object") return false;
	return obj.length != 0;
}
__name(isArrayOfTables, "isArrayOfTables");
function formatString(s) {
	return JSON.stringify(s).replace(/\x7f/g, "\\u007f");
}
__name(formatString, "formatString");
function stringifyValue(val, type, depth, numberAsFloat) {
	if (depth === 0) throw new Error("Could not stringify the object: maximum object depth exceeded");
	if (type === "number") {
		if (isNaN(val)) return "nan";
		if (val === Infinity) return "inf";
		if (val === -Infinity) return "-inf";
		if (numberAsFloat && Number.isInteger(val)) return val.toFixed(1);
		return val.toString();
	}
	if (type === "bigint" || type === "boolean") return val.toString();
	if (type === "string") return formatString(val);
	if (type === "date") {
		if (isNaN(val.getTime())) throw new TypeError("cannot serialize invalid date");
		return val.toISOString();
	}
	if (type === "object") return stringifyInlineTable(val, depth, numberAsFloat);
	if (type === "array") return stringifyArray(val, depth, numberAsFloat);
}
__name(stringifyValue, "stringifyValue");
function stringifyInlineTable(obj, depth, numberAsFloat) {
	let keys = Object.keys(obj);
	if (keys.length === 0) return "{}";
	let res = "{ ";
	for (let i$1 = 0; i$1 < keys.length; i$1++) {
		let k = keys[i$1];
		if (i$1) res += ", ";
		res += BARE_KEY.test(k) ? k : formatString(k);
		res += " = ";
		res += stringifyValue(obj[k], extendedTypeOf(obj[k]), depth - 1, numberAsFloat);
	}
	return res + " }";
}
__name(stringifyInlineTable, "stringifyInlineTable");
function stringifyArray(array, depth, numberAsFloat) {
	if (array.length === 0) return "[]";
	let res = "[ ";
	for (let i$1 = 0; i$1 < array.length; i$1++) {
		if (i$1) res += ", ";
		if (array[i$1] === null || array[i$1] === void 0) throw new TypeError("arrays cannot contain null or undefined values");
		res += stringifyValue(array[i$1], extendedTypeOf(array[i$1]), depth - 1, numberAsFloat);
	}
	return res + " ]";
}
__name(stringifyArray, "stringifyArray");
function stringifyArrayTable(array, key, depth, numberAsFloat) {
	if (depth === 0) throw new Error("Could not stringify the object: maximum object depth exceeded");
	let res = "";
	for (let i$1 = 0; i$1 < array.length; i$1++) {
		res += `${res && "\n"}[[${key}]]
`;
		res += stringifyTable(0, array[i$1], key, depth, numberAsFloat);
	}
	return res;
}
__name(stringifyArrayTable, "stringifyArrayTable");
function stringifyTable(tableKey, obj, prefix, depth, numberAsFloat) {
	if (depth === 0) throw new Error("Could not stringify the object: maximum object depth exceeded");
	let preamble = "";
	let tables = "";
	let keys = Object.keys(obj);
	for (let i$1 = 0; i$1 < keys.length; i$1++) {
		let k = keys[i$1];
		if (obj[k] !== null && obj[k] !== void 0) {
			let type = extendedTypeOf(obj[k]);
			if (type === "symbol" || type === "function") throw new TypeError(`cannot serialize values of type '${type}'`);
			let key = BARE_KEY.test(k) ? k : formatString(k);
			if (type === "array" && isArrayOfTables(obj[k])) tables += (tables && "\n") + stringifyArrayTable(obj[k], prefix ? `${prefix}.${key}` : key, depth - 1, numberAsFloat);
			else if (type === "object") {
				let tblKey = prefix ? `${prefix}.${key}` : key;
				tables += (tables && "\n") + stringifyTable(tblKey, obj[k], tblKey, depth - 1, numberAsFloat);
			} else {
				preamble += key;
				preamble += " = ";
				preamble += stringifyValue(obj[k], type, depth, numberAsFloat);
				preamble += "\n";
			}
		}
	}
	if (tableKey && (preamble || !tables)) preamble = preamble ? `[${tableKey}]
${preamble}` : `[${tableKey}]`;
	return preamble && tables ? `${preamble}
${tables}` : preamble || tables;
}
__name(stringifyTable, "stringifyTable");
function stringify(obj, { maxDepth = 1e3, numbersAsFloat = false } = {}) {
	if (extendedTypeOf(obj) !== "object") throw new TypeError("stringify can only be called with an object");
	let str = stringifyTable(0, obj, "", maxDepth, numbersAsFloat);
	if (str[str.length - 1] !== "\n") return str + "\n";
	return str;
}
__name(stringify, "stringify");
var dist_default = {
	parse: parse3,
	stringify,
	TomlDate,
	TomlError
};
var ParseError = class extends UserError$1 {
	static {
		__name(this, "ParseError");
	}
	text;
	notes;
	location;
	kind;
	constructor({ text, notes, location, kind, telemetryMessage }) {
		super(text, { telemetryMessage });
		this.name = this.constructor.name;
		this.text = text;
		this.notes = notes ?? [];
		this.location = location;
		this.kind = kind ?? "error";
	}
};
var APIError = class extends ParseError {
	static {
		__name(this, "APIError");
	}
	#status;
	code;
	accountTag;
	constructor({ status,...rest }) {
		super(rest);
		this.name = this.constructor.name;
		this.#status = status;
	}
	isGatewayError() {
		if (this.#status !== void 0) return [524].includes(this.#status);
		return false;
	}
	isRetryable() {
		return String(this.#status).startsWith("5");
	}
	#reportable = true;
	get reportable() {
		return this.#reportable;
	}
	preventReport() {
		this.#reportable = false;
	}
};
function parseTOML(tomlContent, filePath) {
	try {
		return dist_default.parse(tomlContent);
	} catch (err) {
		if (!(err instanceof TomlError)) throw err;
		const location = {
			lineText: tomlContent.split("\n")[err.line - 1],
			line: err.line,
			column: err.column - 1,
			file: filePath,
			fileText: tomlContent
		};
		throw new ParseError({
			text: err.message.substring(0, err.message.indexOf("\n")),
			location,
			telemetryMessage: "TOML parse error"
		});
	}
}
__name(parseTOML, "parseTOML");
function parsePackageJSON(input, file) {
	return parseJSON(input, file);
}
__name(parsePackageJSON, "parsePackageJSON");
function parseJSON(input, file) {
	return parseJSONC(input, file, {
		allowEmptyContent: false,
		allowTrailingComma: false,
		disallowComments: true
	});
}
__name(parseJSON, "parseJSON");
function parseJSONC(input, file, options = { allowTrailingComma: true }) {
	const errors = [];
	const data$1 = parse2(input, errors, options);
	if (errors.length) throw new ParseError({
		text: printParseErrorCode(errors[0].error),
		location: {
			...indexLocation({
				file,
				fileText: input
			}, errors[0].offset + 1),
			length: errors[0].length
		},
		telemetryMessage: "JSON(C) parse error"
	});
	return data$1;
}
__name(parseJSONC, "parseJSONC");
function readFileSyncToBuffer(file) {
	try {
		return readFileSync(file);
	} catch (err) {
		const { message } = err;
		throw new ParseError({
			text: `Could not read file: ${file}`,
			notes: [{ text: message.replace(file, resolve(file)) }]
		});
	}
}
__name(readFileSyncToBuffer, "readFileSyncToBuffer");
function readFileSync$1(file) {
	try {
		return removeBOMAndValidate(readFileSync(file), file);
	} catch (err) {
		if (err instanceof ParseError) throw err;
		const { message } = err;
		throw new ParseError({
			text: `Could not read file: ${file}`,
			notes: [{ text: message.replace(file, resolve(file)) }],
			telemetryMessage: "Could not read file"
		});
	}
}
__name(readFileSync$1, "readFileSync");
function indexLocation(file, index) {
	let lineText, line = 0, column = 0, cursor = 0;
	const { fileText = "" } = file;
	for (const row of fileText.split("\n")) {
		line++;
		cursor += row.length + 1;
		if (cursor >= index) {
			lineText = row;
			column = row.length - (cursor - index);
			break;
		}
	}
	return {
		lineText,
		line,
		column,
		...file
	};
}
__name(indexLocation, "indexLocation");
function searchLocation(file, query) {
	let lineText, length, line = 0, column = 0;
	const queryText = String(query);
	const { fileText = "" } = file;
	for (const content of fileText.split("\n")) {
		line++;
		const index = content.indexOf(queryText);
		if (index >= 0) {
			lineText = content;
			column = index;
			length = queryText.length;
			break;
		}
	}
	return {
		lineText,
		line,
		column,
		length,
		...file
	};
}
__name(searchLocation, "searchLocation");
var units = {
	nanoseconds: 1e-9,
	nanosecond: 1e-9,
	microseconds: 1e-6,
	microsecond: 1e-6,
	milliseconds: .001,
	millisecond: .001,
	seconds: 1,
	second: 1,
	minutes: 60,
	minute: 60,
	hours: 3600,
	hour: 3600,
	days: 86400,
	day: 86400,
	weeks: 604800,
	week: 604800,
	month: 18144e3,
	year: 220752e3,
	nsecs: 1e-9,
	nsec: 1e-9,
	usecs: 1e-6,
	usec: 1e-6,
	msecs: .001,
	msec: .001,
	secs: 1,
	sec: 1,
	mins: 60,
	min: 60,
	ns: 1e-9,
	us: 1e-6,
	ms: .001,
	mo: 18144e3,
	yr: 220752e3,
	s: 1,
	m: 60,
	h: 3600,
	d: 86400,
	w: 604800,
	y: 220752e3
};
function parseHumanDuration(s) {
	const unitsMap = new Map(Object.entries(units));
	s = s.trim().toLowerCase();
	let base = 1;
	for (const [name, _] of unitsMap) if (s.endsWith(name)) {
		s = s.substring(0, s.length - name.length);
		base = unitsMap.get(name) || 1;
		break;
	}
	return Number(s) * base;
}
__name(parseHumanDuration, "parseHumanDuration");
function parseNonHyphenedUuid(uuid) {
	if (uuid == null || uuid.includes("-")) return uuid;
	if (uuid.length != 32) return null;
	const uuid_parts = [];
	uuid_parts.push(uuid.slice(0, 8));
	uuid_parts.push(uuid.slice(8, 12));
	uuid_parts.push(uuid.slice(12, 16));
	uuid_parts.push(uuid.slice(16, 20));
	uuid_parts.push(uuid.slice(20));
	let hyphenated = "";
	uuid_parts.forEach((part) => hyphenated += part + "-");
	return hyphenated.slice(0, 36);
}
__name(parseNonHyphenedUuid, "parseNonHyphenedUuid");
function parseByteSize(s, base = void 0) {
	const match = s.match(/^(\d*\.*\d*)\s*([kKmMgGtTpP]{0,1})([i]{0,1}[bB]{0,1})$/);
	if (!match) return NaN;
	const size = match[1];
	if (size.length === 0 || isNaN(Number(size))) return NaN;
	const unit = match[2].toLowerCase();
	const sizeUnits = {
		k: 1,
		m: 2,
		g: 3,
		t: 4,
		p: 5
	};
	if (unit.length !== 0 && !(unit in sizeUnits)) return NaN;
	const binary = match[3].toLowerCase() == "ib";
	if (binary && unit.length === 0) return NaN;
	const pow = sizeUnits[unit] || 0;
	return Math.floor(Number(size) * Math.pow(base ?? (binary ? 1024 : 1e3), pow));
}
__name(parseByteSize, "parseByteSize");
var UNSUPPORTED_BOMS = [
	{
		buffer: Buffer.from([
			0,
			0,
			254,
			255
		]),
		encoding: "UTF-32 BE"
	},
	{
		buffer: Buffer.from([
			255,
			254,
			0,
			0
		]),
		encoding: "UTF-32 LE"
	},
	{
		buffer: Buffer.from([254, 255]),
		encoding: "UTF-16 BE"
	},
	{
		buffer: Buffer.from([255, 254]),
		encoding: "UTF-16 LE"
	}
];
function removeBOMAndValidate(buffer, file) {
	for (const bom of UNSUPPORTED_BOMS) if (buffer.length >= bom.buffer.length && buffer.subarray(0, bom.buffer.length).equals(bom.buffer)) throw new ParseError({
		text: `Configuration file contains ${bom.encoding} byte order marker`,
		notes: [{ text: `The file "${file}" appears to be encoded as ${bom.encoding}. Please save the file as UTF-8 without BOM.` }],
		location: {
			file,
			line: 1,
			column: 0
		},
		telemetryMessage: `${bom.encoding} BOM detected`
	});
	const content = buffer.toString("utf-8");
	if (content.charCodeAt(0) === 65279) return content.slice(1);
	return content;
}
__name(removeBOMAndValidate, "removeBOMAndValidate");
var typeMappings = {
	directory: "isDirectory",
	file: "isFile"
};
function checkType(type) {
	if (type in typeMappings) return;
	throw new Error(`Invalid type specified: ${type}`);
}
__name(checkType, "checkType");
var matchType = /* @__PURE__ */ __name((type, stat) => type === void 0 || stat[typeMappings[type]](), "matchType");
var toPath = /* @__PURE__ */ __name((urlOrPath) => urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath, "toPath");
function locatePathSync(paths, { cwd = process2.cwd(), type = "file", allowSymlinks = true } = {}) {
	checkType(type);
	cwd = toPath(cwd);
	const statFunction = allowSymlinks ? fs.statSync : fs.lstatSync;
	for (const path_ of paths) try {
		if (matchType(type, statFunction(path4.resolve(cwd, path_)))) return path_;
	} catch {}
}
__name(locatePathSync, "locatePathSync");
var toPath2 = /* @__PURE__ */ __name((urlOrPath) => urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath, "toPath");
var findUpStop = Symbol("findUpStop");
function findUpMultipleSync(name, options = {}) {
	let directory = path4.resolve(toPath2(options.cwd) || "");
	const { root } = path4.parse(directory);
	const stopAt = options.stopAt || root;
	const limit = options.limit || Number.POSITIVE_INFINITY;
	const paths = [name].flat();
	const runMatcher = /* @__PURE__ */ __name((locateOptions) => {
		if (typeof name !== "function") return locatePathSync(paths, locateOptions);
		const foundPath = name(locateOptions.cwd);
		if (typeof foundPath === "string") return locatePathSync([foundPath], locateOptions);
		return foundPath;
	}, "runMatcher");
	const matches = [];
	while (true) {
		const foundPath = runMatcher({
			...options,
			cwd: directory
		});
		if (foundPath === findUpStop) break;
		if (foundPath) matches.push(path4.resolve(directory, foundPath));
		if (directory === stopAt || matches.length >= limit) break;
		directory = path4.dirname(directory);
	}
	return matches;
}
__name(findUpMultipleSync, "findUpMultipleSync");
function findUpSync(name, options = {}) {
	return findUpMultipleSync(name, {
		...options,
		limit: 1
	})[0];
}
__name(findUpSync, "findUpSync");
function dedent(templ) {
	var values = [];
	for (var _i = 1; _i < arguments.length; _i++) values[_i - 1] = arguments[_i];
	var strings = Array.from(typeof templ === "string" ? [templ] : templ);
	strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
	var indentLengths = strings.reduce(function(arr, str) {
		var matches = str.match(/\n([\t ]+|(?!\s).)/g);
		if (matches) return arr.concat(matches.map(function(match) {
			var _a, _b;
			return (_b = (_a = match.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
		}));
		return arr;
	}, []);
	if (indentLengths.length) {
		var pattern_1 = new RegExp("\n[	 ]{" + Math.min.apply(Math, indentLengths) + "}", "g");
		strings = strings.map(function(str) {
			return str.replace(pattern_1, "\n");
		});
	}
	strings[0] = strings[0].replace(/^\r?\n/, "");
	var string = strings[0];
	values.forEach(function(value, i$1) {
		var endentations = string.match(/(?:^|\n)( *)$/);
		var endentation = endentations ? endentations[1] : "";
		var indentedValue = value;
		if (typeof value === "string" && value.includes("\n")) indentedValue = String(value).split("\n").map(function(str, i2) {
			return i2 === 0 ? str : "" + endentation + str;
		}).join("\n");
		string += indentedValue + strings[i$1 + 1];
	});
	return string;
}
__name(dedent, "dedent");
var esm_default = dedent;
function resolveWranglerConfigPath({ config, script }, options) {
	if (config !== void 0) return {
		userConfigPath: config,
		configPath: config,
		deployConfigPath: void 0,
		redirected: false
	};
	return findWranglerConfig$1(script !== void 0 ? path4.dirname(script) : process.cwd(), options);
}
__name(resolveWranglerConfigPath, "resolveWranglerConfigPath");
function findWranglerConfig$1(referencePath = process.cwd(), { useRedirectIfAvailable = false } = {}) {
	const userConfigPath = findUpSync(`wrangler.json`, { cwd: referencePath }) ?? findUpSync(`wrangler.jsonc`, { cwd: referencePath }) ?? findUpSync(`wrangler.toml`, { cwd: referencePath });
	if (!useRedirectIfAvailable) return {
		userConfigPath,
		configPath: userConfigPath,
		deployConfigPath: void 0,
		redirected: false
	};
	const { configPath, deployConfigPath, redirected } = findRedirectedWranglerConfig(referencePath, userConfigPath);
	return {
		userConfigPath,
		configPath,
		deployConfigPath,
		redirected
	};
}
__name(findWranglerConfig$1, "findWranglerConfig");
function findRedirectedWranglerConfig(cwd, userConfigPath) {
	const deployConfigPath = findUpSync(PATH_TO_DEPLOY_CONFIG, { cwd });
	if (deployConfigPath === void 0) return {
		configPath: userConfigPath,
		deployConfigPath,
		redirected: false
	};
	let redirectedConfigPath;
	const deployConfigFile = readFileSync$1(deployConfigPath);
	try {
		const deployConfig = parseJSONC(deployConfigFile, deployConfigPath);
		redirectedConfigPath = deployConfig.configPath && path4.resolve(path4.dirname(deployConfigPath), deployConfig.configPath);
	} catch (e) {
		throw new UserError$1(`Failed to parse the deploy configuration file at ${path4.relative(".", deployConfigPath)}`, { cause: e });
	}
	if (!redirectedConfigPath) throw new UserError$1(esm_default`
			A deploy configuration file was found at "${path4.relative(".", deployConfigPath)}".
			But this is not valid - the required "configPath" property was not found.
			Instead this file contains:
			\`\`\`
			${deployConfigFile}
			\`\`\`
		`);
	if (!existsSync(redirectedConfigPath)) throw new UserError$1(esm_default`
				There is a deploy configuration at "${path4.relative(".", deployConfigPath)}".
				But the redirected configuration path it points to, "${path4.relative(".", redirectedConfigPath)}", does not exist.
			`);
	if (userConfigPath) {
		if (path4.join(path4.dirname(userConfigPath), PATH_TO_DEPLOY_CONFIG) !== deployConfigPath) throw new UserError$1(esm_default`
					Found both a user configuration file at "${path4.relative(".", userConfigPath)}"
					and a deploy configuration file at "${path4.relative(".", deployConfigPath)}".
					But these do not share the same base path so it is not clear which should be used.
				`);
	}
	return {
		configPath: redirectedConfigPath,
		deployConfigPath,
		redirected: true
	};
}
__name(findRedirectedWranglerConfig, "findRedirectedWranglerConfig");
function isRedirectedRawConfig(rawConfig, configPath, userConfigPath) {
	return configPath !== void 0 && configPath !== userConfigPath;
}
__name(isRedirectedRawConfig, "isRedirectedRawConfig");
function configFormat(configPath) {
	if (configPath?.endsWith("toml")) return "toml";
	else if (configPath?.endsWith("json") || configPath?.endsWith("jsonc")) return "jsonc";
	return "none";
}
__name(configFormat, "configFormat");
function configFileName(configPath) {
	const format3 = configFormat(configPath);
	if (format3 === "toml") return "wrangler.toml";
	else if (format3 === "jsonc") return "wrangler.json";
	else return "Wrangler configuration";
}
__name(configFileName, "configFileName");
function formatConfigSnippet(snippet, configPath, formatted = true) {
	if (configFormat(configPath) === "toml") return dist_default.stringify(snippet);
	else return formatted ? JSON.stringify(snippet, null, 2) : JSON.stringify(snippet);
}
__name(formatConfigSnippet, "formatConfigSnippet");

//#endregion
//#region ../workers-utils/dist/index.mjs
var require_XDGAppPaths = __commonJS({ "../../node_modules/.pnpm/xdg-app-paths@8.3.0/node_modules/xdg-app-paths/dist/cjs/lib/XDGAppPaths.js"(exports$1) {
	exports$1.__esModule = true;
	exports$1.Adapt = void 0;
	function isBoolean2(t$5) {
		return typeOf(t$5) === "boolean";
	}
	__name(isBoolean2, "isBoolean");
	function isObject$1(t$5) {
		return typeOf(t$5) === "object";
	}
	__name(isObject$1, "isObject");
	function isString2(t$5) {
		return typeOf(t$5) === "string";
	}
	__name(isString2, "isString");
	function typeOf(t$5) {
		return typeof t$5;
	}
	__name(typeOf, "typeOf");
	function Adapt(adapter_) {
		var meta = adapter_.meta, path5 = adapter_.path, xdg = adapter_.xdg;
		return { XDGAppPaths: new (/* @__PURE__ */ function() {
			function XDGAppPaths_2(options_) {
				if (options_ === void 0) options_ = {};
				var _a, _b, _c;
				function XDGAppPaths(options2) {
					if (options2 === void 0) options2 = {};
					return new XDGAppPaths_2(options2);
				}
				__name(XDGAppPaths, "XDGAppPaths");
				var options = isObject$1(options_) ? options_ : { name: options_ };
				var suffix = (_a = options.suffix) !== null && _a !== void 0 ? _a : "";
				var isolated_ = (_b = options.isolated) !== null && _b !== void 0 ? _b : true;
				var namePriorityList = [
					options.name,
					meta.pkgMainFilename(),
					meta.mainFilename()
				];
				var name = path5.parse(((_c = namePriorityList.find(function(e) {
					return isString2(e);
				})) !== null && _c !== void 0 ? _c : "$eval") + suffix).name;
				XDGAppPaths.$name = /* @__PURE__ */ __name(function $name() {
					return name;
				}, "$name");
				XDGAppPaths.$isolated = /* @__PURE__ */ __name(function $isolated() {
					return isolated_;
				}, "$isolated");
				function isIsolated(dirOptions) {
					var _a2;
					dirOptions = dirOptions !== null && dirOptions !== void 0 ? dirOptions : { isolated: isolated_ };
					return isBoolean2(dirOptions) ? dirOptions : (_a2 = dirOptions.isolated) !== null && _a2 !== void 0 ? _a2 : isolated_;
				}
				__name(isIsolated, "isIsolated");
				function finalPathSegment(dirOptions) {
					return isIsolated(dirOptions) ? name : "";
				}
				__name(finalPathSegment, "finalPathSegment");
				XDGAppPaths.cache = /* @__PURE__ */ __name(function cache$2(dirOptions) {
					return path5.join(xdg.cache(), finalPathSegment(dirOptions));
				}, "cache");
				XDGAppPaths.config = /* @__PURE__ */ __name(function config(dirOptions) {
					return path5.join(xdg.config(), finalPathSegment(dirOptions));
				}, "config");
				XDGAppPaths.data = /* @__PURE__ */ __name(function data$1(dirOptions) {
					return path5.join(xdg.data(), finalPathSegment(dirOptions));
				}, "data");
				XDGAppPaths.runtime = /* @__PURE__ */ __name(function runtime(dirOptions) {
					return xdg.runtime() ? path5.join(xdg.runtime(), finalPathSegment(dirOptions)) : void 0;
				}, "runtime");
				XDGAppPaths.state = /* @__PURE__ */ __name(function state(dirOptions) {
					return path5.join(xdg.state(), finalPathSegment(dirOptions));
				}, "state");
				XDGAppPaths.configDirs = /* @__PURE__ */ __name(function configDirs(dirOptions) {
					return xdg.configDirs().map(function(s) {
						return path5.join(s, finalPathSegment(dirOptions));
					});
				}, "configDirs");
				XDGAppPaths.dataDirs = /* @__PURE__ */ __name(function dataDirs(dirOptions) {
					return xdg.dataDirs().map(function(s) {
						return path5.join(s, finalPathSegment(dirOptions));
					});
				}, "dataDirs");
				return XDGAppPaths;
			}
			__name(XDGAppPaths_2, "XDGAppPaths_");
			return XDGAppPaths_2;
		}())() };
	}
	__name(Adapt, "Adapt");
	exports$1.Adapt = Adapt;
} });
var require_XDG = __commonJS({ "../../node_modules/.pnpm/xdg-portable@10.6.0/node_modules/xdg-portable/dist/cjs/lib/XDG.js"(exports$1) {
	var __spreadArray = exports$1 && exports$1.__spreadArray || function(to, from) {
		for (var i$1 = 0, il = from.length, j = to.length; i$1 < il; i$1++, j++) to[j] = from[i$1];
		return to;
	};
	exports$1.__esModule = true;
	exports$1.Adapt = void 0;
	function Adapt(adapter_) {
		var env = adapter_.env, osPaths = adapter_.osPaths, path5 = adapter_.path;
		var isMacOS = /^darwin$/i.test(adapter_.process.platform);
		var isWinOS = /^win/i.test(adapter_.process.platform);
		function baseDir() {
			return osPaths.home() || osPaths.temp();
		}
		__name(baseDir, "baseDir");
		function valOrPath(val, pathSegments) {
			return val || path5.join.apply(path5, pathSegments);
		}
		__name(valOrPath, "valOrPath");
		var linux = /* @__PURE__ */ __name(function() {
			return {
				cache: /* @__PURE__ */ __name(function() {
					return valOrPath(env.get("XDG_CACHE_HOME"), [baseDir(), ".cache"]);
				}, "cache"),
				config: /* @__PURE__ */ __name(function() {
					return valOrPath(env.get("XDG_CONFIG_HOME"), [baseDir(), ".config"]);
				}, "config"),
				data: /* @__PURE__ */ __name(function() {
					return valOrPath(env.get("XDG_DATA_HOME"), [
						baseDir(),
						".local",
						"share"
					]);
				}, "data"),
				runtime: /* @__PURE__ */ __name(function() {
					return env.get("XDG_RUNTIME_DIR") || void 0;
				}, "runtime"),
				state: /* @__PURE__ */ __name(function() {
					return valOrPath(env.get("XDG_STATE_HOME"), [
						baseDir(),
						".local",
						"state"
					]);
				}, "state")
			};
		}, "linux");
		var macos = /* @__PURE__ */ __name(function() {
			return {
				cache: /* @__PURE__ */ __name(function() {
					return valOrPath(env.get("XDG_CACHE_HOME"), [
						baseDir(),
						"Library",
						"Caches"
					]);
				}, "cache"),
				config: /* @__PURE__ */ __name(function() {
					return valOrPath(env.get("XDG_CONFIG_HOME"), [
						baseDir(),
						"Library",
						"Preferences"
					]);
				}, "config"),
				data: /* @__PURE__ */ __name(function() {
					return valOrPath(env.get("XDG_DATA_HOME"), [
						baseDir(),
						"Library",
						"Application Support"
					]);
				}, "data"),
				runtime: /* @__PURE__ */ __name(function() {
					return env.get("XDG_RUNTIME_DIR") || void 0;
				}, "runtime"),
				state: /* @__PURE__ */ __name(function() {
					return valOrPath(env.get("XDG_STATE_HOME"), [
						baseDir(),
						"Library",
						"State"
					]);
				}, "state")
			};
		}, "macos");
		var windows = /* @__PURE__ */ __name(function() {
			function appData() {
				return valOrPath(env.get("APPDATA"), [
					baseDir(),
					"AppData",
					"Roaming"
				]);
			}
			__name(appData, "appData");
			function localAppData() {
				return valOrPath(env.get("LOCALAPPDATA"), [
					baseDir(),
					"AppData",
					"Local"
				]);
			}
			__name(localAppData, "localAppData");
			return {
				cache: /* @__PURE__ */ __name(function() {
					return valOrPath(env.get("XDG_CACHE_HOME"), [localAppData(), "xdg.cache"]);
				}, "cache"),
				config: /* @__PURE__ */ __name(function() {
					return valOrPath(env.get("XDG_CONFIG_HOME"), [appData(), "xdg.config"]);
				}, "config"),
				data: /* @__PURE__ */ __name(function() {
					return valOrPath(env.get("XDG_DATA_HOME"), [appData(), "xdg.data"]);
				}, "data"),
				runtime: /* @__PURE__ */ __name(function() {
					return env.get("XDG_RUNTIME_DIR") || void 0;
				}, "runtime"),
				state: /* @__PURE__ */ __name(function() {
					return valOrPath(env.get("XDG_STATE_HOME"), [localAppData(), "xdg.state"]);
				}, "state")
			};
		}, "windows");
		return { XDG: new (/* @__PURE__ */ function() {
			function XDG_2() {
				function XDG() {
					return new XDG_2();
				}
				__name(XDG, "XDG");
				var extension = isMacOS ? macos() : isWinOS ? windows() : linux();
				XDG.cache = extension.cache;
				XDG.config = extension.config;
				XDG.data = extension.data;
				XDG.runtime = extension.runtime;
				XDG.state = extension.state;
				XDG.configDirs = /* @__PURE__ */ __name(function configDirs() {
					var pathList = env.get("XDG_CONFIG_DIRS");
					return __spreadArray([extension.config()], pathList ? pathList.split(path5.delimiter) : []);
				}, "configDirs");
				XDG.dataDirs = /* @__PURE__ */ __name(function dataDirs() {
					var pathList = env.get("XDG_DATA_DIRS");
					return __spreadArray([extension.data()], pathList ? pathList.split(path5.delimiter) : []);
				}, "dataDirs");
				return XDG;
			}
			__name(XDG_2, "XDG_");
			return XDG_2;
		}())() };
	}
	__name(Adapt, "Adapt");
	exports$1.Adapt = Adapt;
} });
var require_OSPaths = __commonJS({ "../../node_modules/.pnpm/os-paths@7.4.0/node_modules/os-paths/dist/cjs/lib/OSPaths.js"(exports$1) {
	var __spreadArray = exports$1 && exports$1.__spreadArray || function(to, from) {
		for (var i$1 = 0, il = from.length, j = to.length; i$1 < il; i$1++, j++) to[j] = from[i$1];
		return to;
	};
	exports$1.__esModule = true;
	exports$1.Adapt = void 0;
	function isEmpty(s) {
		return !s;
	}
	__name(isEmpty, "isEmpty");
	function Adapt(adapter_) {
		var env = adapter_.env, os2 = adapter_.os, path5 = adapter_.path;
		var isWinOS = /^win/i.test(adapter_.process.platform);
		function normalizePath(path_) {
			return path_ ? adapter_.path.normalize(adapter_.path.join(path_, ".")) : void 0;
		}
		__name(normalizePath, "normalizePath");
		function home() {
			return isWinOS ? (/* @__PURE__ */ __name(function() {
				return normalizePath([
					typeof os2.homedir === "function" ? os2.homedir() : void 0,
					env.get("USERPROFILE"),
					env.get("HOME"),
					env.get("HOMEDRIVE") || env.get("HOMEPATH") ? path5.join(env.get("HOMEDRIVE") || "", env.get("HOMEPATH") || "") : void 0
				].find(function(v) {
					return !isEmpty(v);
				}));
			}, "windows"))() : (/* @__PURE__ */ __name(function() {
				return normalizePath((typeof os2.homedir === "function" ? os2.homedir() : void 0) || env.get("HOME"));
			}, "posix"))();
		}
		__name(home, "home");
		function temp() {
			function joinPathToBase(base, segments) {
				return base ? path5.join.apply(path5, __spreadArray([base], segments)) : void 0;
			}
			__name(joinPathToBase, "joinPathToBase");
			function posix() {
				return normalizePath([
					typeof os2.tmpdir === "function" ? os2.tmpdir() : void 0,
					env.get("TMPDIR"),
					env.get("TEMP"),
					env.get("TMP")
				].find(function(v) {
					return !isEmpty(v);
				})) || "/tmp";
			}
			__name(posix, "posix");
			function windows() {
				var fallback = "C:\\Temp";
				var v = [
					typeof os2.tmpdir === "function" ? os2.tmpdir : function() {},
					function() {
						return env.get("TEMP");
					},
					function() {
						return env.get("TMP");
					},
					function() {
						return joinPathToBase(env.get("LOCALAPPDATA"), ["Temp"]);
					},
					function() {
						return joinPathToBase(home(), [
							"AppData",
							"Local",
							"Temp"
						]);
					},
					function() {
						return joinPathToBase(env.get("ALLUSERSPROFILE"), ["Temp"]);
					},
					function() {
						return joinPathToBase(env.get("SystemRoot"), ["Temp"]);
					},
					function() {
						return joinPathToBase(env.get("windir"), ["Temp"]);
					},
					function() {
						return joinPathToBase(env.get("SystemDrive"), ["\\", "Temp"]);
					}
				].find(function(v2) {
					return v2 && !isEmpty(v2());
				});
				return v && normalizePath(v()) || fallback;
			}
			__name(windows, "windows");
			return isWinOS ? windows() : posix();
		}
		__name(temp, "temp");
		return { OSPaths: new (/* @__PURE__ */ function() {
			function OSPaths_2() {
				function OSPaths() {
					return new OSPaths_2();
				}
				__name(OSPaths, "OSPaths");
				OSPaths.home = home;
				OSPaths.temp = temp;
				return OSPaths;
			}
			__name(OSPaths_2, "OSPaths_");
			return OSPaths_2;
		}())() };
	}
	__name(Adapt, "Adapt");
	exports$1.Adapt = Adapt;
} });
var require_node = __commonJS({ "../../node_modules/.pnpm/os-paths@7.4.0/node_modules/os-paths/dist/cjs/platform-adapters/node.js"(exports$1) {
	var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o, k2, {
			enumerable: true,
			get: /* @__PURE__ */ __name(function() {
				return m[k];
			}, "get")
		});
	} : function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	});
	var __setModuleDefault = exports$1 && exports$1.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports$1 && exports$1.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	exports$1.__esModule = true;
	exports$1.adapter = void 0;
	var os2 = __importStar(__require("os"));
	var path5 = __importStar(__require("path"));
	exports$1.adapter = {
		atImportPermissions: { env: true },
		env: { get: /* @__PURE__ */ __name(function(s) {
			return process.env[s];
		}, "get") },
		os: os2,
		path: path5,
		process
	};
} });
var require_mod_cjs = __commonJS({ "../../node_modules/.pnpm/os-paths@7.4.0/node_modules/os-paths/dist/cjs/mod.cjs.js"(exports$1, module$2) {
	var OSPaths_js_1 = require_OSPaths();
	var node_js_1 = require_node();
	module$2.exports = OSPaths_js_1.Adapt(node_js_1.adapter).OSPaths;
} });
var require_node2 = __commonJS({ "../../node_modules/.pnpm/xdg-portable@10.6.0/node_modules/xdg-portable/dist/cjs/platform-adapters/node.js"(exports$1) {
	var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o, k2, {
			enumerable: true,
			get: /* @__PURE__ */ __name(function() {
				return m[k];
			}, "get")
		});
	} : function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	});
	var __setModuleDefault = exports$1 && exports$1.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports$1 && exports$1.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __importDefault = exports$1 && exports$1.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	exports$1.__esModule = true;
	exports$1.adapter = void 0;
	var path5 = __importStar(__require("path"));
	var os_paths_1 = __importDefault(require_mod_cjs());
	exports$1.adapter = {
		atImportPermissions: { env: true },
		env: { get: /* @__PURE__ */ __name(function(s) {
			return process.env[s];
		}, "get") },
		osPaths: os_paths_1["default"],
		path: path5,
		process
	};
} });
var require_mod_cjs2 = __commonJS({ "../../node_modules/.pnpm/xdg-portable@10.6.0/node_modules/xdg-portable/dist/cjs/mod.cjs.js"(exports$1, module$2) {
	var XDG_js_1 = require_XDG();
	var node_js_1 = require_node2();
	module$2.exports = XDG_js_1.Adapt(node_js_1.adapter).XDG;
} });
var require_node3 = __commonJS({ "../../node_modules/.pnpm/xdg-app-paths@8.3.0/node_modules/xdg-app-paths/dist/cjs/platform-adapters/node.js"(exports$1) {
	var __createBinding = exports$1 && exports$1.__createBinding || (Object.create ? function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o, k2, {
			enumerable: true,
			get: /* @__PURE__ */ __name(function() {
				return m[k];
			}, "get")
		});
	} : function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	});
	var __setModuleDefault = exports$1 && exports$1.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports$1 && exports$1.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __importDefault = exports$1 && exports$1.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	exports$1.__esModule = true;
	exports$1.adapter = void 0;
	var path5 = __importStar(__require("path"));
	var xdg_portable_1 = __importDefault(require_mod_cjs2());
	exports$1.adapter = {
		atImportPermissions: {
			env: true,
			read: true
		},
		meta: {
			mainFilename: /* @__PURE__ */ __name(function() {
				var requireMainFilename = (typeof __require !== "undefined" && __require !== null && __require.main ? __require.main : { filename: void 0 }).filename;
				return (requireMainFilename !== process.execArgv[0] ? requireMainFilename : void 0) || (typeof process._eval === "undefined" ? process.argv[1] : void 0);
			}, "mainFilename"),
			pkgMainFilename: /* @__PURE__ */ __name(function() {
				return process.pkg ? process.execPath : void 0;
			}, "pkgMainFilename")
		},
		path: path5,
		process,
		xdg: xdg_portable_1["default"]
	};
} });
var require_mod_cjs3 = __commonJS({ "../../node_modules/.pnpm/xdg-app-paths@8.3.0/node_modules/xdg-app-paths/dist/cjs/mod.cjs.js"(exports$1, module$2) {
	var XDGAppPaths_js_1 = require_XDGAppPaths();
	var node_js_1 = require_node3();
	module$2.exports = XDGAppPaths_js_1.Adapt(node_js_1.adapter).XDGAppPaths;
} });
var defaultWranglerConfig = {
	configPath: void 0,
	userConfigPath: void 0,
	topLevelName: void 0,
	definedEnvironments: void 0,
	targetEnvironment: void 0,
	pages_build_output_dir: void 0,
	send_metrics: void 0,
	dev: {
		ip: process.platform === "win32" ? "127.0.0.1" : "localhost",
		port: void 0,
		inspector_port: void 0,
		local_protocol: "http",
		upstream_protocol: "http",
		host: void 0,
		enable_containers: true,
		container_engine: void 0,
		generate_types: false
	},
	name: void 0,
	compatibility_date: void 0,
	compatibility_flags: [],
	limits: void 0,
	placement: void 0,
	vars: {},
	durable_objects: { bindings: [] },
	kv_namespaces: [],
	queues: {
		producers: [],
		consumers: []
	},
	r2_buckets: [],
	d1_databases: [],
	vectorize: [],
	hyperdrive: [],
	workflows: [],
	secrets_store_secrets: [],
	services: [],
	analytics_engine_datasets: [],
	ai: void 0,
	images: void 0,
	media: void 0,
	version_metadata: void 0,
	unsafe_hello_world: [],
	ratelimits: [],
	worker_loaders: [],
	legacy_env: true,
	site: void 0,
	wasm_modules: void 0,
	text_blobs: void 0,
	data_blobs: void 0,
	keep_vars: void 0,
	alias: void 0,
	account_id: void 0,
	main: void 0,
	find_additional_modules: void 0,
	preserve_file_names: void 0,
	base_dir: void 0,
	workers_dev: void 0,
	preview_urls: void 0,
	route: void 0,
	routes: void 0,
	tsconfig: void 0,
	jsx_factory: "React.createElement",
	jsx_fragment: "React.Fragment",
	migrations: [],
	triggers: { crons: void 0 },
	rules: [],
	build: {
		command: void 0,
		watch_dir: "./src",
		cwd: void 0
	},
	no_bundle: void 0,
	minify: void 0,
	keep_names: void 0,
	dispatch_namespaces: [],
	first_party_worker: void 0,
	logfwdr: { bindings: [] },
	logpush: void 0,
	upload_source_maps: void 0,
	assets: void 0,
	observability: { enabled: true },
	compliance_region: void 0,
	python_modules: { exclude: ["**/*.pyc"] },
	define: {},
	cloudchamber: {},
	containers: void 0,
	send_email: [],
	browser: void 0,
	unsafe: {},
	mtls_certificates: [],
	tail_consumers: void 0,
	streaming_tail_consumers: void 0,
	pipelines: [],
	vpc_services: []
};
var PatchConfigError = class extends Error {
	static {
		__name(this, "PatchConfigError");
	}
};
var ApplicationRollout$1;
((ApplicationRollout2) => {
	((kind2) => {
		kind2["FULL_AUTO"] = "full_auto";
		kind2["FULL_MANUAL"] = "full_manual";
		kind2["DURABLE_OBJECTS_AUTO"] = "durable_objects_auto";
	})(ApplicationRollout2.kind || (ApplicationRollout2.kind = {}));
	((strategy2) => {
		strategy2["ROLLING"] = "rolling";
	})(ApplicationRollout2.strategy || (ApplicationRollout2.strategy = {}));
	((status2) => {
		status2["PENDING"] = "pending";
		status2["PROGRESSING"] = "progressing";
		status2["COMPLETED"] = "completed";
		status2["REVERTED"] = "reverted";
		status2["REPLACED"] = "replaced";
	})(ApplicationRollout2.status || (ApplicationRollout2.status = {}));
})(ApplicationRollout$1 || (ApplicationRollout$1 = {}));
var BadRequestWithCodeError$1;
((BadRequestWithCodeError2) => {
	((error2) => {
		error2["VALIDATE_INPUT"] = "VALIDATE_INPUT";
	})(BadRequestWithCodeError2.error || (BadRequestWithCodeError2.error = {}));
})(BadRequestWithCodeError$1 || (BadRequestWithCodeError$1 = {}));
var CreateApplicationRolloutRequest$1;
((CreateApplicationRolloutRequest2) => {
	((strategy2) => {
		strategy2["ROLLING"] = "rolling";
	})(CreateApplicationRolloutRequest2.strategy || (CreateApplicationRolloutRequest2.strategy = {}));
	((step_percentage2) => {
		step_percentage2[step_percentage2["_5"] = 5] = "_5";
		step_percentage2[step_percentage2["_10"] = 10] = "_10";
		step_percentage2[step_percentage2["_20"] = 20] = "_20";
		step_percentage2[step_percentage2["_25"] = 25] = "_25";
		step_percentage2[step_percentage2["_50"] = 50] = "_50";
		step_percentage2[step_percentage2["_100"] = 100] = "_100";
	})(CreateApplicationRolloutRequest2.step_percentage || (CreateApplicationRolloutRequest2.step_percentage = {}));
	((kind2) => {
		kind2["FULL_AUTO"] = "full_auto";
		kind2["FULL_MANUAL"] = "full_manual";
	})(CreateApplicationRolloutRequest2.kind || (CreateApplicationRolloutRequest2.kind = {}));
})(CreateApplicationRolloutRequest$1 || (CreateApplicationRolloutRequest$1 = {}));
var DeploymentNotFoundError$1;
((DeploymentNotFoundError2) => {
	((error2) => {
		error2["DEPLOYMENT_NOT_FOUND"] = "DEPLOYMENT_NOT_FOUND";
	})(DeploymentNotFoundError2.error || (DeploymentNotFoundError2.error = {}));
})(DeploymentNotFoundError$1 || (DeploymentNotFoundError$1 = {}));
var ImageRegistryAlreadyExistsError$1;
((ImageRegistryAlreadyExistsError2) => {
	((error2) => {
		error2["IMAGE_REGISTRY_ALREADY_EXISTS"] = "IMAGE_REGISTRY_ALREADY_EXISTS";
	})(ImageRegistryAlreadyExistsError2.error || (ImageRegistryAlreadyExistsError2.error = {}));
})(ImageRegistryAlreadyExistsError$1 || (ImageRegistryAlreadyExistsError$1 = {}));
var ImageRegistryIsPublic$1;
((ImageRegistryIsPublic2) => {
	((error2) => {
		error2["IMAGE_REGISTRY_IS_PUBLIC"] = "IMAGE_REGISTRY_IS_PUBLIC";
	})(ImageRegistryIsPublic2.error || (ImageRegistryIsPublic2.error = {}));
})(ImageRegistryIsPublic$1 || (ImageRegistryIsPublic$1 = {}));
var ImageRegistryNotAllowedError$1;
((ImageRegistryNotAllowedError2) => {
	((error2) => {
		error2["IMAGE_REGISTRY_NOT_ALLOWED"] = "IMAGE_REGISTRY_NOT_ALLOWED";
	})(ImageRegistryNotAllowedError2.error || (ImageRegistryNotAllowedError2.error = {}));
})(ImageRegistryNotAllowedError$1 || (ImageRegistryNotAllowedError$1 = {}));
var ImageRegistryNotFoundError$1;
((ImageRegistryNotFoundError2) => {
	((error2) => {
		error2["IMAGE_REGISTRY_NOT_FOUND"] = "IMAGE_REGISTRY_NOT_FOUND";
	})(ImageRegistryNotFoundError2.error || (ImageRegistryNotFoundError2.error = {}));
})(ImageRegistryNotFoundError$1 || (ImageRegistryNotFoundError$1 = {}));
var ImageRegistryProtocolAlreadyExists$1;
((ImageRegistryProtocolAlreadyExists2) => {
	((error2) => {
		error2["IMAGE_REGISTRY_PROTOCOL_ALREADY_EXISTS"] = "IMAGE_REGISTRY_PROTOCOL_ALREADY_EXISTS";
	})(ImageRegistryProtocolAlreadyExists2.error || (ImageRegistryProtocolAlreadyExists2.error = {}));
})(ImageRegistryProtocolAlreadyExists$1 || (ImageRegistryProtocolAlreadyExists$1 = {}));
var ImageRegistryProtocolIsReferencedError$1;
((ImageRegistryProtocolIsReferencedError2) => {
	((error2) => {
		error2["IMAGE_REGISTRY_PROTO_IS_REFERENCED"] = "IMAGE_REGISTRY_PROTO_IS_REFERENCED";
	})(ImageRegistryProtocolIsReferencedError2.error || (ImageRegistryProtocolIsReferencedError2.error = {}));
})(ImageRegistryProtocolIsReferencedError$1 || (ImageRegistryProtocolIsReferencedError$1 = {}));
var ImageRegistryProtocolNotFound$1;
((ImageRegistryProtocolNotFound2) => {
	((error2) => {
		error2["IMAGE_REGISTRY_PROTOCOL_NOT_FOUND"] = "IMAGE_REGISTRY_PROTOCOL_NOT_FOUND";
	})(ImageRegistryProtocolNotFound2.error || (ImageRegistryProtocolNotFound2.error = {}));
})(ImageRegistryProtocolNotFound$1 || (ImageRegistryProtocolNotFound$1 = {}));
var ProvisionerConfiguration$1;
((ProvisionerConfiguration2) => {
	((type2) => {
		type2["NONE"] = "none";
		type2["CLOUDINIT"] = "cloudinit";
	})(ProvisionerConfiguration2.type || (ProvisionerConfiguration2.type = {}));
})(ProvisionerConfiguration$1 || (ProvisionerConfiguration$1 = {}));
var RolloutStep$1;
((RolloutStep2) => {
	((status2) => {
		status2["PENDING"] = "pending";
		status2["PROGRESSING"] = "progressing";
		status2["REVERTING"] = "reverting";
		status2["COMPLETED"] = "completed";
		status2["REVERTED"] = "reverted";
	})(RolloutStep2.status || (RolloutStep2.status = {}));
})(RolloutStep$1 || (RolloutStep$1 = {}));
var SecretNameAlreadyExists$1;
((SecretNameAlreadyExists2) => {
	((error2) => {
		error2["SECRET_NAME_ALREADY_EXISTS"] = "SECRET_NAME_ALREADY_EXISTS";
	})(SecretNameAlreadyExists2.error || (SecretNameAlreadyExists2.error = {}));
})(SecretNameAlreadyExists$1 || (SecretNameAlreadyExists$1 = {}));
var SecretNotFound$1;
((SecretNotFound2) => {
	((error2) => {
		error2["SECRET_NAME_NOT_FOUND"] = "SECRET_NAME_NOT_FOUND";
	})(SecretNotFound2.error || (SecretNotFound2.error = {}));
})(SecretNotFound$1 || (SecretNotFound$1 = {}));
var SSHPublicKeyNotFoundError$1;
((SSHPublicKeyNotFoundError2) => {
	((error2) => {
		error2["SSH_PUBLIC_KEY_NOT_FOUND"] = "SSH_PUBLIC_KEY_NOT_FOUND";
	})(SSHPublicKeyNotFoundError2.error || (SSHPublicKeyNotFoundError2.error = {}));
})(SSHPublicKeyNotFoundError$1 || (SSHPublicKeyNotFoundError$1 = {}));
var UpdateApplicationRolloutRequest$1;
((UpdateApplicationRolloutRequest2) => {
	((action2) => {
		action2["NEXT"] = "next";
		action2["PREVIOUS"] = "previous";
		action2["REVERT"] = "revert";
	})(UpdateApplicationRolloutRequest2.action || (UpdateApplicationRolloutRequest2.action = {}));
})(UpdateApplicationRolloutRequest$1 || (UpdateApplicationRolloutRequest$1 = {}));
var UserError2 = class extends Error {
	static {
		__name(this, "UserError");
	}
	telemetryMessage;
	constructor(message, options) {
		super(message, options);
		Object.setPrototypeOf(this, new.target.prototype);
		this.telemetryMessage = options?.telemetryMessage === true ? message : options?.telemetryMessage;
	}
};
function isDir$1(inputPath) {
	return statSync(inputPath).isDirectory();
}
__name(isDir$1, "isDir");
var isDockerfile$1 = /* @__PURE__ */ __name((image, configPath) => {
	const baseDir = configPath ? path4.dirname(configPath) : process.cwd();
	const maybeDockerfile = path4.resolve(baseDir, image);
	if (existsSync(maybeDockerfile)) {
		if (isDir$1(maybeDockerfile)) throw new UserError2(`${image} is a directory, you should specify a path to the Dockerfile`);
		return true;
	}
	const errorPrefix = `The image "${image}" does not appear to be a valid path to a Dockerfile, or a valid image registry path:
`;
	try {
		new URL(`https://${image}`);
	} catch (e) {
		if (e instanceof Error) throw new UserError2(errorPrefix + e.message);
		throw e;
	}
	const imageParts = image.split("/");
	if (!imageParts[imageParts.length - 1]?.includes(":")) throw new UserError2(errorPrefix + `If this is an image registry path, it needs to include at least a tag ':' (e.g: docker.io/httpd:1)`);
	if (image.includes("://")) throw new UserError2(errorPrefix + `Image reference should not include the protocol part (e.g: docker.io/httpd:1, not https://docker.io/httpd:1)`);
	return false;
}, "isDockerfile");
var MAX_WORKFLOW_NAME_LENGTH = 64;
var ALLOWED_WORKFLOW_NAME_REGEX = new RegExp("^[a-zA-Z0-9_][a-zA-Z0-9-_]*$");
function isValidWorkflowName(name) {
	if (typeof name !== "string") return false;
	if (name.length > MAX_WORKFLOW_NAME_LENGTH) return false;
	return ALLOWED_WORKFLOW_NAME_REGEX.test(name);
}
__name(isValidWorkflowName, "isValidWorkflowName");
var mod_esm_exports = {};
__export(mod_esm_exports, { default: () => mod_esm_default });
var import_mod_cjs = __toESM(require_mod_cjs3(), 1);
__reExport(mod_esm_exports, __toESM(require_mod_cjs3(), 1));
var mod_esm_default = import_mod_cjs.default;
function isDirectory(configPath) {
	try {
		return fs.statSync(configPath).isDirectory();
	} catch {
		return false;
	}
}
__name(isDirectory, "isDirectory");
function getGlobalWranglerConfigPath() {
	const configDir = mod_esm_default(".wrangler").config();
	const legacyConfigDir = path4.join(os.homedir(), ".wrangler");
	if (isDirectory(legacyConfigDir)) return legacyConfigDir;
	else return configDir;
}
__name(getGlobalWranglerConfigPath, "getGlobalWranglerConfigPath");
function getBooleanEnvironmentVariableFactory(options) {
	return () => {
		if (!(options.variableName in process.env) || process.env[options.variableName] === void 0) return typeof options.defaultValue === "function" ? options.defaultValue() : options.defaultValue;
		switch (process.env[options.variableName]?.toLowerCase()) {
			case "true": return true;
			case "false": return false;
			default: throw new UserError$1(`Expected ${options.variableName} to be "true" or "false", but got ${JSON.stringify(process.env[options.variableName])}`);
		}
	};
}
__name(getBooleanEnvironmentVariableFactory, "getBooleanEnvironmentVariableFactory");
function getEnvironmentVariableFactory({ variableName, deprecatedName, choices, defaultValue }) {
	let hasWarned = false;
	return () => {
		if (variableName in process.env) return getProcessEnv(variableName, choices);
		if (deprecatedName && deprecatedName in process.env) {
			if (!hasWarned) {
				hasWarned = true;
				console.warn(`Using "${deprecatedName}" environment variable. This is deprecated. Please use "${variableName}", instead.`);
			}
			return getProcessEnv(deprecatedName, choices);
		}
		return defaultValue?.();
	};
}
__name(getEnvironmentVariableFactory, "getEnvironmentVariableFactory");
function getProcessEnv(variableName, choices) {
	assertOneOf(choices, process.env[variableName]);
	return process.env[variableName];
}
__name(getProcessEnv, "getProcessEnv");
function assertOneOf(choices, value) {
	if (Array.isArray(choices) && !choices.includes(value)) throw new UserError$1(`Expected ${JSON.stringify(value)} to be one of ${JSON.stringify(choices)}`);
}
__name(assertOneOf, "assertOneOf");
var getC3CommandFromEnv = getEnvironmentVariableFactory({
	variableName: "WRANGLER_C3_COMMAND",
	defaultValue: /* @__PURE__ */ __name(() => "create cloudflare@^2.5.0", "defaultValue")
});
var getWranglerSendMetricsFromEnv = getBooleanEnvironmentVariableFactory({ variableName: "WRANGLER_SEND_METRICS" });
var getWranglerSendErrorReportsFromEnv = getBooleanEnvironmentVariableFactory({ variableName: "WRANGLER_SEND_ERROR_REPORTS" });
var getCloudflareApiEnvironmentFromEnv = getEnvironmentVariableFactory({
	variableName: "WRANGLER_API_ENVIRONMENT",
	defaultValue: /* @__PURE__ */ __name(() => "production", "defaultValue"),
	choices: ["production", "staging"]
});
var getCloudflareComplianceRegionFromEnv = getEnvironmentVariableFactory({
	variableName: "CLOUDFLARE_COMPLIANCE_REGION",
	choices: ["public", "fedramp_high"]
});
var getCloudflareComplianceRegion = /* @__PURE__ */ __name((complianceConfig) => {
	const complianceRegionFromEnv = getCloudflareComplianceRegionFromEnv();
	if (complianceRegionFromEnv !== void 0 && complianceConfig?.compliance_region !== void 0 && complianceRegionFromEnv !== complianceConfig.compliance_region) throw new UserError$1(dedent`
			The compliance region has been set to different values in two places:
			 - \`CLOUDFLARE_COMPLIANCE_REGION\` environment variable: \`${complianceRegionFromEnv}\`
			 - \`compliance_region\` configuration property: \`${complianceConfig.compliance_region}\`
			`);
	return complianceRegionFromEnv || complianceConfig?.compliance_region || "public";
}, "getCloudflareComplianceRegion");
var getCloudflareApiBaseUrlFromEnv = getEnvironmentVariableFactory({
	variableName: "CLOUDFLARE_API_BASE_URL",
	deprecatedName: "CF_API_BASE_URL"
});
function getComplianceRegionSubdomain(complianceConfig) {
	return getCloudflareComplianceRegion(complianceConfig) === "fedramp_high" ? ".fed" : "";
}
__name(getComplianceRegionSubdomain, "getComplianceRegionSubdomain");
function getStagingSubdomain() {
	return getCloudflareApiEnvironmentFromEnv() === "staging" ? ".staging" : "";
}
__name(getStagingSubdomain, "getStagingSubdomain");
var getSanitizeLogs = getBooleanEnvironmentVariableFactory({
	variableName: "WRANGLER_LOG_SANITIZE",
	defaultValue: true
});
var getOutputFileDirectoryFromEnv = getEnvironmentVariableFactory({ variableName: "WRANGLER_OUTPUT_FILE_DIRECTORY" });
var getOutputFilePathFromEnv = getEnvironmentVariableFactory({ variableName: "WRANGLER_OUTPUT_FILE_PATH" });
var getCIMatchTag = getEnvironmentVariableFactory({ variableName: "WRANGLER_CI_MATCH_TAG" });
var getCIOverrideName = getEnvironmentVariableFactory({ variableName: "WRANGLER_CI_OVERRIDE_NAME" });
var getCIOverrideNetworkModeHost = getEnvironmentVariableFactory({ variableName: "WRANGLER_CI_OVERRIDE_NETWORK_MODE_HOST" });
var getCIGeneratePreviewAlias = getEnvironmentVariableFactory({
	variableName: "WRANGLER_CI_GENERATE_PREVIEW_ALIAS",
	defaultValue: /* @__PURE__ */ __name(() => "false", "defaultValue"),
	choices: ["true", "false"]
});
var getWorkersCIBranchName = getEnvironmentVariableFactory({ variableName: "WORKERS_CI_BRANCH" });
var getBuildConditionsFromEnv = getEnvironmentVariableFactory({ variableName: "WRANGLER_BUILD_CONDITIONS" });
var getBuildPlatformFromEnv = getEnvironmentVariableFactory({ variableName: "WRANGLER_BUILD_PLATFORM" });
var getRegistryPath = getEnvironmentVariableFactory({
	variableName: "WRANGLER_REGISTRY_PATH",
	defaultValue() {
		return path4.join(getGlobalWranglerConfigPath(), "registry");
	}
});
var getD1ExtraLocationChoices = getEnvironmentVariableFactory({ variableName: "WRANGLER_D1_EXTRA_LOCATION_CHOICES" });
var getDockerPath$1 = getEnvironmentVariableFactory({
	variableName: "WRANGLER_DOCKER_BIN",
	defaultValue() {
		return "docker";
	}
});
var getSubdomainMixedStateCheckDisabled = getBooleanEnvironmentVariableFactory({
	variableName: "WRANGLER_DISABLE_SUBDOMAIN_MIXED_STATE_CHECK",
	defaultValue: false
});
var getCloudflareLoadDevVarsFromDotEnv = getBooleanEnvironmentVariableFactory({
	variableName: "CLOUDFLARE_LOAD_DEV_VARS_FROM_DOT_ENV",
	defaultValue: true
});
var getCloudflareIncludeProcessEnvFromEnv = getBooleanEnvironmentVariableFactory({
	variableName: "CLOUDFLARE_INCLUDE_PROCESS_ENV",
	defaultValue: false
});
var getTraceHeader = getEnvironmentVariableFactory({ variableName: "WRANGLER_TRACE_ID" });
var getDisableConfigWatching = getBooleanEnvironmentVariableFactory({
	variableName: "WRANGLER_CI_DISABLE_CONFIG_WATCHING",
	defaultValue: false
});
var getWranglerHideBanner = getBooleanEnvironmentVariableFactory({
	variableName: "WRANGLER_HIDE_BANNER",
	defaultValue: false
});
var getCloudflareEnv = getEnvironmentVariableFactory({ variableName: "CLOUDFLARE_ENV" });
var getOpenNextDeployFromEnv = getEnvironmentVariableFactory({ variableName: "OPEN_NEXT_DEPLOY" });
var Diagnostics = class {
	/**
	* Create a new Diagnostics object.
	* @param description A general description of this collection of messages.
	*/
	constructor(description) {
		this.description = description;
	}
	static {
		__name(this, "Diagnostics");
	}
	errors = [];
	warnings = [];
	children = [];
	/**
	* Merge the given `diagnostics` into this as a child.
	*/
	addChild(diagnostics) {
		if (diagnostics.hasErrors() || diagnostics.hasWarnings()) this.children.push(diagnostics);
	}
	/** Does this or any of its children have errors. */
	hasErrors() {
		if (this.errors.length > 0) return true;
		else return this.children.some((child) => child.hasErrors());
	}
	/** Render the errors of this and all its children. */
	renderErrors() {
		return this.render("errors");
	}
	/** Does this or any of its children have warnings. */
	hasWarnings() {
		if (this.warnings.length > 0) return true;
		else return this.children.some((child) => child.hasWarnings());
	}
	/** Render the warnings of this and all its children. */
	renderWarnings() {
		return this.render("warnings");
	}
	render(field) {
		const hasMethod = field === "errors" ? "hasErrors" : "hasWarnings";
		return indentText(`${this.description}
` + this[field].map((message) => `- ${indentText(message)}`).join("\n") + this.children.map((child) => child[hasMethod]() ? "\n- " + child.render(field) : "").filter((output) => output !== "").join("\n"));
	}
};
function indentText(str) {
	return str.split("\n").map((line, index) => (index === 0 ? line : `  ${line}`).replace(/^\s*$/, "")).join("\n");
}
__name(indentText, "indentText");
function deprecated(diagnostics, config, fieldPath, message, remove, title = "Deprecation", type = "warning") {
	const diagnosticMessage = `[1m${title}[0m: "${fieldPath}":
${message}`;
	const result = unwindPropertyPath(config, fieldPath);
	if (result !== void 0 && result.field in result.container) {
		diagnostics[`${type}s`].push(diagnosticMessage);
		if (remove) delete result.container[result.field];
	}
}
__name(deprecated, "deprecated");
function experimental(diagnostics, config, fieldPath) {
	const result = unwindPropertyPath(config, fieldPath);
	if (result !== void 0 && result.field in result.container && !("WRANGLER_DISABLE_EXPERIMENTAL_WARNING" in process.env)) diagnostics.warnings.push(`"${fieldPath}" fields are experimental and may change or break at any time.`);
}
__name(experimental, "experimental");
function inheritable(diagnostics, topLevelEnv, rawEnv, field, validate, defaultValue, transformFn = (v) => v) {
	validate(diagnostics, field, rawEnv[field], topLevelEnv);
	return (rawEnv !== topLevelEnv ? rawEnv[field] : void 0) ?? transformFn(topLevelEnv?.[field]) ?? defaultValue;
}
__name(inheritable, "inheritable");
function inheritableInWranglerEnvironments(diagnostics, useServiceEnvironments, topLevelEnv, rawEnv, field, validate, transformFn = (v) => v, defaultValue) {
	return useServiceEnvironments && topLevelEnv !== void 0 ? notAllowedInNamedServiceEnvironment(diagnostics, topLevelEnv, rawEnv, field) : inheritable(diagnostics, topLevelEnv, rawEnv, field, validate, defaultValue, transformFn);
}
__name(inheritableInWranglerEnvironments, "inheritableInWranglerEnvironments");
var appendEnvName = /* @__PURE__ */ __name((envName) => (fieldValue) => fieldValue ? `${fieldValue}-${envName}` : void 0, "appendEnvName");
function notAllowedInNamedServiceEnvironment(diagnostics, topLevelEnv, rawEnv, field) {
	if (field in rawEnv) diagnostics.errors.push(`The "${field}" field is not allowed in named service environments.
Please remove the field from this environment.`);
	return topLevelEnv[field];
}
__name(notAllowedInNamedServiceEnvironment, "notAllowedInNamedServiceEnvironment");
function notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, field, validate, defaultValue) {
	if (rawEnv[field] !== void 0) validate(diagnostics, field, rawEnv[field], topLevelEnv);
	else if (rawConfig?.[field] !== void 0) diagnostics.warnings.push(`"${field}" exists at the top level, but not on "env.${envName}".
This is not what you probably want, since "${field}" is not inherited by environments.
Please add "${field}" to "env.${envName}".`);
	return rawEnv[field] ?? defaultValue;
}
__name(notInheritable, "notInheritable");
function unwindPropertyPath(root, path5) {
	let container = root;
	const parts = path5.split(".");
	for (let i$1 = 0; i$1 < parts.length - 1; i$1++) {
		if (!hasProperty(container, parts[i$1])) return;
		container = container[parts[i$1]];
	}
	return {
		container,
		field: parts[parts.length - 1]
	};
}
__name(unwindPropertyPath, "unwindPropertyPath");
var isString$2 = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (value !== void 0 && typeof value !== "string") {
		diagnostics.errors.push(`Expected "${field}" to be of type string but got ${JSON.stringify(value)}.`);
		return false;
	}
	return true;
}, "isString");
var isValidName = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value === "string" && /^$|^[a-z0-9_][a-z0-9-_]*$/.test(value) || value === void 0) return true;
	else {
		diagnostics.errors.push(`Expected "${field}" to be of type string, alphanumeric and lowercase with dashes only but got ${JSON.stringify(value)}.`);
		return false;
	}
}, "isValidName");
var isValidDateTimeStringFormat = /* @__PURE__ */ __name((diagnostics, field, value) => {
	let isValid$1 = true;
	if (value.includes("") || value.includes("")) {
		diagnostics.errors.push(`"${field}" field should use ISO-8601 accepted hyphens (-) rather than en-dashes (\u2013) or em-dashes (\u2014).`);
		isValid$1 = false;
	}
	const data$1 = new Date(value.replaceAll(/|/g, "-"));
	if (isNaN(data$1.getTime())) {
		diagnostics.errors.push(`"${field}" field should be a valid ISO-8601 date (YYYY-MM-DD), but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	return isValid$1;
}, "isValidDateTimeStringFormat");
var isStringArray = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (value !== void 0 && (!Array.isArray(value) || value.some((item) => typeof item !== "string"))) {
		diagnostics.errors.push(`Expected "${field}" to be of type string array but got ${JSON.stringify(value)}.`);
		return false;
	}
	return true;
}, "isStringArray");
var isOneOf = /* @__PURE__ */ __name((...choices) => (diagnostics, field, value) => {
	if (value !== void 0 && !choices.some((choice) => value === choice)) {
		diagnostics.errors.push(`Expected "${field}" field to be one of ${JSON.stringify(choices)} but got ${JSON.stringify(value)}.`);
		return false;
	}
	return true;
}, "isOneOf");
var all = /* @__PURE__ */ __name((...validations) => {
	return (diagnostics, field, value, config) => {
		let passedValidations = true;
		for (const validate of validations) if (!validate(diagnostics, field, value, config)) passedValidations = false;
		return passedValidations;
	};
}, "all");
var isMutuallyExclusiveWith = /* @__PURE__ */ __name((container, ...fields) => {
	return (diagnostics, field, value) => {
		if (value === void 0) return true;
		for (const exclusiveWith of fields) if (container[exclusiveWith] !== void 0) {
			diagnostics.errors.push(`Expected exactly one of the following fields ${JSON.stringify([field, ...fields])}.`);
			return false;
		}
		return true;
	};
}, "isMutuallyExclusiveWith");
var isBoolean = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (value !== void 0 && typeof value !== "boolean") {
		diagnostics.errors.push(`Expected "${field}" to be of type boolean but got ${JSON.stringify(value)}.`);
		return false;
	}
	return true;
}, "isBoolean");
var validateRequiredProperty = /* @__PURE__ */ __name((diagnostics, container, key, value, type, choices) => {
	if (container) container += ".";
	if (value === void 0) {
		diagnostics.errors.push(`"${container}${key}" is a required field.`);
		return false;
	} else if (typeof value !== type) {
		diagnostics.errors.push(`Expected "${container}${key}" to be of type ${type} but got ${JSON.stringify(value)}.`);
		return false;
	} else if (choices) {
		if (!isOneOf(...choices)(diagnostics, `${container}${key}`, value, void 0)) return false;
	}
	return true;
}, "validateRequiredProperty");
var validateAtLeastOnePropertyRequired = /* @__PURE__ */ __name((diagnostics, container, properties) => {
	const containerPath = container ? `${container}.` : "";
	if (properties.every((property) => property.value === void 0)) {
		diagnostics.errors.push(`${properties.map(({ key }) => `"${containerPath}${key}"`).join(" or ")} is required.`);
		return false;
	}
	const errors = [];
	for (const prop of properties) {
		if (typeof prop.value === prop.type) return true;
		errors.push(`Expected "${containerPath}${prop.key}" to be of type ${prop.type} but got ${JSON.stringify(prop.value)}.`);
	}
	diagnostics.errors.push(...errors);
	return false;
}, "validateAtLeastOnePropertyRequired");
var validateOptionalProperty = /* @__PURE__ */ __name((diagnostics, container, key, value, type, choices) => {
	if (value !== void 0) return validateRequiredProperty(diagnostics, container, key, value, type, choices);
	return true;
}, "validateOptionalProperty");
var validateTypedArray = /* @__PURE__ */ __name((diagnostics, container, value, type) => {
	let isValid$1 = true;
	if (!Array.isArray(value)) {
		diagnostics.errors.push(`Expected "${container}" to be an array of ${type}s but got ${JSON.stringify(value)}`);
		isValid$1 = false;
	} else for (let i$1 = 0; i$1 < value.length; i$1++) isValid$1 = validateRequiredProperty(diagnostics, container, `[${i$1}]`, value[i$1], type) && isValid$1;
	return isValid$1;
}, "validateTypedArray");
var validateOptionalTypedArray = /* @__PURE__ */ __name((diagnostics, container, value, type) => {
	if (value !== void 0) return validateTypedArray(diagnostics, container, value, type);
	return true;
}, "validateOptionalTypedArray");
var isRequiredProperty = /* @__PURE__ */ __name((target$1, property, type, choices) => hasProperty(target$1, property) && typeof target$1[property] === type && (choices === void 0 || choices.includes(target$1[property])), "isRequiredProperty");
var isOptionalProperty = /* @__PURE__ */ __name((target$1, property, type) => !hasProperty(target$1, property) || typeof target$1[property] === type, "isOptionalProperty");
var hasProperty = /* @__PURE__ */ __name((target$1, property) => property in target$1, "hasProperty");
var validateAdditionalProperties = /* @__PURE__ */ __name((diagnostics, fieldPath, restProps, knownProps) => {
	const restPropSet = new Set(restProps);
	for (const knownProp of knownProps) restPropSet.delete(knownProp);
	if (restPropSet.size > 0) {
		const fields = Array.from(restPropSet.keys()).map((field) => `"${field}"`);
		diagnostics.warnings.push(`Unexpected fields found in ${fieldPath} field: ${fields}`);
		return false;
	}
	return true;
}, "validateAdditionalProperties");
var getBindingNames = /* @__PURE__ */ __name((value) => {
	if (typeof value !== "object" || value === null) return [];
	if (isBindingList(value)) return value.bindings.map(({ name }) => name);
	else if (isNamespaceList(value)) return value.map(({ binding }) => binding);
	else if (isRecord(value)) {
		if (value["binding"] !== void 0) return [value["binding"]];
		return Object.keys(value).filter((k) => value[k] !== void 0);
	} else return [];
}, "getBindingNames");
var isBindingList = /* @__PURE__ */ __name((value) => isRecord(value) && "bindings" in value && Array.isArray(value.bindings) && value.bindings.every((binding) => isRecord(binding) && "name" in binding && typeof binding.name === "string"), "isBindingList");
var isNamespaceList = /* @__PURE__ */ __name((value) => Array.isArray(value) && value.every((entry) => isRecord(entry) && "binding" in entry && typeof entry.binding === "string"), "isNamespaceList");
var isRecord = /* @__PURE__ */ __name((value) => typeof value === "object" && value !== null && !Array.isArray(value), "isRecord");
var validateUniqueNameProperty = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (Array.isArray(value)) {
		const nameCount = /* @__PURE__ */ new Map();
		Object.entries(value).forEach(([_2, entry]) => {
			nameCount.set(entry.name, (nameCount.get(entry.name) ?? 0) + 1);
		});
		const duplicates = Array.from(nameCount.entries()).filter(([_2, count]) => count > 1).map(([name]) => name);
		if (duplicates.length > 0) {
			const list$1 = duplicates.join("\", \"");
			diagnostics.errors.push(`"${field}" bindings must have unique "name" values; duplicate(s) found: "${list$1}"`);
			return false;
		}
	}
	return true;
}, "validateUniqueNameProperty");
function isValidR2BucketName(name) {
	return typeof name === "string" && /^[a-z0-9][a-z0-9-]{1,61}[a-z0-9]$/.test(name);
}
__name(isValidR2BucketName, "isValidR2BucketName");
var bucketFormatMessage = `Bucket names must begin and end with an alphanumeric character, only contain lowercase letters, numbers, and hyphens, and be between 3 and 63 characters long.`;
var friendlyBindingNames = {
	data_blobs: "Data Blob",
	durable_objects: "Durable Object",
	kv_namespaces: "KV Namespace",
	send_email: "Send Email",
	queues: "Queue",
	d1_databases: "D1 Database",
	vectorize: "Vectorize Index",
	hyperdrive: "Hyperdrive Config",
	r2_buckets: "R2 Bucket",
	logfwdr: "logfwdr",
	services: "Worker",
	analytics_engine_datasets: "Analytics Engine Dataset",
	text_blobs: "Text Blob",
	browser: "Browser",
	ai: "AI",
	images: "Images",
	media: "Media",
	version_metadata: "Worker Version Metadata",
	unsafe: "Unsafe Metadata",
	vars: "Environment Variable",
	wasm_modules: "Wasm Module",
	dispatch_namespaces: "Dispatch Namespace",
	mtls_certificates: "mTLS Certificate",
	workflows: "Workflow",
	pipelines: "Pipeline",
	secrets_store_secrets: "Secrets Store Secret",
	ratelimits: "Rate Limit",
	assets: "Assets",
	unsafe_hello_world: "Hello World",
	worker_loaders: "Worker Loader",
	vpc_services: "VPC Service"
};
var ENGLISH = new Intl.ListFormat("en-US");
var ALLOWED_INSTANCE_TYPES = [
	"lite",
	"basic",
	"standard-1",
	"standard-2",
	"standard-3",
	"standard-4",
	"dev",
	"standard"
];
function isPagesConfig(rawConfig) {
	return rawConfig.pages_build_output_dir !== void 0;
}
__name(isPagesConfig, "isPagesConfig");
function normalizeAndValidateConfig(rawConfig, configPath, userConfigPath, args, preserveOriginalMain = false) {
	const diagnostics = new Diagnostics(`Processing ${configPath ? path4.relative(process.cwd(), configPath) : "wrangler"} configuration:`);
	validateOptionalProperty(diagnostics, "", "legacy_env", rawConfig.legacy_env, "boolean");
	validateOptionalProperty(diagnostics, "", "send_metrics", rawConfig.send_metrics, "boolean");
	validateOptionalProperty(diagnostics, "", "keep_vars", rawConfig.keep_vars, "boolean");
	validateOptionalProperty(diagnostics, "", "pages_build_output_dir", rawConfig.pages_build_output_dir, "string");
	validateOptionalProperty(diagnostics, "", "$schema", rawConfig.$schema, "string");
	const useServiceEnvironments = !(args["legacy-env"] ?? rawConfig.legacy_env ?? true);
	if (useServiceEnvironments) diagnostics.warnings.push("Service environments are deprecated, and will be removed in the future. DO NOT USE IN PRODUCTION.");
	const isDispatchNamespace = typeof args["dispatch-namespace"] === "string" && args["dispatch-namespace"].trim() !== "";
	const topLevelEnv = normalizeAndValidateEnvironment(diagnostics, configPath, rawConfig, isDispatchNamespace, preserveOriginalMain);
	const isRedirectedConfig = isRedirectedRawConfig(rawConfig, configPath, userConfigPath);
	const definedEnvironments = Object.keys(rawConfig.env ?? {});
	if (isRedirectedConfig && definedEnvironments.length > 0) diagnostics.errors.push(dedent`
				Redirected configurations cannot include environments but the following have been found:\n${definedEnvironments.map((env) => `	- ${env}`).join("\n")}


				Such configurations are generated by tools, meaning that one of the tools
				your application is using is generating the incorrect configuration.
				Report this issue to the tool's author so that this can be fixed there.
				`);
	const envName = args.env ?? getCloudflareEnv();
	assert(envName === void 0 || typeof envName === "string");
	let activeEnv = topLevelEnv;
	if (envName) if (isRedirectedConfig) {
		if (!isPagesConfig(rawConfig) && rawConfig.targetEnvironment && rawConfig.targetEnvironment !== envName) {
			const via = args.env !== void 0 ? "via the `--env/-e` CLI argument" : "via the CLOUDFLARE_ENV environment variable";
			throw new Error(dedent`
					You have specified the environment "${envName}" ${via}.
					This does not match the target environment "${rawConfig.targetEnvironment}" that was used when building the application.
					Perhaps you need to re-run the custom build of the project with "${envName}" as the selected environment?
				`);
		}
	} else {
		const envDiagnostics = new Diagnostics(`"env.${envName}" environment configuration`);
		const rawEnv = rawConfig.env?.[envName];
		if (rawEnv !== void 0) {
			activeEnv = normalizeAndValidateEnvironment(envDiagnostics, configPath, rawEnv, isDispatchNamespace, preserveOriginalMain, envName, topLevelEnv, useServiceEnvironments, rawConfig);
			diagnostics.addChild(envDiagnostics);
		} else if (!isPagesConfig(rawConfig)) {
			activeEnv = normalizeAndValidateEnvironment(envDiagnostics, configPath, topLevelEnv, isDispatchNamespace, preserveOriginalMain, envName, topLevelEnv, useServiceEnvironments, rawConfig);
			const envNames = rawConfig.env ? `The available configured environment names are: ${JSON.stringify(Object.keys(rawConfig.env))}
` : "";
			const message = `No environment found in configuration with name "${envName}".
Before using \`--env=${envName}\` there should be an equivalent environment section in the configuration.
${envNames}
Consider adding an environment configuration section to the ${configFileName(configPath)} file:
\`\`\`
[env.` + envName + "]\n```\n";
			if (envNames.length > 0) diagnostics.errors.push(message);
			else diagnostics.warnings.push(message);
		}
	}
	const config = {
		configPath,
		userConfigPath,
		topLevelName: isRedirectedConfig ? rawConfig.topLevelName : rawConfig.name,
		definedEnvironments: isRedirectedConfig ? rawConfig.definedEnvironments : definedEnvironments,
		targetEnvironment: isRedirectedConfig ? rawConfig.targetEnvironment : envName,
		pages_build_output_dir: normalizeAndValidatePagesBuildOutputDir(configPath, rawConfig.pages_build_output_dir),
		legacy_env: !useServiceEnvironments,
		send_metrics: rawConfig.send_metrics,
		keep_vars: rawConfig.keep_vars,
		...activeEnv,
		dev: normalizeAndValidateDev(diagnostics, rawConfig.dev ?? {}, args),
		site: normalizeAndValidateSite(diagnostics, configPath, rawConfig, activeEnv.main),
		alias: normalizeAndValidateAliases(diagnostics, configPath, rawConfig),
		wasm_modules: normalizeAndValidateModulePaths(diagnostics, configPath, "wasm_modules", rawConfig.wasm_modules),
		text_blobs: normalizeAndValidateModulePaths(diagnostics, configPath, "text_blobs", rawConfig.text_blobs),
		data_blobs: normalizeAndValidateModulePaths(diagnostics, configPath, "data_blobs", rawConfig.data_blobs)
	};
	validateBindingsHaveUniqueNames(diagnostics, config);
	validateAdditionalProperties(diagnostics, "top-level", Object.keys(rawConfig), [
		...Object.keys(config),
		"env",
		"$schema"
	]);
	applyPythonConfig(config, args);
	return {
		config,
		diagnostics
	};
}
__name(normalizeAndValidateConfig, "normalizeAndValidateConfig");
function applyPythonConfig(config, args) {
	const mainModule = args.script ?? config.main;
	if (typeof mainModule === "string" && mainModule.endsWith(".py")) {
		config.no_bundle = true;
		if (!config.rules.some((rule) => rule.type === "PythonModule")) config.rules.push({
			type: "PythonModule",
			globs: ["**/*.py"]
		});
		if (!config.compatibility_flags.includes("python_workers")) throw new UserError$1("The `python_workers` compatibility flag is required to use Python.");
	}
}
__name(applyPythonConfig, "applyPythonConfig");
function normalizeAndValidateBuild(diagnostics, rawEnv, rawBuild, configPath) {
	const { command, cwd, watch_dir = "./src",...rest } = rawBuild;
	validateAdditionalProperties(diagnostics, "build", Object.keys(rest), []);
	validateOptionalProperty(diagnostics, "build", "command", command, "string");
	validateOptionalProperty(diagnostics, "build", "cwd", cwd, "string");
	if (Array.isArray(watch_dir)) validateTypedArray(diagnostics, "build.watch_dir", watch_dir, "string");
	else validateOptionalProperty(diagnostics, "build", "watch_dir", watch_dir, "string");
	return {
		command,
		watch_dir: command && configPath ? Array.isArray(watch_dir) ? watch_dir.map((dir) => path4.relative(process.cwd(), path4.join(path4.dirname(configPath), `${dir}`))) : path4.relative(process.cwd(), path4.join(path4.dirname(configPath), `${watch_dir}`)) : watch_dir,
		cwd
	};
}
__name(normalizeAndValidateBuild, "normalizeAndValidateBuild");
function normalizeAndValidateMainField(configPath, rawMain) {
	const configDir = path4.dirname(configPath ?? "wrangler.toml");
	if (rawMain !== void 0) if (typeof rawMain === "string") {
		const directory = path4.resolve(configDir);
		return path4.resolve(directory, rawMain);
	} else return rawMain;
	else return;
}
__name(normalizeAndValidateMainField, "normalizeAndValidateMainField");
function normalizeAndValidateBaseDirField(configPath, rawDir) {
	const configDir = path4.dirname(configPath ?? "wrangler.toml");
	if (rawDir !== void 0) if (typeof rawDir === "string") {
		const directory = path4.resolve(configDir);
		return path4.resolve(directory, rawDir);
	} else return rawDir;
	else return;
}
__name(normalizeAndValidateBaseDirField, "normalizeAndValidateBaseDirField");
function normalizeAndValidatePagesBuildOutputDir(configPath, rawPagesDir) {
	const configDir = path4.dirname(configPath ?? "wrangler.toml");
	if (rawPagesDir !== void 0) if (typeof rawPagesDir === "string") {
		const directory = path4.resolve(configDir);
		return path4.resolve(directory, rawPagesDir);
	} else return rawPagesDir;
	else return;
}
__name(normalizeAndValidatePagesBuildOutputDir, "normalizeAndValidatePagesBuildOutputDir");
function normalizeAndValidateDev(diagnostics, rawDev, args) {
	assert(typeof args === "object" && args !== null && !Array.isArray(args));
	const { localProtocol: localProtocolArg, upstreamProtocol: upstreamProtocolArg, remote: remoteArg, enableContainers: enableContainersArg, generateTypes: generateTypesArg } = args;
	assert(localProtocolArg === void 0 || localProtocolArg === "http" || localProtocolArg === "https");
	assert(upstreamProtocolArg === void 0 || upstreamProtocolArg === "http" || upstreamProtocolArg === "https");
	assert(remoteArg === void 0 || typeof remoteArg === "boolean");
	assert(enableContainersArg === void 0 || typeof enableContainersArg === "boolean");
	assert(generateTypesArg === void 0 || typeof generateTypesArg === "boolean");
	const { ip = process.platform === "win32" ? "127.0.0.1" : "localhost", port, inspector_port, local_protocol = localProtocolArg ?? "http", upstream_protocol = upstreamProtocolArg ?? remoteArg ? "https" : local_protocol, host, enable_containers = enableContainersArg ?? true, container_engine, generate_types = generateTypesArg ?? false,...rest } = rawDev;
	validateAdditionalProperties(diagnostics, "dev", Object.keys(rest), []);
	validateOptionalProperty(diagnostics, "dev", "ip", ip, "string");
	validateOptionalProperty(diagnostics, "dev", "port", port, "number");
	validateOptionalProperty(diagnostics, "dev", "inspector_port", inspector_port, "number");
	validateOptionalProperty(diagnostics, "dev", "local_protocol", local_protocol, "string", ["http", "https"]);
	validateOptionalProperty(diagnostics, "dev", "upstream_protocol", upstream_protocol, "string", ["http", "https"]);
	validateOptionalProperty(diagnostics, "dev", "host", host, "string");
	validateOptionalProperty(diagnostics, "dev", "enable_containers", enable_containers, "boolean");
	validateOptionalProperty(diagnostics, "dev", "container_engine", container_engine, "string");
	validateOptionalProperty(diagnostics, "dev", "generate_types", generate_types, "boolean");
	return {
		ip,
		port,
		inspector_port,
		local_protocol,
		upstream_protocol,
		host,
		enable_containers,
		container_engine,
		generate_types
	};
}
__name(normalizeAndValidateDev, "normalizeAndValidateDev");
function normalizeAndValidateAssets(diagnostics, topLevelEnv, rawEnv) {
	return inheritable(diagnostics, topLevelEnv, rawEnv, "assets", validateAssetsConfig, void 0);
}
__name(normalizeAndValidateAssets, "normalizeAndValidateAssets");
function normalizeAndValidateSite(diagnostics, configPath, rawConfig, mainEntryPoint) {
	if (rawConfig?.site !== void 0) {
		const { bucket, include = [], exclude = [],...rest } = rawConfig.site;
		validateAdditionalProperties(diagnostics, "site", Object.keys(rest), ["entry-point"]);
		validateRequiredProperty(diagnostics, "site", "bucket", bucket, "string");
		validateTypedArray(diagnostics, "sites.include", include, "string");
		validateTypedArray(diagnostics, "sites.exclude", exclude, "string");
		validateOptionalProperty(diagnostics, "site", "entry-point", rawConfig.site["entry-point"], "string");
		deprecated(diagnostics, rawConfig, `site.entry-point`, `Delete the \`site.entry-point\` field, then add the top level \`main\` field to your configuration file:
\`\`\`
main = "${path4.join(String(rawConfig.site["entry-point"]) || "workers-site", path4.extname(String(rawConfig.site["entry-point"]) || "workers-site") ? "" : "index.js")}"
\`\`\``, false, void 0, "warning");
		let siteEntryPoint = rawConfig.site["entry-point"];
		if (!mainEntryPoint && !siteEntryPoint) {
			diagnostics.warnings.push(`Because you've defined a [site] configuration, we're defaulting to "workers-site" for the deprecated \`site.entry-point\`field.
Add the top level \`main\` field to your configuration file:
\`\`\`
main = "workers-site/index.js"
\`\`\``);
			siteEntryPoint = "workers-site";
		} else if (mainEntryPoint && siteEntryPoint) diagnostics.errors.push(`Don't define both the \`main\` and \`site.entry-point\` fields in your configuration.
They serve the same purpose: to point to the entry-point of your worker.
Delete the deprecated \`site.entry-point\` field from your config.`);
		if (configPath && siteEntryPoint) siteEntryPoint = path4.relative(process.cwd(), path4.join(path4.dirname(configPath), siteEntryPoint));
		return {
			bucket,
			"entry-point": siteEntryPoint,
			include,
			exclude
		};
	}
}
__name(normalizeAndValidateSite, "normalizeAndValidateSite");
function normalizeAndValidateAliases(diagnostics, configPath, rawConfig) {
	if (rawConfig?.alias === void 0) return;
	if ([
		"string",
		"boolean",
		"number"
	].includes(typeof rawConfig?.alias) || typeof rawConfig?.alias !== "object") {
		diagnostics.errors.push(`Expected alias to be an object, but got ${typeof rawConfig?.alias}`);
		return;
	}
	let isValid$1 = true;
	for (const [key, value] of Object.entries(rawConfig?.alias)) if (typeof value !== "string") {
		diagnostics.errors.push(`Expected alias["${key}"] to be a string, but got ${typeof value}`);
		isValid$1 = false;
	}
	if (isValid$1) return rawConfig.alias;
}
__name(normalizeAndValidateAliases, "normalizeAndValidateAliases");
function normalizeAndValidateModulePaths(diagnostics, configPath, field, rawMapping) {
	if (rawMapping === void 0) return;
	const mapping = {};
	for (const [name, filePath] of Object.entries(rawMapping)) if (isString$2(diagnostics, `${field}['${name}']`, filePath, void 0)) {
		if (configPath) mapping[name] = configPath ? path4.relative(process.cwd(), path4.join(path4.dirname(configPath), filePath)) : filePath;
	}
	return mapping;
}
__name(normalizeAndValidateModulePaths, "normalizeAndValidateModulePaths");
function isValidRouteValue(item) {
	if (!item) return false;
	if (typeof item === "string") return true;
	if (typeof item === "object") {
		if (!hasProperty(item, "pattern") || typeof item.pattern !== "string") return false;
		const otherKeys = Object.keys(item).length - 1;
		const hasZoneId = hasProperty(item, "zone_id") && typeof item.zone_id === "string";
		const hasZoneName = hasProperty(item, "zone_name") && typeof item.zone_name === "string";
		const hasCustomDomainFlag = hasProperty(item, "custom_domain") && typeof item.custom_domain === "boolean";
		if (otherKeys === 2 && hasCustomDomainFlag && (hasZoneId || hasZoneName)) return true;
		else if (otherKeys === 1 && (hasZoneId || hasZoneName || hasCustomDomainFlag)) return true;
	}
	return false;
}
__name(isValidRouteValue, "isValidRouteValue");
function mutateEmptyStringAccountIDValue(diagnostics, rawEnv) {
	if (rawEnv.account_id === "") {
		diagnostics.warnings.push(`The "account_id" field in your configuration is an empty string and will be ignored.
Please remove the "account_id" field from your configuration.`);
		rawEnv.account_id = void 0;
	}
	return rawEnv;
}
__name(mutateEmptyStringAccountIDValue, "mutateEmptyStringAccountIDValue");
function mutateEmptyStringRouteValue(diagnostics, rawEnv) {
	if (rawEnv["route"] === "") {
		diagnostics.warnings.push(`The "route" field in your configuration is an empty string and will be ignored.
Please remove the "route" field from your configuration.`);
		rawEnv["route"] = void 0;
	}
	return rawEnv;
}
__name(mutateEmptyStringRouteValue, "mutateEmptyStringRouteValue");
var isRoute = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (value !== void 0 && !isValidRouteValue(value)) {
		diagnostics.errors.push(`Expected "${field}" to be either a string, or an object with shape { pattern, custom_domain, zone_id | zone_name }, but got ${JSON.stringify(value)}.`);
		return false;
	}
	return true;
}, "isRoute");
var isRouteArray = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (value === void 0) return true;
	if (!Array.isArray(value)) {
		diagnostics.errors.push(`Expected "${field}" to be an array but got ${JSON.stringify(value)}.`);
		return false;
	}
	const invalidRoutes = [];
	for (const item of value) if (!isValidRouteValue(item)) invalidRoutes.push(item);
	if (invalidRoutes.length > 0) diagnostics.errors.push(`Expected "${field}" to be an array of either strings or objects with the shape { pattern, custom_domain, zone_id | zone_name }, but these weren't valid: ${JSON.stringify(invalidRoutes, null, 2)}.`);
	return invalidRoutes.length === 0;
}, "isRouteArray");
function normalizeAndValidateRoute(diagnostics, topLevelEnv, rawEnv) {
	return inheritable(diagnostics, topLevelEnv, mutateEmptyStringRouteValue(diagnostics, rawEnv), "route", isRoute, void 0);
}
__name(normalizeAndValidateRoute, "normalizeAndValidateRoute");
function validateRoutes(diagnostics, topLevelEnv, rawEnv) {
	return inheritable(diagnostics, topLevelEnv, rawEnv, "routes", all(isRouteArray, isMutuallyExclusiveWith(rawEnv, "route")), void 0);
}
__name(validateRoutes, "validateRoutes");
function normalizeAndValidatePlacement(diagnostics, topLevelEnv, rawEnv) {
	if (rawEnv.placement) {
		const placement = rawEnv.placement;
		const hasHint = "hint" in placement;
		const hasRegion = "region" in placement;
		const hasHost = "host" in placement;
		const hasHostname = "hostname" in placement;
		const hasTargetedFields = hasRegion || hasHost || hasHostname;
		if (hasHint && hasTargetedFields) {
			diagnostics.errors.push(`"placement" cannot have both "hint" (smart format) and "region"/"host"/"hostname" (targeted format) fields`);
			return inheritable(diagnostics, topLevelEnv, rawEnv, "placement", () => true, void 0);
		}
		if (hasHint) {
			validateRequiredProperty(diagnostics, "placement", "mode", placement.mode, "string", ["off", "smart"]);
			const mode = placement.mode;
			const hint = placement.hint;
			if (hint !== void 0 && typeof hint !== "string") diagnostics.errors.push(`"placement.hint" must be a string when "placement.mode" is "${mode}"`);
			if (hint && mode !== "smart") diagnostics.errors.push(`"placement.hint" can only be set when "placement.mode" is "smart"`);
		} else if (hasTargetedFields) {
			validateOptionalProperty(diagnostics, "placement", "mode", placement.mode, "string", ["off", "targeted"]);
			if (hasRegion) validateOptionalProperty(diagnostics, "placement", "region", placement.region, "string");
			if (hasHost) validateOptionalProperty(diagnostics, "placement", "host", placement.host, "string");
			if (hasHostname) validateOptionalProperty(diagnostics, "placement", "hostname", placement.hostname, "string");
			if ([
				hasRegion,
				hasHost,
				hasHostname
			].filter(Boolean).length > 1) {
				const presentFields = [];
				if (hasRegion) presentFields.push("region");
				if (hasHost) presentFields.push("host");
				if (hasHostname) presentFields.push("hostname");
				diagnostics.errors.push(`"placement" fields ${presentFields.map((f) => `"${f}"`).join(", ")} are mutually exclusive. Only one can be specified.`);
			}
		} else validateRequiredProperty(diagnostics, "placement", "mode", placement.mode, "string", [
			"off",
			"smart",
			"targeted"
		]);
	}
	return inheritable(diagnostics, topLevelEnv, rawEnv, "placement", () => true, void 0);
}
__name(normalizeAndValidatePlacement, "normalizeAndValidatePlacement");
function validateTailConsumer(diagnostics, field, value) {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"${field}" should be an object but got ${JSON.stringify(value)}.`);
		return false;
	}
	let isValid$1 = true;
	isValid$1 = isValid$1 && validateRequiredProperty(diagnostics, field, "service", value.service, "string");
	isValid$1 = isValid$1 && validateOptionalProperty(diagnostics, field, "environment", value.environment, "string");
	return isValid$1;
}
__name(validateTailConsumer, "validateTailConsumer");
var validateTailConsumers = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (!value) return true;
	if (!Array.isArray(value)) {
		diagnostics.errors.push(`Expected "${field}" to be an array but got ${JSON.stringify(value)}.`);
		return false;
	}
	let isValid$1 = true;
	for (let i$1 = 0; i$1 < value.length; i$1++) isValid$1 = validateTailConsumer(diagnostics, `${field}[${i$1}]`, value[i$1]) && isValid$1;
	return isValid$1;
}, "validateTailConsumers");
function validateStreamingTailConsumer(diagnostics, field, value) {
	if (typeof value !== "object" || value === null || Array.isArray(value)) {
		diagnostics.errors.push(`"${field}" should be an object but got ${JSON.stringify(value)}.`);
		return false;
	}
	return validateRequiredProperty(diagnostics, field, "service", value.service, "string");
}
__name(validateStreamingTailConsumer, "validateStreamingTailConsumer");
var validateStreamingTailConsumers = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (!value) return true;
	if (!Array.isArray(value)) {
		diagnostics.errors.push(`Expected "${field}" to be an array but got ${JSON.stringify(value)}.`);
		return false;
	}
	let isValid$1 = true;
	for (let i$1 = 0; i$1 < value.length; i$1++) isValid$1 = validateStreamingTailConsumer(diagnostics, `${field}[${i$1}]`, value[i$1]) && isValid$1;
	return isValid$1;
}, "validateStreamingTailConsumers");
function normalizeAndValidateEnvironment(diagnostics, configPath, rawEnv, isDispatchNamespace, preserveOriginalMain, envName = "top level", topLevelEnv, useServiceEnvironments, rawConfig) {
	deprecated(diagnostics, rawEnv, "node_compat", `The "node_compat" field is no longer supported as of Wrangler v4. Instead, use the \`nodejs_compat\` compatibility flag. This includes the functionality from legacy \`node_compat\` polyfills and natively implemented Node.js APIs. See https://developers.cloudflare.com/workers/runtime-apis/nodejs for more information.`, true, "Removed", "error");
	experimental(diagnostics, rawEnv, "unsafe");
	const route = normalizeAndValidateRoute(diagnostics, topLevelEnv, rawEnv);
	const account_id = inheritableInWranglerEnvironments(diagnostics, useServiceEnvironments, topLevelEnv, mutateEmptyStringAccountIDValue(diagnostics, rawEnv), "account_id", isString$2, void 0, void 0);
	const routes = validateRoutes(diagnostics, topLevelEnv, rawEnv);
	const workers_dev = inheritable(diagnostics, topLevelEnv, rawEnv, "workers_dev", isBoolean, void 0);
	const preview_urls = inheritable(diagnostics, topLevelEnv, rawEnv, "preview_urls", isBoolean, void 0);
	const build = normalizeAndValidateBuild(diagnostics, rawEnv, rawEnv.build ?? topLevelEnv?.build ?? {}, configPath);
	const environment = {
		account_id,
		compatibility_date: inheritable(diagnostics, topLevelEnv, rawEnv, "compatibility_date", validateCompatibilityDate, void 0),
		compatibility_flags: inheritable(diagnostics, topLevelEnv, rawEnv, "compatibility_flags", isStringArray, []),
		jsx_factory: inheritable(diagnostics, topLevelEnv, rawEnv, "jsx_factory", isString$2, "React.createElement"),
		jsx_fragment: inheritable(diagnostics, topLevelEnv, rawEnv, "jsx_fragment", isString$2, "React.Fragment"),
		tsconfig: validateAndNormalizeTsconfig(diagnostics, topLevelEnv, rawEnv, configPath),
		rules: validateAndNormalizeRules(diagnostics, topLevelEnv, rawEnv, envName),
		name: inheritableInWranglerEnvironments(diagnostics, useServiceEnvironments, topLevelEnv, rawEnv, "name", isDispatchNamespace ? isString$2 : isValidName, appendEnvName(envName), void 0),
		main: preserveOriginalMain ? inheritable(diagnostics, topLevelEnv, rawEnv, "main", isString$2, void 0) : normalizeAndValidateMainField(configPath, inheritable(diagnostics, topLevelEnv, rawEnv, "main", isString$2, void 0)),
		find_additional_modules: inheritable(diagnostics, topLevelEnv, rawEnv, "find_additional_modules", isBoolean, void 0),
		preserve_file_names: inheritable(diagnostics, topLevelEnv, rawEnv, "preserve_file_names", isBoolean, void 0),
		base_dir: normalizeAndValidateBaseDirField(configPath, inheritable(diagnostics, topLevelEnv, rawEnv, "base_dir", isString$2, void 0)),
		route,
		routes,
		triggers: inheritable(diagnostics, topLevelEnv, rawEnv, "triggers", validateTriggers, { crons: void 0 }),
		assets: normalizeAndValidateAssets(diagnostics, topLevelEnv, rawEnv),
		limits: normalizeAndValidateLimits(diagnostics, topLevelEnv, rawEnv),
		placement: normalizeAndValidatePlacement(diagnostics, topLevelEnv, rawEnv),
		build,
		workers_dev,
		preview_urls,
		vars: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "vars", validateVars(envName), {}),
		define: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "define", validateDefines(envName), {}),
		durable_objects: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "durable_objects", validateBindingsProperty(envName, validateDurableObjectBinding), { bindings: [] }),
		workflows: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "workflows", all(validateBindingArray(envName, validateWorkflowBinding), validateUniqueNameProperty), []),
		migrations: inheritable(diagnostics, topLevelEnv, rawEnv, "migrations", validateMigrations, []),
		kv_namespaces: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "kv_namespaces", validateBindingArray(envName, validateKVBinding), []),
		cloudchamber: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "cloudchamber", validateCloudchamberConfig, {}),
		containers: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "containers", validateContainerApp(envName, rawEnv.name, configPath), void 0),
		send_email: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "send_email", validateBindingArray(envName, validateSendEmailBinding), []),
		queues: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "queues", validateQueues(envName), {
			producers: [],
			consumers: []
		}),
		r2_buckets: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "r2_buckets", validateBindingArray(envName, validateR2Binding), []),
		d1_databases: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "d1_databases", validateBindingArray(envName, validateD1Binding), []),
		vectorize: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "vectorize", validateBindingArray(envName, validateVectorizeBinding), []),
		hyperdrive: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "hyperdrive", validateBindingArray(envName, validateHyperdriveBinding), []),
		services: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "services", validateBindingArray(envName, validateServiceBinding), []),
		analytics_engine_datasets: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "analytics_engine_datasets", validateBindingArray(envName, validateAnalyticsEngineBinding), []),
		dispatch_namespaces: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "dispatch_namespaces", validateBindingArray(envName, validateWorkerNamespaceBinding), []),
		mtls_certificates: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "mtls_certificates", validateBindingArray(envName, validateMTlsCertificateBinding), []),
		tail_consumers: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "tail_consumers", validateTailConsumers, void 0),
		streaming_tail_consumers: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "streaming_tail_consumers", validateStreamingTailConsumers, void 0),
		unsafe: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "unsafe", validateUnsafeSettings(envName), {}),
		browser: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "browser", validateNamedSimpleBinding(envName), void 0),
		ai: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "ai", validateAIBinding(envName), void 0),
		images: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "images", validateNamedSimpleBinding(envName), void 0),
		media: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "media", validateNamedSimpleBinding(envName), void 0),
		pipelines: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "pipelines", validateBindingArray(envName, validatePipelineBinding), []),
		secrets_store_secrets: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "secrets_store_secrets", validateBindingArray(envName, validateSecretsStoreSecretBinding), []),
		unsafe_hello_world: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "unsafe_hello_world", validateBindingArray(envName, validateHelloWorldBinding), []),
		worker_loaders: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "worker_loaders", validateBindingArray(envName, validateWorkerLoaderBinding), []),
		ratelimits: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "ratelimits", validateBindingArray(envName, validateRateLimitBinding), []),
		vpc_services: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "vpc_services", validateBindingArray(envName, validateVpcServiceBinding), []),
		version_metadata: notInheritable(diagnostics, topLevelEnv, rawConfig, rawEnv, envName, "version_metadata", validateVersionMetadataBinding(envName), void 0),
		logfwdr: inheritable(diagnostics, topLevelEnv, rawEnv, "logfwdr", validateCflogfwdrObject(envName), { bindings: [] }),
		no_bundle: inheritable(diagnostics, topLevelEnv, rawEnv, "no_bundle", isBoolean, void 0),
		minify: inheritable(diagnostics, topLevelEnv, rawEnv, "minify", isBoolean, void 0),
		keep_names: inheritable(diagnostics, topLevelEnv, rawEnv, "keep_names", isBoolean, void 0),
		first_party_worker: inheritable(diagnostics, topLevelEnv, rawEnv, "first_party_worker", isBoolean, void 0),
		logpush: inheritable(diagnostics, topLevelEnv, rawEnv, "logpush", isBoolean, void 0),
		upload_source_maps: inheritable(diagnostics, topLevelEnv, rawEnv, "upload_source_maps", isBoolean, void 0),
		observability: inheritable(diagnostics, topLevelEnv, rawEnv, "observability", validateObservability, void 0),
		compliance_region: inheritable(diagnostics, topLevelEnv, rawEnv, "compliance_region", isOneOf("public", "fedramp_high"), void 0),
		python_modules: inheritable(diagnostics, topLevelEnv, rawEnv, "python_modules", validatePythonModules, { exclude: ["**/*.pyc"] })
	};
	warnIfDurableObjectsHaveNoMigrations(diagnostics, environment.durable_objects, environment.migrations, configPath);
	return environment;
}
__name(normalizeAndValidateEnvironment, "normalizeAndValidateEnvironment");
function validateAndNormalizeTsconfig(diagnostics, topLevelEnv, rawEnv, configPath) {
	const tsconfig = inheritable(diagnostics, topLevelEnv, rawEnv, "tsconfig", isString$2, void 0);
	return configPath && tsconfig ? path4.relative(process.cwd(), path4.join(path4.dirname(configPath), tsconfig)) : tsconfig;
}
__name(validateAndNormalizeTsconfig, "validateAndNormalizeTsconfig");
var validateAndNormalizeRules = /* @__PURE__ */ __name((diagnostics, topLevelEnv, rawEnv, envName) => {
	return inheritable(diagnostics, topLevelEnv, rawEnv, "rules", validateRules(envName), []);
}, "validateAndNormalizeRules");
var validateTriggers = /* @__PURE__ */ __name((diagnostics, triggersFieldName, triggersValue) => {
	if (triggersValue === void 0 || triggersValue === null) return true;
	if (typeof triggersValue !== "object") {
		diagnostics.errors.push(`Expected "${triggersFieldName}" to be of type object but got ${JSON.stringify(triggersValue)}.`);
		return false;
	}
	let isValid$1 = true;
	if ("crons" in triggersValue && !Array.isArray(triggersValue.crons)) {
		diagnostics.errors.push(`Expected "${triggersFieldName}.crons" to be of type array, but got ${JSON.stringify(triggersValue)}.`);
		isValid$1 = false;
	}
	isValid$1 = validateAdditionalProperties(diagnostics, triggersFieldName, Object.keys(triggersValue), ["crons"]) && isValid$1;
	return isValid$1;
}, "validateTriggers");
var validateRules = /* @__PURE__ */ __name((envName) => (diagnostics, field, envValue, config) => {
	if (!envValue) return true;
	const fieldPath = config === void 0 ? `${field}` : `env.${envName}.${field}`;
	if (!Array.isArray(envValue)) {
		diagnostics.errors.push(`The field "${fieldPath}" should be an array but got ${JSON.stringify(envValue)}.`);
		return false;
	}
	let isValid$1 = true;
	for (let i$1 = 0; i$1 < envValue.length; i$1++) isValid$1 = validateRule(diagnostics, `${fieldPath}[${i$1}]`, envValue[i$1], config) && isValid$1;
	return isValid$1;
}, "validateRules");
var validateRule = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"${field}" should be an object but got ${JSON.stringify(value)}.`);
		return false;
	}
	let isValid$1 = true;
	const rule = value;
	if (!isRequiredProperty(rule, "type", "string", [
		"ESModule",
		"CommonJS",
		"CompiledWasm",
		"Text",
		"Data"
	])) {
		diagnostics.errors.push(`bindings should have a string "type" field, which contains one of "ESModule", "CommonJS", "CompiledWasm", "Text", or "Data".`);
		isValid$1 = false;
	}
	isValid$1 = validateTypedArray(diagnostics, `${field}.globs`, rule.globs, "string") && isValid$1;
	if (!isOptionalProperty(rule, "fallthrough", "boolean")) {
		diagnostics.errors.push(`the field "fallthrough", when present, should be a boolean.`);
		isValid$1 = false;
	}
	return isValid$1;
}, "validateRule");
var validateDefines = /* @__PURE__ */ __name((envName) => (diagnostics, field, value, config) => {
	let isValid$1 = true;
	const fieldPath = config === void 0 ? `${field}` : `env.${envName}.${field}`;
	if (typeof value === "object" && value !== null) {
		for (const varName in value) if (typeof value[varName] !== "string") {
			diagnostics.errors.push(`The field "${fieldPath}.${varName}" should be a string but got ${JSON.stringify(value[varName])}.`);
			isValid$1 = false;
		}
	} else if (value !== void 0) {
		diagnostics.errors.push(`The field "${fieldPath}" should be an object but got ${JSON.stringify(value)}.
`);
		isValid$1 = false;
	}
	const configDefines = Object.keys(config?.define ?? {});
	if (configDefines.length > 0) {
		if (typeof value === "object" && value !== null) {
			const configEnvDefines = config === void 0 ? [] : Object.keys(value);
			for (const varName of configDefines) if (!(varName in value)) diagnostics.warnings.push(`"define.${varName}" exists at the top level, but not on "${fieldPath}".
This is not what you probably want, since "define" configuration is not inherited by environments.
Please add "define.${varName}" to "env.${envName}".`);
			for (const varName of configEnvDefines) if (!configDefines.includes(varName)) diagnostics.warnings.push(`"${varName}" exists on "env.${envName}", but not on the top level.
This is not what you probably want, since "define" configuration within environments can only override existing top level "define" configuration
Please remove "${fieldPath}.${varName}", or add "define.${varName}".`);
		}
	}
	return isValid$1;
}, "validateDefines");
var validateVars = /* @__PURE__ */ __name((envName) => (diagnostics, field, value, config) => {
	let isValid$1 = true;
	const fieldPath = config === void 0 ? `${field}` : `env.${envName}.${field}`;
	if (value !== void 0) {
		if (typeof value !== "object" || value === null) {
			diagnostics.errors.push(`The field "${fieldPath}" should be an object but got ${JSON.stringify(value)}.
`);
			isValid$1 = false;
		} else for (const [varName, varValue] of Object.entries(value)) if (varValue instanceof Date) {
			diagnostics.errors.push(`The field "${fieldPath}.${varName}" is a TOML date, which is not supported. Please use a string instead, e.g. ${varName} = "2025-12-19".`);
			isValid$1 = false;
		}
	}
	const configVars = Object.keys(config?.vars ?? {});
	if (configVars.length > 0) {
		if (typeof value === "object" && value !== null) {
			for (const varName of configVars) if (!(varName in value)) diagnostics.warnings.push(`"vars.${varName}" exists at the top level, but not on "${fieldPath}".
This is not what you probably want, since "vars" configuration is not inherited by environments.
Please add "vars.${varName}" to "env.${envName}".`);
		}
	}
	return isValid$1;
}, "validateVars");
var validateBindingsProperty = /* @__PURE__ */ __name((envName, validateBinding) => (diagnostics, field, value, config) => {
	let isValid$1 = true;
	const fieldPath = config === void 0 ? `${field}` : `env.${envName}.${field}`;
	if (value !== void 0) {
		if (typeof value !== "object" || value === null || Array.isArray(value)) {
			diagnostics.errors.push(`The field "${fieldPath}" should be an object but got ${JSON.stringify(value)}.`);
			isValid$1 = false;
		} else if (!hasProperty(value, "bindings")) {
			diagnostics.errors.push(`The field "${fieldPath}" is missing the required "bindings" property.`);
			isValid$1 = false;
		} else if (!Array.isArray(value.bindings)) {
			diagnostics.errors.push(`The field "${fieldPath}.bindings" should be an array but got ${JSON.stringify(value.bindings)}.`);
			isValid$1 = false;
		} else for (let i$1 = 0; i$1 < value.bindings.length; i$1++) {
			const binding = value.bindings[i$1];
			const bindingDiagnostics = new Diagnostics(`"${fieldPath}.bindings[${i$1}]": ${JSON.stringify(binding)}`);
			isValid$1 = validateBinding(bindingDiagnostics, `${fieldPath}.bindings[${i$1}]`, binding, config) && isValid$1;
			diagnostics.addChild(bindingDiagnostics);
		}
		const configBindingNames = getBindingNames(config?.[field]);
		if (isValid$1 && configBindingNames.length > 0) {
			const envBindingNames = new Set(getBindingNames(value));
			const missingBindings = configBindingNames.filter((name) => !envBindingNames.has(name));
			if (missingBindings.length > 0) diagnostics.warnings.push(`The following bindings are at the top level, but not on "env.${envName}".
This is not what you probably want, since "${field}" configuration is not inherited by environments.
Please add a binding for each to "${fieldPath}.bindings":
` + missingBindings.map((name) => `- ${name}`).join("\n"));
		}
	}
	return isValid$1;
}, "validateBindingsProperty");
var validateUnsafeSettings = /* @__PURE__ */ __name((envName) => (diagnostics, field, value, config) => {
	const fieldPath = config === void 0 ? `${field}` : `env.${envName}.${field}`;
	if (typeof value !== "object" || value === null || Array.isArray(value)) {
		diagnostics.errors.push(`The field "${fieldPath}" should be an object but got ${JSON.stringify(value)}.`);
		return false;
	}
	if (hasProperty(value, "bindings") && value.bindings !== void 0) {
		if (!validateBindingsProperty(envName, validateUnsafeBinding)(diagnostics, field, value, config)) return false;
	}
	if (hasProperty(value, "metadata") && value.metadata !== void 0 && (typeof value.metadata !== "object" || value.metadata === null || Array.isArray(value.metadata))) {
		diagnostics.errors.push(`The field "${fieldPath}.metadata" should be an object but got ${JSON.stringify(value.metadata)}.`);
		return false;
	}
	if (hasProperty(value, "capnp") && value.capnp !== void 0) {
		if (typeof value.capnp !== "object" || value.capnp === null || Array.isArray(value.capnp)) {
			diagnostics.errors.push(`The field "${fieldPath}.capnp" should be an object but got ${JSON.stringify(value.capnp)}.`);
			return false;
		}
		if (hasProperty(value.capnp, "compiled_schema")) {
			if (hasProperty(value.capnp, "base_path") || hasProperty(value.capnp, "source_schemas")) {
				diagnostics.errors.push(`The field "${fieldPath}.capnp" cannot contain both "compiled_schema" and one of "base_path" or "source_schemas".`);
				return false;
			}
			if (typeof value.capnp.compiled_schema !== "string") {
				diagnostics.errors.push(`The field "${fieldPath}.capnp.compiled_schema", when present, should be a string but got ${JSON.stringify(value.capnp.compiled_schema)}.`);
				return false;
			}
		} else {
			if (!isRequiredProperty(value.capnp, "base_path", "string")) diagnostics.errors.push(`The field "${fieldPath}.capnp.base_path", when present, should be a string but got ${JSON.stringify(value.capnp.base_path)}`);
			if (!validateTypedArray(diagnostics, `${fieldPath}.capnp.source_schemas`, value.capnp.source_schemas, "string")) return false;
		}
	}
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"bindings",
		"metadata",
		"capnp"
	]);
	return true;
}, "validateUnsafeSettings");
var validateDurableObjectBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`Expected "${field}" to be an object but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "name", "string")) {
		diagnostics.errors.push(`binding should have a string "name" field.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "class_name", "string")) {
		diagnostics.errors.push(`binding should have a string "class_name" field.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "script_name", "string")) {
		diagnostics.errors.push(`the field "script_name", when present, should be a string.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "environment", "string")) {
		diagnostics.errors.push(`the field "environment", when present, should be a string.`);
		isValid$1 = false;
	}
	if ("environment" in value && !("script_name" in value)) {
		diagnostics.errors.push(`binding should have a "script_name" field if "environment" is present.`);
		isValid$1 = false;
	}
	if (!isRemoteValid(value, field, diagnostics)) isValid$1 = false;
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"class_name",
		"environment",
		"name",
		"script_name"
	]);
	return isValid$1;
}, "validateDurableObjectBinding");
var workflowNameFormatMessage = `Workflow names must be 1-64 characters long, start with a letter, number, or underscore, and may only contain letters, numbers, underscores, or hyphens.`;
var validateWorkflowBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"workflows" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "name", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "name" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	} else if (!isValidWorkflowName(value.name)) {
		diagnostics.errors.push(`"${field}" binding "name" field is invalid. ${workflowNameFormatMessage}`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "class_name", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "class_name" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "script_name", "string")) {
		diagnostics.errors.push(`"${field}" bindings should, optionally, have a string "script_name" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "remote", "boolean")) {
		diagnostics.errors.push(`"${field}" bindings should, optionally, have a boolean "remote" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"binding",
		"name",
		"class_name",
		"script_name",
		"remote"
	]);
	return isValid$1;
}, "validateWorkflowBinding");
var validateCflogfwdrObject = /* @__PURE__ */ __name((envName) => (diagnostics, field, value, topLevelEnv) => {
	if (!validateBindingsProperty(envName, validateCflogfwdrBinding)(diagnostics, field, value, topLevelEnv)) return false;
	if (value?.schema !== void 0) {
		diagnostics.errors.push(`"${field}" binding "schema" property has been replaced with the "unsafe.capnp" object, which expects a "base_path" and an array of "source_schemas" to compile, or a "compiled_schema" property.`);
		return false;
	}
	return true;
}, "validateCflogfwdrObject");
var validateCflogfwdrBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`Expected "${field}" to be an object but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "name", "string")) {
		diagnostics.errors.push(`binding should have a string "name" field.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "destination", "string")) {
		diagnostics.errors.push(`binding should have a string "destination" field.`);
		isValid$1 = false;
	}
	validateAdditionalProperties(diagnostics, field, Object.keys(value), ["destination", "name"]);
	return isValid$1;
}, "validateCflogfwdrBinding");
var validateAssetsConfig = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (value === void 0) return true;
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"${field}" should be an object, but got value ${JSON.stringify(field)} of type ${typeof value}`);
		return false;
	}
	let isValid$1 = true;
	isValid$1 = validateOptionalProperty(diagnostics, field, "directory", value.directory, "string") && isValid$1;
	isValid$1 = validateOptionalProperty(diagnostics, field, "binding", value.binding, "string") && isValid$1;
	isValid$1 = validateOptionalProperty(diagnostics, field, "html_handling", value.html_handling, "string", [
		"auto-trailing-slash",
		"force-trailing-slash",
		"drop-trailing-slash",
		"none"
	]) && isValid$1;
	isValid$1 = validateOptionalProperty(diagnostics, field, "not_found_handling", value.not_found_handling, "string", [
		"single-page-application",
		"404-page",
		"none"
	]) && isValid$1;
	if (value.run_worker_first !== void 0) if (typeof value.run_worker_first === "boolean") isValid$1 = validateOptionalProperty(diagnostics, field, "run_worker_first", value.run_worker_first, "boolean") && isValid$1;
	else if (Array.isArray(value.run_worker_first)) isValid$1 = validateOptionalTypedArray(diagnostics, "assets.run_worker_first", value.run_worker_first, "string") && isValid$1;
	else {
		diagnostics.errors.push(`The field "${field}.run_worker_first" should be an array of strings or a boolean, but got ${JSON.stringify(value.run_worker_first)}.`);
		isValid$1 = false;
	}
	isValid$1 = validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"directory",
		"binding",
		"html_handling",
		"not_found_handling",
		"run_worker_first"
	]) && isValid$1;
	return isValid$1;
}, "validateAssetsConfig");
var validateNamedSimpleBinding = /* @__PURE__ */ __name((envName) => (diagnostics, field, value, config) => {
	const fieldPath = config === void 0 ? `${field}` : `env.${envName}.${field}`;
	if (typeof value !== "object" || value === null || Array.isArray(value)) {
		diagnostics.errors.push(`The field "${fieldPath}" should be an object but got ${JSON.stringify(value)}.`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`binding should have a string "binding" field.`);
		isValid$1 = false;
	}
	if (!isRemoteValid(value, field, diagnostics)) isValid$1 = false;
	validateAdditionalProperties(diagnostics, field, Object.keys(value), ["binding", "remote"]);
	return isValid$1;
}, "validateNamedSimpleBinding");
var validateAIBinding = /* @__PURE__ */ __name((envName) => (diagnostics, field, value, config) => {
	const fieldPath = config === void 0 ? `${field}` : `env.${envName}.${field}`;
	if (typeof value !== "object" || value === null || Array.isArray(value)) {
		diagnostics.errors.push(`The field "${fieldPath}" should be an object but got ${JSON.stringify(value)}.`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`binding should have a string "binding" field.`);
		isValid$1 = false;
	}
	if (!isRemoteValid(value, field, diagnostics)) isValid$1 = false;
	return isValid$1;
}, "validateAIBinding");
var validateVersionMetadataBinding = /* @__PURE__ */ __name((envName) => (diagnostics, field, value, config) => {
	const fieldPath = config === void 0 ? `${field}` : `env.${envName}.${field}`;
	if (typeof value !== "object" || value === null || Array.isArray(value)) {
		diagnostics.errors.push(`The field "${fieldPath}" should be an object but got ${JSON.stringify(value)}.`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`binding should have a string "binding" field.`);
		isValid$1 = false;
	}
	return isValid$1;
}, "validateVersionMetadataBinding");
var validateUnsafeBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`Expected ${field} to be an object but got ${JSON.stringify(value)}.`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "name", "string")) {
		diagnostics.errors.push(`binding should have a string "name" field.`);
		isValid$1 = false;
	}
	if (isRequiredProperty(value, "type", "string")) {
		if ([
			"plain_text",
			"secret_text",
			"json",
			"wasm_module",
			"data_blob",
			"text_blob",
			"browser",
			"ai",
			"kv_namespace",
			"durable_object_namespace",
			"d1_database",
			"r2_bucket",
			"service",
			"logfwdr",
			"mtls_certificate",
			"pipeline",
			"worker_loader",
			"vpc_service",
			"media"
		].includes(value.type)) diagnostics.warnings.push(`The binding type "${value.type}" is directly supported by wrangler.
Consider migrating this unsafe binding to a format for '${value.type}' bindings that is supported by wrangler for optimal support.
For more details, see https://developers.cloudflare.com/workers/cli-wrangler/configuration`);
		if (value.type === "metadata" && isRequiredProperty(value, "name", "string")) diagnostics.warnings.push("The deployment object in the metadata binding is now deprecated. Please switch using the version_metadata binding for access to version specific fields: https://developers.cloudflare.com/workers/runtime-apis/bindings/version-metadata");
	} else {
		diagnostics.errors.push(`binding should have a string "type" field.`);
		isValid$1 = false;
	}
	return isValid$1;
}, "validateUnsafeBinding");
var validateBindingArray = /* @__PURE__ */ __name((envName, validateBinding) => (diagnostics, field, envValue, config) => {
	if (envValue === void 0) return true;
	const fieldPath = config === void 0 ? `${field}` : `env.${envName}.${field}`;
	if (!Array.isArray(envValue)) {
		diagnostics.errors.push(`The field "${fieldPath}" should be an array but got ${JSON.stringify(envValue)}.`);
		return false;
	}
	let isValid$1 = true;
	for (let i$1 = 0; i$1 < envValue.length; i$1++) isValid$1 = validateBinding(diagnostics, `${fieldPath}[${i$1}]`, envValue[i$1], config) && isValid$1;
	const configValue = config?.[field];
	if (Array.isArray(configValue)) {
		const configBindingNames = configValue.map((value) => value.binding);
		if (configBindingNames.length > 0) {
			const envBindingNames = new Set(envValue.map((value) => value.binding));
			for (const configBindingName of configBindingNames) if (!envBindingNames.has(configBindingName)) diagnostics.warnings.push(`There is a ${field} binding with name "${configBindingName}" at the top level, but not on "env.${envName}".
This is not what you probably want, since "${field}" configuration is not inherited by environments.
Please add a binding for "${configBindingName}" to "env.${envName}.${field}.bindings".`);
		}
	}
	return isValid$1;
}, "validateBindingArray");
function validateContainerApp(envName, topLevelName, configPath) {
	return (diagnostics, field, value, config) => {
		if (!value) return true;
		if (!Array.isArray(value)) {
			diagnostics.errors.push(`"containers" field should be an array, but got ${JSON.stringify(value)}`);
			return false;
		}
		for (const containerAppOptional of value) {
			if (!isOptionalProperty(value, "name", "string")) diagnostics.errors.push(`Field "name", when present, should be a string, but got ${JSON.stringify(value)}`);
			validateRequiredProperty(diagnostics, field, "class_name", containerAppOptional.class_name, "string");
			validateOptionalProperty(diagnostics, field, "name", containerAppOptional.name, "string");
			if (!containerAppOptional.name) {
				if (!topLevelName || !isOptionalProperty(containerAppOptional, "class_name", "string")) diagnostics.errors.push(`Must have either a top level "name" and "containers.class_name" field defined, or have field "containers.name" defined.`);
				let name = `${topLevelName}-${containerAppOptional.class_name}`;
				name += config === void 0 ? "" : `-${envName}`;
				containerAppOptional.name = name.toLowerCase().replace(/ /g, "-");
			}
			if (!containerAppOptional.configuration?.image && !containerAppOptional.image) diagnostics.errors.push(`"containers.image" field must be defined for each container app. This should be the path to your Dockerfile or an image URI pointing to the Cloudflare registry.`);
			if ("configuration" in containerAppOptional) {
				diagnostics.warnings.push(`"containers.configuration" is deprecated. Use top level "containers" fields instead. "configuration.image" should be "image", limits should be set via "instance_type".`);
				if (typeof containerAppOptional.configuration !== "object" || Array.isArray(containerAppOptional.configuration)) diagnostics.errors.push(`"containers.configuration" should be an object`);
				if (containerAppOptional.instance_type && (containerAppOptional.configuration.disk !== void 0 || containerAppOptional.configuration.vcpu !== void 0 || containerAppOptional.configuration.memory_mib !== void 0)) diagnostics.errors.push(`Cannot set custom limits via "containers.configuration" and use preset "instance_type" limits at the same time.`);
			}
			validateOptionalProperty(diagnostics, field, "image_build_context", containerAppOptional.image_build_context, "string");
			let resolvedImage = containerAppOptional.image ?? containerAppOptional.configuration?.image;
			let resolvedBuildContextPath = void 0;
			try {
				if (isDockerfile$1(resolvedImage, configPath)) {
					const baseDir = configPath ? path4.dirname(configPath) : process.cwd();
					resolvedImage = path4.resolve(baseDir, resolvedImage);
					resolvedBuildContextPath = containerAppOptional.image_build_context ? path4.resolve(baseDir, containerAppOptional.image_build_context) : path4.dirname(resolvedImage);
				}
			} catch (err) {
				if (err instanceof Error && err.message) diagnostics.errors.push(err.message);
				else throw err;
			}
			containerAppOptional.image = resolvedImage;
			containerAppOptional.image_build_context = resolvedBuildContextPath;
			if (containerAppOptional.rollout_step_percentage !== void 0) {
				const rolloutStep = containerAppOptional.rollout_step_percentage;
				if (typeof rolloutStep === "number") {
					if (![
						5,
						10,
						20,
						25,
						50,
						100
					].includes(rolloutStep)) diagnostics.errors.push(`"containers.rollout_step_percentage" must be one of [5, 10, 20, 25, 50, 100], but got ${rolloutStep}`);
				} else if (Array.isArray(rolloutStep)) {
					const nonNumber = [];
					const outOfRange = [];
					let index = 0;
					let ascending = true;
					for (const step of rolloutStep) if (typeof step !== "number") nonNumber.push(step);
					else {
						if (step < 10 || step > 100) outOfRange.push(step);
						if (ascending && index > 0 && step < rolloutStep[index - 1]) {
							diagnostics.errors.push(`"containers.rollout_step_percentage" array elements must be in ascending order, but got "${rolloutStep}"`);
							ascending = false;
						}
						if (index === rolloutStep.length - 1 && step !== 100) diagnostics.errors.push(`The final step in "containers.rollout_step_percentage" must be 100, but got "${step}"`);
						index++;
					}
					if (nonNumber.length) diagnostics.errors.push(`"containers.rollout_step_percentage" array elements must be numbers, but got "${nonNumber.join(", ")}"`);
					if (outOfRange.length) diagnostics.errors.push(`"containers.rollout_step_percentage" array elements must be between 10 and 100, but got "${outOfRange.join(", ")}"`);
				} else diagnostics.errors.push(`"containers.rollout_step_percentage" must be a number or array of numbers, but got "${rolloutStep}"`);
			}
			validateOptionalProperty(diagnostics, field, "rollout_kind", containerAppOptional.rollout_kind, "string", [
				"full_auto",
				"full_manual",
				"none"
			]);
			if (!isOptionalProperty(containerAppOptional, "rollout_active_grace_period", "number") || containerAppOptional.rollout_active_grace_period < 0) diagnostics.errors.push(`"containers.rollout_active_grace_period" field should be a positive number but got "${containerAppOptional.rollout_active_grace_period}"`);
			validateOptionalProperty(diagnostics, field, "max_instances", containerAppOptional.max_instances, "number");
			if (containerAppOptional.max_instances !== void 0 && containerAppOptional.max_instances < 0) diagnostics.errors.push(`"containers.max_instances" field should be a positive number, but got ${containerAppOptional.max_instances}`);
			if (containerAppOptional.rollout_step_percentage !== void 0 && containerAppOptional.max_instances !== void 0 && Array.isArray(containerAppOptional.rollout_step_percentage)) {
				const rolloutStepsCount = containerAppOptional.rollout_step_percentage.length;
				if (rolloutStepsCount > containerAppOptional.max_instances) diagnostics.errors.push(`"containers.rollout_step_percentage" cannot have more steps (${rolloutStepsCount}) than "max_instances" (${containerAppOptional.max_instances})`);
			}
			validateOptionalProperty(diagnostics, field, "image_vars", containerAppOptional.image_vars, "object");
			validateOptionalProperty(diagnostics, field, "scheduling_policy", containerAppOptional.scheduling_policy, "string", [
				"regional",
				"moon",
				"default"
			]);
			if ("instances" in containerAppOptional) diagnostics.warnings.push(`"containers.instances" is deprecated. Use "containers.max_instances" instead.`);
			if ("durable_objects" in containerAppOptional) diagnostics.warnings.push(`"containers.durable_objects" is deprecated. Use the "class_name" field instead.`);
			if ("unsafe" in containerAppOptional) {
				if (containerAppOptional.unsafe && typeof containerAppOptional.unsafe !== "object" || Array.isArray(containerAppOptional.unsafe)) diagnostics.errors.push(`The field "containers.unsafe" should be an object but got ${JSON.stringify(typeof containerAppOptional.unsafe)}.`);
			}
			validateAdditionalProperties(diagnostics, field, Object.keys(containerAppOptional), [
				"name",
				"instances",
				"max_instances",
				"image",
				"image_build_context",
				"image_vars",
				"class_name",
				"scheduling_policy",
				"instance_type",
				"wrangler_ssh",
				"authorized_keys",
				"trusted_user_ca_keys",
				"configuration",
				"constraints",
				"affinities",
				"rollout_step_percentage",
				"rollout_kind",
				"durable_objects",
				"rollout_active_grace_period",
				"unsafe"
			]);
			if ("configuration" in containerAppOptional) validateAdditionalProperties(diagnostics, `${field}.configuration`, Object.keys(containerAppOptional.configuration), [
				"image",
				"secrets",
				"labels",
				"disk",
				"vcpu",
				"memory_mib"
			]);
			if ("wrangler_ssh" in containerAppOptional) {
				if (!isRequiredProperty(containerAppOptional.wrangler_ssh, "enabled", "boolean")) diagnostics.errors.push(`${field}.wrangler_ssh.enabled must be a boolean`);
				if (!isOptionalProperty(containerAppOptional.wrangler_ssh, "port", "number") || containerAppOptional.wrangler_ssh.port < 1 || containerAppOptional.wrangler_ssh.port > 65535) diagnostics.errors.push(`${field}.wrangler_ssh.port must be a number between 1 and 65535 inclusive`);
			}
			if ("authorized_keys" in containerAppOptional) if (!Array.isArray(containerAppOptional.authorized_keys)) diagnostics.errors.push(`${field}.authorized_keys must be an array`);
			else for (const index in containerAppOptional.authorized_keys) {
				const fieldPath = `${field}.authorized_keys[${index}]`;
				const key = containerAppOptional.authorized_keys[index];
				if (!isRequiredProperty(key, "name", "string")) diagnostics.errors.push(`${fieldPath}.name must be a string`);
				if (!isRequiredProperty(key, "public_key", "string")) diagnostics.errors.push(`${fieldPath}.public_key must be a string`);
				if (!key.public_key.toLowerCase().startsWith("ssh-ed25519")) diagnostics.errors.push(`${fieldPath}.public_key is a unsupported key type. Please provide a ED25519 public key.`);
			}
			if ("trusted_user_ca_keys" in containerAppOptional) if (!Array.isArray(containerAppOptional.trusted_user_ca_keys)) diagnostics.errors.push(`${field}.trusted_user_ca_keys must be an array`);
			else for (const index in containerAppOptional.trusted_user_ca_keys) {
				const fieldPath = `${field}.trusted_user_ca_keys[${index}]`;
				const key = containerAppOptional.trusted_user_ca_keys[index];
				if (!isOptionalProperty(key, "name", "string")) diagnostics.errors.push(`${fieldPath}.name must be a string`);
				if (!isRequiredProperty(key, "public_key", "string")) diagnostics.errors.push(`${fieldPath}.public_key must be a string`);
				if (!key.public_key.toLowerCase().startsWith("ssh-ed25519")) diagnostics.errors.push(`${fieldPath}.public_key is a unsupported key type. Please provide a ED25519 public key.`);
			}
			if (typeof containerAppOptional.instance_type === "string") {
				validateOptionalProperty(diagnostics, field, "instance_type", containerAppOptional.instance_type, "string", ALLOWED_INSTANCE_TYPES);
				if (containerAppOptional.instance_type === "dev") diagnostics.warnings.push(`The "dev" instance_type has been renamed to "lite" and will be removed in a subsequent version. Please update your configuration to use "lite" instead.`);
				if (containerAppOptional.instance_type === "standard") diagnostics.warnings.push(`The "standard" instance_type has been renamed to "standard-1" and will be removed in a subsequent version. Please update your configuration to use "standard-1" instead.`);
			} else if (validateOptionalProperty(diagnostics, field, "instance_type", containerAppOptional.instance_type, "object") && containerAppOptional.instance_type) {
				const instanceTypeProperties = [
					"vcpu",
					"memory_mib",
					"disk_mb"
				];
				instanceTypeProperties.forEach((key) => {
					if (!isOptionalProperty(containerAppOptional.instance_type, key, "number")) diagnostics.errors.push(`"containers.instance_type.${key}", when present, should be a number.`);
				});
				validateAdditionalProperties(diagnostics, `${field}.instance_type`, Object.keys(containerAppOptional.instance_type), instanceTypeProperties);
			}
		}
		if (diagnostics.errors.length > 0) return false;
		return true;
	};
}
__name(validateContainerApp, "validateContainerApp");
var validateCloudchamberConfig = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null || Array.isArray(value)) {
		diagnostics.errors.push(`"cloudchamber" should be an object, but got ${JSON.stringify(value)}`);
		return false;
	}
	const optionalAttrsByType = {
		string: [
			"memory",
			"image",
			"location"
		],
		boolean: ["ipv4"],
		number: ["vcpu"]
	};
	let isValid$1 = true;
	Object.entries(optionalAttrsByType).forEach(([attrType, attrNames]) => {
		attrNames.forEach((key) => {
			if (!isOptionalProperty(value, key, attrType)) {
				diagnostics.errors.push(`"${field}" bindings should, optionally, have a ${attrType} "${key}" field but got ${JSON.stringify(value)}.`);
				isValid$1 = false;
			}
		});
	});
	if ("instance_type" in value && value.instance_type !== void 0) {
		if (typeof value.instance_type !== "string" || !ALLOWED_INSTANCE_TYPES.includes(value.instance_type)) diagnostics.errors.push(`"instance_type" should be one of 'lite', 'basic', 'standard-1', 'standard-2', 'standard-3', or 'standard-4', but got ${value.instance_type}`);
		if ("memory" in value && value.memory !== void 0 || "vcpu" in value && value.vcpu !== void 0) diagnostics.errors.push(`"${field}" configuration should not set either "memory" or "vcpu" with "instance_type"`);
	}
	return isValid$1;
}, "validateCloudchamberConfig");
var validateKVBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"kv_namespaces" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "id", "string") || value.id !== void 0 && value.id.length === 0) {
		diagnostics.errors.push(`"${field}" bindings should have a string "id" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "preview_id", "string")) {
		diagnostics.errors.push(`"${field}" bindings should, optionally, have a string "preview_id" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRemoteValid(value, field, diagnostics)) isValid$1 = false;
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"binding",
		"id",
		"preview_id",
		"remote"
	]);
	return isValid$1;
}, "validateKVBinding");
var validateSendEmailBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"send_email" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "name", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "name" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "destination_address", "string")) {
		diagnostics.errors.push(`"${field}" bindings should, optionally, have a string "destination_address" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "allowed_destination_addresses", "object")) {
		diagnostics.errors.push(`"${field}" bindings should, optionally, have a []string "allowed_destination_addresses" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "allowed_sender_addresses", "object")) {
		diagnostics.errors.push(`"${field}" bindings should, optionally, have a []string "allowed_sender_addresses" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if ("destination_address" in value && "allowed_destination_addresses" in value) {
		diagnostics.errors.push(`"${field}" bindings should have either a "destination_address" or "allowed_destination_addresses" field, but not both.`);
		isValid$1 = false;
	}
	if (!isRemoteValid(value, field, diagnostics)) isValid$1 = false;
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"allowed_sender_addresses",
		"allowed_destination_addresses",
		"destination_address",
		"name",
		"binding",
		"remote"
	]);
	return isValid$1;
}, "validateSendEmailBinding");
var validateQueueBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"queue" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	if (!validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"binding",
		"queue",
		"delivery_delay",
		"remote"
	])) return false;
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "queue", "string") || value.queue.length === 0) {
		diagnostics.errors.push(`"${field}" bindings should have a string "queue" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	for (const optionalOpt of [{
		key: "delivery_delay",
		type: "number"
	}]) if (!isOptionalProperty(value, optionalOpt.key, optionalOpt.type)) {
		diagnostics.errors.push(`"${field}" should, optionally, have a ${optionalOpt.type} "${optionalOpt.key}" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRemoteValid(value, field, diagnostics)) isValid$1 = false;
	return isValid$1;
}, "validateQueueBinding");
var validateR2Binding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"r2_buckets" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "bucket_name", "string") || value.bucket_name !== void 0 && value.bucket_name.length === 0) {
		diagnostics.errors.push(`"${field}" bindings should have a string "bucket_name" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (isValid$1 && hasProperty(value, "bucket_name") && !isValidR2BucketName(value.bucket_name)) {
		diagnostics.errors.push(`${field}.bucket_name=${JSON.stringify(value.bucket_name)} is invalid. ${bucketFormatMessage}`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "preview_bucket_name", "string")) {
		diagnostics.errors.push(`"${field}" bindings should, optionally, have a string "preview_bucket_name" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (isValid$1 && hasProperty(value, "preview_bucket_name") && !isValidR2BucketName(value.preview_bucket_name)) {
		diagnostics.errors.push(`${field}.preview_bucket_name= ${JSON.stringify(value.preview_bucket_name)} is invalid. ${bucketFormatMessage}`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "jurisdiction", "string")) {
		diagnostics.errors.push(`"${field}" bindings should, optionally, have a string "jurisdiction" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRemoteValid(value, field, diagnostics)) isValid$1 = false;
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"binding",
		"bucket_name",
		"preview_bucket_name",
		"jurisdiction",
		"remote"
	]);
	return isValid$1;
}, "validateR2Binding");
var validateD1Binding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"d1_databases" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "database_id", "string")) {
		diagnostics.errors.push(`"${field}" bindings must have a "database_id" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "preview_database_id", "string")) {
		diagnostics.errors.push(`"${field}" bindings should, optionally, have a string "preview_database_id" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRemoteValid(value, field, diagnostics)) isValid$1 = false;
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"binding",
		"database_id",
		"database_internal_env",
		"database_name",
		"migrations_dir",
		"migrations_table",
		"preview_database_id",
		"remote"
	]);
	return isValid$1;
}, "validateD1Binding");
var validateVectorizeBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"vectorize" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "index_name", "string")) {
		diagnostics.errors.push(`"${field}" bindings must have an "index_name" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRemoteValid(value, field, diagnostics)) isValid$1 = false;
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"binding",
		"index_name",
		"remote"
	]);
	return isValid$1;
}, "validateVectorizeBinding");
var validateHyperdriveBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"hyperdrive" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "id", "string")) {
		diagnostics.errors.push(`"${field}" bindings must have a "id" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"binding",
		"id",
		"localConnectionString"
	]);
	return isValid$1;
}, "validateHyperdriveBinding");
var validateVpcServiceBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"vpc_services" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "service_id", "string")) {
		diagnostics.errors.push(`"${field}" bindings must have a "service_id" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"binding",
		"service_id",
		"remote"
	]);
	return isValid$1;
}, "validateVpcServiceBinding");
var validateBindingsHaveUniqueNames = /* @__PURE__ */ __name((diagnostics, config) => {
	let hasDuplicates = false;
	const bindingNamesArray = Object.entries(friendlyBindingNames);
	const bindingsGroupedByType = Object.fromEntries(bindingNamesArray.map(([bindingType, binding]) => [binding, getBindingNames(bindingType === "queues" ? config[bindingType]?.producers : config[bindingType])]));
	const bindingsGroupedByName = {};
	for (const bindingType in bindingsGroupedByType) {
		const bindingNames = bindingsGroupedByType[bindingType];
		for (const bindingName of bindingNames) {
			if (!(bindingName in bindingsGroupedByName)) bindingsGroupedByName[bindingName] = [];
			if (bindingName === "ASSETS" && isPagesConfig(config)) diagnostics.errors.push(`The name 'ASSETS' is reserved in Pages projects. Please use a different name for your ${bindingType} binding.`);
			bindingsGroupedByName[bindingName].push(bindingType);
		}
	}
	for (const bindingName in bindingsGroupedByName) {
		const bindingTypes = bindingsGroupedByName[bindingName];
		if (bindingTypes.length < 2) continue;
		hasDuplicates = true;
		const sameType = bindingTypes.filter((type, i$1) => bindingTypes.indexOf(type) !== i$1).filter((type, i$1, duplicateBindingTypes) => duplicateBindingTypes.indexOf(type) === i$1);
		const differentTypes = bindingTypes.filter((type, i$1) => bindingTypes.indexOf(type) === i$1);
		if (differentTypes.length > 1) diagnostics.errors.push(`${bindingName} assigned to ${ENGLISH.format(differentTypes)} bindings.`);
		sameType.forEach((bindingType) => {
			diagnostics.errors.push(`${bindingName} assigned to multiple ${bindingType} bindings.`);
		});
	}
	if (hasDuplicates) diagnostics.errors.push(`Bindings must have unique names, so that they can all be referenced in the worker.
Please change your bindings to have unique names.`);
	return !hasDuplicates;
}, "validateBindingsHaveUniqueNames");
var validateServiceBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"services" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "service", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "service" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "environment", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "environment" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "entrypoint", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "entrypoint" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRemoteValid(value, field, diagnostics)) isValid$1 = false;
	return isValid$1;
}, "validateServiceBinding");
var validateAnalyticsEngineBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"analytics_engine" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "dataset", "string") || value.dataset?.length === 0) {
		diagnostics.errors.push(`"${field}" bindings should, optionally, have a string "dataset" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	validateAdditionalProperties(diagnostics, field, Object.keys(value), ["binding", "dataset"]);
	return isValid$1;
}, "validateAnalyticsEngineBinding");
var validateWorkerNamespaceBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"${field}" binding should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" should have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "namespace", "string")) {
		diagnostics.errors.push(`"${field}" should have a string "namespace" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (hasProperty(value, "outbound")) {
		if (!validateWorkerNamespaceOutbound(diagnostics, `${field}.outbound`, value.outbound ?? {})) {
			diagnostics.errors.push(`"${field}" has an invalid outbound definition.`);
			isValid$1 = false;
		}
	}
	if (!isRemoteValid(value, field, diagnostics)) isValid$1 = false;
	return isValid$1;
}, "validateWorkerNamespaceBinding");
function validateWorkerNamespaceOutbound(diagnostics, field, value) {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"${field}" should be an object, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	isValid$1 = isValid$1 && validateRequiredProperty(diagnostics, field, "service", value.service, "string");
	isValid$1 = isValid$1 && validateOptionalProperty(diagnostics, field, "environment", value.environment, "string");
	isValid$1 = isValid$1 && validateOptionalTypedArray(diagnostics, `${field}.parameters`, value.parameters, "string");
	return isValid$1;
}
__name(validateWorkerNamespaceOutbound, "validateWorkerNamespaceOutbound");
var validateMTlsCertificateBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"mtls_certificates" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings should have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "certificate_id", "string") || value.certificate_id.length === 0) {
		diagnostics.errors.push(`"${field}" bindings should have a string "certificate_id" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"binding",
		"certificate_id",
		"remote"
	]);
	if (!isRemoteValid(value, field, diagnostics)) isValid$1 = false;
	return isValid$1;
}, "validateMTlsCertificateBinding");
function validateQueues(envName) {
	return (diagnostics, field, value, config) => {
		const fieldPath = config === void 0 ? `${field}` : `env.${envName}.${field}`;
		if (typeof value !== "object" || Array.isArray(value) || value === null) {
			diagnostics.errors.push(`The field "${fieldPath}" should be an object but got ${JSON.stringify(value)}.`);
			return false;
		}
		let isValid$1 = true;
		if (!validateAdditionalProperties(diagnostics, fieldPath, Object.keys(value), ["consumers", "producers"])) isValid$1 = false;
		if (hasProperty(value, "consumers")) {
			const consumers = value.consumers;
			if (!Array.isArray(consumers)) {
				diagnostics.errors.push(`The field "${fieldPath}.consumers" should be an array but got ${JSON.stringify(consumers)}.`);
				isValid$1 = false;
			}
			for (let i$1 = 0; i$1 < consumers.length; i$1++) {
				const consumer = consumers[i$1];
				if (!validateConsumer(diagnostics, `${fieldPath}.consumers[${i$1}]`, consumer, config)) isValid$1 = false;
			}
		}
		if (hasProperty(value, "producers")) {
			if (!validateBindingArray(envName, validateQueueBinding)(diagnostics, `${field}.producers`, value.producers, config)) isValid$1 = false;
		}
		return isValid$1;
	};
}
__name(validateQueues, "validateQueues");
var validateConsumer = /* @__PURE__ */ __name((diagnostics, field, value, _config) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"${field}" should be a objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"queue",
		"type",
		"max_batch_size",
		"max_batch_timeout",
		"max_retries",
		"dead_letter_queue",
		"max_concurrency",
		"visibility_timeout_ms",
		"retry_delay"
	])) isValid$1 = false;
	if (!isRequiredProperty(value, "queue", "string")) diagnostics.errors.push(`"${field}" should have a string "queue" field but got ${JSON.stringify(value)}.`);
	for (const optionalOpt of [
		{
			key: "type",
			type: "string"
		},
		{
			key: "max_batch_size",
			type: "number"
		},
		{
			key: "max_batch_timeout",
			type: "number"
		},
		{
			key: "max_retries",
			type: "number"
		},
		{
			key: "dead_letter_queue",
			type: "string"
		},
		{
			key: "max_concurrency",
			type: "number"
		},
		{
			key: "visibility_timeout_ms",
			type: "number"
		},
		{
			key: "retry_delay",
			type: "number"
		}
	]) if (!isOptionalProperty(value, optionalOpt.key, optionalOpt.type)) {
		diagnostics.errors.push(`"${field}" should, optionally, have a ${optionalOpt.type} "${optionalOpt.key}" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	return isValid$1;
}, "validateConsumer");
var validateCompatibilityDate = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (value === void 0) return true;
	if (typeof value !== "string") {
		diagnostics.errors.push(`Expected "${field}" to be of type string but got ${JSON.stringify(value)}.`);
		return false;
	}
	return isValidDateTimeStringFormat(diagnostics, field, value);
}, "validateCompatibilityDate");
var validatePipelineBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"pipeline" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings must have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "pipeline", "string")) {
		diagnostics.errors.push(`"${field}" bindings must have a string "pipeline" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRemoteValid(value, field, diagnostics)) isValid$1 = false;
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"binding",
		"pipeline",
		"remote"
	]);
	return isValid$1;
}, "validatePipelineBinding");
var validateSecretsStoreSecretBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"secrets_store_secrets" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings must have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "store_id", "string")) {
		diagnostics.errors.push(`"${field}" bindings must have a string "store_id" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "secret_name", "string")) {
		diagnostics.errors.push(`"${field}" bindings must have a string "secret_name" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"binding",
		"store_id",
		"secret_name"
	]);
	return isValid$1;
}, "validateSecretsStoreSecretBinding");
var validateHelloWorldBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"unsafe_hello_world" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings must have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isOptionalProperty(value, "enable_timer", "boolean")) {
		diagnostics.errors.push(`"${field}" bindings must have a boolean "enable_timer" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	validateAdditionalProperties(diagnostics, field, Object.keys(value), ["binding", "enable_timer"]);
	return isValid$1;
}, "validateHelloWorldBinding");
var validateWorkerLoaderBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"worker_loader" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "binding", "string")) {
		diagnostics.errors.push(`"${field}" bindings must have a string "binding" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	validateAdditionalProperties(diagnostics, field, Object.keys(value), ["binding"]);
	return isValid$1;
}, "validateWorkerLoaderBinding");
var validateRateLimitBinding = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (typeof value !== "object" || value === null) {
		diagnostics.errors.push(`"ratelimits" bindings should be objects, but got ${JSON.stringify(value)}`);
		return false;
	}
	let isValid$1 = true;
	if (!isRequiredProperty(value, "name", "string")) {
		diagnostics.errors.push(`"${field}" bindings must have a string "name" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!isRequiredProperty(value, "namespace_id", "string")) {
		diagnostics.errors.push(`"${field}" bindings must have a string "namespace_id" field but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	}
	if (!hasProperty(value, "simple") || typeof value.simple !== "object" || value.simple === null) {
		diagnostics.errors.push(`"${field}" bindings must have a "simple" configuration object but got ${JSON.stringify(value)}.`);
		isValid$1 = false;
	} else {
		if (!isRequiredProperty(value.simple, "limit", "number")) {
			diagnostics.errors.push(`"${field}" bindings "simple.limit" must be a number but got ${JSON.stringify(value.simple)}.`);
			isValid$1 = false;
		}
		if (!isRequiredProperty(value.simple, "period", "number")) {
			diagnostics.errors.push(`"${field}" bindings "simple.period" is required and must be a number but got ${JSON.stringify(value.simple)}.`);
			isValid$1 = false;
		} else if (![10, 60].includes(value.simple.period)) {
			diagnostics.errors.push(`"${field}" bindings "simple.period" must be either 10 or 60 but got ${JSON.stringify(value.simple.period)}.`);
			isValid$1 = false;
		}
		validateAdditionalProperties(diagnostics, `${field}.simple`, Object.keys(value.simple), ["limit", "period"]);
	}
	validateAdditionalProperties(diagnostics, field, Object.keys(value), [
		"name",
		"namespace_id",
		"simple"
	]);
	return isValid$1;
}, "validateRateLimitBinding");
function normalizeAndValidateLimits(diagnostics, topLevelEnv, rawEnv) {
	if (rawEnv.limits) validateRequiredProperty(diagnostics, "limits", "cpu_ms", rawEnv.limits.cpu_ms, "number");
	return inheritable(diagnostics, topLevelEnv, rawEnv, "limits", () => true, void 0);
}
__name(normalizeAndValidateLimits, "normalizeAndValidateLimits");
var validateMigrations = /* @__PURE__ */ __name((diagnostics, field, value) => {
	const rawMigrations = value ?? [];
	if (!Array.isArray(rawMigrations)) {
		diagnostics.errors.push(`The optional "${field}" field should be an array, but got ${JSON.stringify(rawMigrations)}`);
		return false;
	}
	let valid$2 = true;
	for (let i$1 = 0; i$1 < rawMigrations.length; i$1++) {
		const { tag, new_classes, new_sqlite_classes, renamed_classes, deleted_classes, transferred_classes,...rest } = rawMigrations[i$1];
		valid$2 = validateAdditionalProperties(diagnostics, "migrations", Object.keys(rest), []) && valid$2;
		valid$2 = validateRequiredProperty(diagnostics, `migrations[${i$1}]`, `tag`, tag, "string") && valid$2;
		valid$2 = validateOptionalTypedArray(diagnostics, `migrations[${i$1}].new_classes`, new_classes, "string") && valid$2;
		valid$2 = validateOptionalTypedArray(diagnostics, `migrations[${i$1}].new_sqlite_classes`, new_sqlite_classes, "string") && valid$2;
		if (renamed_classes !== void 0) {
			if (!Array.isArray(renamed_classes)) {
				diagnostics.errors.push(`Expected "migrations[${i$1}].renamed_classes" to be an array of "{from: string, to: string}" objects but got ${JSON.stringify(renamed_classes)}.`);
				valid$2 = false;
			} else if (renamed_classes.some((c) => typeof c !== "object" || !isRequiredProperty(c, "from", "string") || !isRequiredProperty(c, "to", "string"))) {
				diagnostics.errors.push(`Expected "migrations[${i$1}].renamed_classes" to be an array of "{from: string, to: string}" objects but got ${JSON.stringify(renamed_classes)}.`);
				valid$2 = false;
			}
		}
		if (transferred_classes !== void 0) {
			if (!Array.isArray(transferred_classes)) {
				diagnostics.errors.push(`Expected "migrations[${i$1}].transferred_classes" to be an array of "{from: string, from_script: string, to: string}" objects but got ${JSON.stringify(transferred_classes)}.`);
				valid$2 = false;
			} else if (transferred_classes.some((c) => typeof c !== "object" || !isRequiredProperty(c, "from", "string") || !isRequiredProperty(c, "from_script", "string") || !isRequiredProperty(c, "to", "string"))) {
				diagnostics.errors.push(`Expected "migrations[${i$1}].transferred_classes" to be an array of "{from: string, from_script: string, to: string}" objects but got ${JSON.stringify(transferred_classes)}.`);
				valid$2 = false;
			}
		}
		valid$2 = validateOptionalTypedArray(diagnostics, `migrations[${i$1}].deleted_classes`, deleted_classes, "string") && valid$2;
	}
	return valid$2;
}, "validateMigrations");
var validateObservability = /* @__PURE__ */ __name((diagnostics, field, value) => {
	if (value === void 0) return true;
	if (typeof value !== "object") {
		diagnostics.errors.push(`"${field}" should be an object but got ${JSON.stringify(value)}.`);
		return false;
	}
	const val = value;
	let isValid$1 = true;
	isValid$1 = validateAtLeastOnePropertyRequired(diagnostics, field, [
		{
			key: "enabled",
			value: val.enabled,
			type: "boolean"
		},
		{
			key: "logs.enabled",
			value: val.logs?.enabled,
			type: "boolean"
		},
		{
			key: "traces.enabled",
			value: val.traces?.enabled,
			type: "boolean"
		}
	]) && isValid$1;
	isValid$1 = validateOptionalProperty(diagnostics, field, "head_sampling_rate", val.head_sampling_rate, "number") && isValid$1;
	isValid$1 = validateOptionalProperty(diagnostics, field, "logs", val.logs, "object") && isValid$1;
	isValid$1 = validateOptionalProperty(diagnostics, field, "traces", val.traces, "object") && isValid$1;
	isValid$1 = validateAdditionalProperties(diagnostics, field, Object.keys(val), [
		"enabled",
		"head_sampling_rate",
		"logs",
		"traces"
	]) && isValid$1;
	if (typeof val.logs === "object") {
		isValid$1 = validateOptionalProperty(diagnostics, field, "logs.enabled", val.logs.enabled, "boolean") && isValid$1;
		isValid$1 = validateOptionalProperty(diagnostics, field, "logs.head_sampling_rate", val.logs.head_sampling_rate, "number") && isValid$1;
		isValid$1 = validateOptionalProperty(diagnostics, field, "logs.invocation_logs", val.logs.invocation_logs, "boolean") && isValid$1;
		isValid$1 = validateOptionalTypedArray(diagnostics, "logs.destinations", val.logs?.destinations, "string") && isValid$1;
		isValid$1 = validateOptionalProperty(diagnostics, field, "logs.persist", val.logs.persist, "boolean") && isValid$1;
		isValid$1 = validateAdditionalProperties(diagnostics, field, Object.keys(val.logs), [
			"enabled",
			"head_sampling_rate",
			"invocation_logs",
			"destinations",
			"persist"
		]) && isValid$1;
	}
	if (typeof val.traces === "object") {
		isValid$1 = validateOptionalProperty(diagnostics, field, "traces.enabled", val.traces.enabled, "boolean") && isValid$1;
		isValid$1 = validateOptionalProperty(diagnostics, field, "traces.head_sampling_rate", val.traces.head_sampling_rate, "number") && isValid$1;
		isValid$1 = validateOptionalTypedArray(diagnostics, "traces.destinations", val.traces?.destinations, "string") && isValid$1;
		isValid$1 = validateOptionalProperty(diagnostics, field, "traces.persist", val.traces.persist, "boolean") && isValid$1;
		isValid$1 = validateAdditionalProperties(diagnostics, field, Object.keys(val.traces), [
			"enabled",
			"head_sampling_rate",
			"destinations",
			"persist"
		]) && isValid$1;
	}
	const samplingRate = val?.head_sampling_rate;
	if (samplingRate && (samplingRate < 0 || samplingRate > 1)) diagnostics.errors.push(`"${field}.head_sampling_rate" must be a value between 0 and 1.`);
	return isValid$1;
}, "validateObservability");
function warnIfDurableObjectsHaveNoMigrations(diagnostics, durableObjects, migrations, configPath) {
	if (Array.isArray(durableObjects.bindings) && durableObjects.bindings.length > 0) {
		const exportedDurableObjects = (durableObjects.bindings || []).filter((binding) => !binding.script_name);
		if (exportedDurableObjects.length > 0 && migrations.length === 0) {
			if (!exportedDurableObjects.some((exportedDurableObject) => typeof exportedDurableObject.class_name !== "string")) {
				const durableObjectClassnames = exportedDurableObjects.map((durable) => durable.class_name);
				diagnostics.warnings.push(dedent`
				In your ${configFileName(configPath)} file, you have configured \`durable_objects\` exported by this Worker (${durableObjectClassnames.join(", ")}), but no \`migrations\` for them. This may not work as expected until you add a \`migrations\` section to your ${configFileName(configPath)} file. Add the following configuration:

				\`\`\`
				${formatConfigSnippet({ migrations: [{
					tag: "v1",
					new_classes: durableObjectClassnames
				}] }, configPath)}
				\`\`\`

				Refer to https://developers.cloudflare.com/durable-objects/reference/durable-objects-migrations/ for more details.`);
			}
		}
	}
}
__name(warnIfDurableObjectsHaveNoMigrations, "warnIfDurableObjectsHaveNoMigrations");
var validatePythonModules = /* @__PURE__ */ __name((diagnostics, field, value, topLevelEnv) => {
	if (value === void 0) return true;
	if (typeof value !== "object" || value === null || Array.isArray(value)) {
		diagnostics.errors.push(`"${field}" should be an object but got ${JSON.stringify(value)}.`);
		return false;
	}
	const val = value;
	if (!("exclude" in val)) return false;
	if (!isStringArray(diagnostics, `${field}.exclude`, val.exclude, topLevelEnv)) return false;
	return true;
}, "validatePythonModules");
function isRemoteValid(targetObject, fieldPath, diagnostics) {
	if (!isOptionalProperty(targetObject, "remote", "boolean")) {
		diagnostics.errors.push(`"${fieldPath}" should, optionally, have a boolean "remote" field but got ${JSON.stringify(targetObject)}.`);
		return false;
	}
	return true;
}
__name(isRemoteValid, "isRemoteValid");
var supportedPagesConfigFields = [
	"pages_build_output_dir",
	"name",
	"compatibility_date",
	"compatibility_flags",
	"send_metrics",
	"no_bundle",
	"limits",
	"placement",
	"vars",
	"durable_objects",
	"kv_namespaces",
	"queues",
	"r2_buckets",
	"d1_databases",
	"vectorize",
	"hyperdrive",
	"services",
	"analytics_engine_datasets",
	"ai",
	"version_metadata",
	"dev",
	"mtls_certificates",
	"browser",
	"upload_source_maps",
	"configPath",
	"userConfigPath",
	"topLevelName",
	"definedEnvironments",
	"targetEnvironment"
];
function validatePagesConfig(config, envNames, projectName) {
	if (!config.pages_build_output_dir) throw new FatalError(`Attempting to validate Pages configuration file, but "pages_build_output_dir" field was not found.
		"pages_build_output_dir" is required for Pages projects.`);
	const diagnostics = new Diagnostics(`Running configuration file validation for Pages:`);
	validateMainField(config, diagnostics);
	validateProjectName(projectName, diagnostics);
	validatePagesEnvironmentNames(envNames, diagnostics);
	validateUnsupportedFields(config, diagnostics);
	validateDurableObjectBinding2(config, diagnostics);
	return diagnostics;
}
__name(validatePagesConfig, "validatePagesConfig");
function validateMainField(config, diagnostics) {
	if (config.main !== void 0) diagnostics.errors.push(`Configuration file cannot contain both both "main" and "pages_build_output_dir" configuration keys.
Please use "main" if you are deploying a Worker, or "pages_build_output_dir" if you are deploying a Pages project.`);
}
__name(validateMainField, "validateMainField");
function validateProjectName(name, diagnostics) {
	if (name === void 0 || name.trim() === "") diagnostics.errors.push(`Missing top-level field "name" in configuration file.
Pages requires the name of your project to be configured at the top-level of your Wrangler configuration file. This is because, in Pages, environments target the same project.`);
}
__name(validateProjectName, "validateProjectName");
function validatePagesEnvironmentNames(envNames, diagnostics) {
	if (!envNames?.length) return;
	const unsupportedPagesEnvNames = envNames.filter((name) => name !== "preview" && name !== "production");
	if (unsupportedPagesEnvNames.length > 0) diagnostics.errors.push(`Configuration file contains the following environment names that are not supported by Pages projects:
${unsupportedPagesEnvNames.map((name) => `"${name}"`).join()}.
The supported named-environments for Pages are "preview" and "production".`);
}
__name(validatePagesEnvironmentNames, "validatePagesEnvironmentNames");
function validateUnsupportedFields(config, diagnostics) {
	const unsupportedFields = new Set(Object.keys(config));
	for (const field of supportedPagesConfigFields) {
		if (field === "queues" && config.queues?.consumers?.length) continue;
		unsupportedFields.delete(field);
	}
	for (const field of unsupportedFields) if (config[field] === void 0 || JSON.stringify(config[field]) === JSON.stringify(defaultWranglerConfig[field])) unsupportedFields.delete(field);
	if (unsupportedFields.size > 0) Array.from(unsupportedFields.keys()).forEach((field) => {
		if (field === "queues" && config.queues?.consumers?.length) diagnostics.errors.push(`Configuration file for Pages projects does not support "queues.consumers"`);
		else diagnostics.errors.push(`Configuration file for Pages projects does not support "${field}"`);
	});
}
__name(validateUnsupportedFields, "validateUnsupportedFields");
function validateDurableObjectBinding2(config, diagnostics) {
	if (config.durable_objects.bindings.length > 0) {
		if (config.durable_objects.bindings.filter((binding) => !isRequiredProperty(binding, "script_name", "string")).length > 0) diagnostics.errors.push(`Durable Objects bindings should specify a "script_name".
Pages requires Durable Object bindings to specify the name of the Worker where the Durable Object is defined.`);
	}
}
__name(validateDurableObjectBinding2, "validateDurableObjectBinding");

//#endregion
//#region src/deploy-config.ts
function getDeployConfigPath(root) {
	return nodePath.resolve(root, ".wrangler", "deploy", "config.json");
}
function getWorkerConfigs(root) {
	const deployConfigPath = getDeployConfigPath(root);
	const deployConfig = JSON.parse(fs$1.readFileSync(deployConfigPath, "utf-8"));
	return [{ configPath: deployConfig.configPath }, ...deployConfig.auxiliaryWorkers].map(({ configPath }) => {
		const resolvedConfigPath = nodePath.resolve(nodePath.dirname(deployConfigPath), configPath);
		return wrangler.unstable_readConfig({ config: resolvedConfigPath });
	});
}
function getRelativePathToWorkerConfig(deployConfigDirectory, root, outputDirectory) {
	return nodePath.relative(deployConfigDirectory, nodePath.resolve(root, outputDirectory, "wrangler.json"));
}
function writeDeployConfig(resolvedPluginConfig, resolvedViteConfig) {
	const deployConfigPath = getDeployConfigPath(resolvedViteConfig.root);
	const deployConfigDirectory = nodePath.dirname(deployConfigPath);
	fs$1.mkdirSync(deployConfigDirectory, { recursive: true });
	if (resolvedPluginConfig.type === "assets-only") {
		const clientOutputDirectory = resolvedViteConfig.environments.client?.build.outDir;
		assert(clientOutputDirectory, "Unexpected error: client environment output directory is undefined");
		const deployConfig = {
			configPath: getRelativePathToWorkerConfig(deployConfigDirectory, resolvedViteConfig.root, clientOutputDirectory),
			auxiliaryWorkers: []
		};
		fs$1.writeFileSync(deployConfigPath, JSON.stringify(deployConfig));
	} else {
		let entryWorkerConfigPath;
		const auxiliaryWorkers = [];
		for (const environmentName of resolvedPluginConfig.environmentNameToWorkerMap.keys()) {
			const outputDirectory = resolvedViteConfig.environments[environmentName]?.build.outDir;
			assert(outputDirectory, `Unexpected error: ${environmentName} environment output directory is undefined`);
			const configPath = getRelativePathToWorkerConfig(deployConfigDirectory, resolvedViteConfig.root, outputDirectory);
			if (environmentName === resolvedPluginConfig.entryWorkerEnvironmentName) entryWorkerConfigPath = configPath;
			else auxiliaryWorkers.push({ configPath });
		}
		assert(entryWorkerConfigPath, `Unexpected error: entryWorkerConfigPath is undefined`);
		const deployConfig = {
			configPath: entryWorkerConfigPath,
			auxiliaryWorkers
		};
		fs$1.writeFileSync(deployConfigPath, JSON.stringify(deployConfig));
	}
}

//#endregion
//#region ../../node_modules/.pnpm/acorn@8.14.0/node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [
	509,
	0,
	227,
	0,
	150,
	4,
	294,
	9,
	1368,
	2,
	2,
	1,
	6,
	3,
	41,
	2,
	5,
	0,
	166,
	1,
	574,
	3,
	9,
	9,
	7,
	9,
	32,
	4,
	318,
	1,
	80,
	3,
	71,
	10,
	50,
	3,
	123,
	2,
	54,
	14,
	32,
	10,
	3,
	1,
	11,
	3,
	46,
	10,
	8,
	0,
	46,
	9,
	7,
	2,
	37,
	13,
	2,
	9,
	6,
	1,
	45,
	0,
	13,
	2,
	49,
	13,
	9,
	3,
	2,
	11,
	83,
	11,
	7,
	0,
	3,
	0,
	158,
	11,
	6,
	9,
	7,
	3,
	56,
	1,
	2,
	6,
	3,
	1,
	3,
	2,
	10,
	0,
	11,
	1,
	3,
	6,
	4,
	4,
	68,
	8,
	2,
	0,
	3,
	0,
	2,
	3,
	2,
	4,
	2,
	0,
	15,
	1,
	83,
	17,
	10,
	9,
	5,
	0,
	82,
	19,
	13,
	9,
	214,
	6,
	3,
	8,
	28,
	1,
	83,
	16,
	16,
	9,
	82,
	12,
	9,
	9,
	7,
	19,
	58,
	14,
	5,
	9,
	243,
	14,
	166,
	9,
	71,
	5,
	2,
	1,
	3,
	3,
	2,
	0,
	2,
	1,
	13,
	9,
	120,
	6,
	3,
	6,
	4,
	0,
	29,
	9,
	41,
	6,
	2,
	3,
	9,
	0,
	10,
	10,
	47,
	15,
	343,
	9,
	54,
	7,
	2,
	7,
	17,
	9,
	57,
	21,
	2,
	13,
	123,
	5,
	4,
	0,
	2,
	1,
	2,
	6,
	2,
	0,
	9,
	9,
	49,
	4,
	2,
	1,
	2,
	4,
	9,
	9,
	330,
	3,
	10,
	1,
	2,
	0,
	49,
	6,
	4,
	4,
	14,
	10,
	5350,
	0,
	7,
	14,
	11465,
	27,
	2343,
	9,
	87,
	9,
	39,
	4,
	60,
	6,
	26,
	9,
	535,
	9,
	470,
	0,
	2,
	54,
	8,
	3,
	82,
	0,
	12,
	1,
	19628,
	1,
	4178,
	9,
	519,
	45,
	3,
	22,
	543,
	4,
	4,
	5,
	9,
	7,
	3,
	6,
	31,
	3,
	149,
	2,
	1418,
	49,
	513,
	54,
	5,
	49,
	9,
	0,
	15,
	0,
	23,
	4,
	2,
	14,
	1361,
	6,
	2,
	16,
	3,
	6,
	2,
	1,
	2,
	4,
	101,
	0,
	161,
	6,
	10,
	9,
	357,
	0,
	62,
	13,
	499,
	13,
	245,
	1,
	2,
	9,
	726,
	6,
	110,
	6,
	6,
	9,
	4759,
	9,
	787719,
	239
];
var astralIdentifierStartCodes = [
	0,
	11,
	2,
	25,
	2,
	18,
	2,
	1,
	2,
	14,
	3,
	13,
	35,
	122,
	70,
	52,
	268,
	28,
	4,
	48,
	48,
	31,
	14,
	29,
	6,
	37,
	11,
	29,
	3,
	35,
	5,
	7,
	2,
	4,
	43,
	157,
	19,
	35,
	5,
	35,
	5,
	39,
	9,
	51,
	13,
	10,
	2,
	14,
	2,
	6,
	2,
	1,
	2,
	10,
	2,
	14,
	2,
	6,
	2,
	1,
	4,
	51,
	13,
	310,
	10,
	21,
	11,
	7,
	25,
	5,
	2,
	41,
	2,
	8,
	70,
	5,
	3,
	0,
	2,
	43,
	2,
	1,
	4,
	0,
	3,
	22,
	11,
	22,
	10,
	30,
	66,
	18,
	2,
	1,
	11,
	21,
	11,
	25,
	71,
	55,
	7,
	1,
	65,
	0,
	16,
	3,
	2,
	2,
	2,
	28,
	43,
	28,
	4,
	28,
	36,
	7,
	2,
	27,
	28,
	53,
	11,
	21,
	11,
	18,
	14,
	17,
	111,
	72,
	56,
	50,
	14,
	50,
	14,
	35,
	39,
	27,
	10,
	22,
	251,
	41,
	7,
	1,
	17,
	2,
	60,
	28,
	11,
	0,
	9,
	21,
	43,
	17,
	47,
	20,
	28,
	22,
	13,
	52,
	58,
	1,
	3,
	0,
	14,
	44,
	33,
	24,
	27,
	35,
	30,
	0,
	3,
	0,
	9,
	34,
	4,
	0,
	13,
	47,
	15,
	3,
	22,
	0,
	2,
	0,
	36,
	17,
	2,
	24,
	20,
	1,
	64,
	6,
	2,
	0,
	2,
	3,
	2,
	14,
	2,
	9,
	8,
	46,
	39,
	7,
	3,
	1,
	3,
	21,
	2,
	6,
	2,
	1,
	2,
	4,
	4,
	0,
	19,
	0,
	13,
	4,
	31,
	9,
	2,
	0,
	3,
	0,
	2,
	37,
	2,
	0,
	26,
	0,
	2,
	0,
	45,
	52,
	19,
	3,
	21,
	2,
	31,
	47,
	21,
	1,
	2,
	0,
	185,
	46,
	42,
	3,
	37,
	47,
	21,
	0,
	60,
	42,
	14,
	0,
	72,
	26,
	38,
	6,
	186,
	43,
	117,
	63,
	32,
	7,
	3,
	0,
	3,
	7,
	2,
	1,
	2,
	23,
	16,
	0,
	2,
	0,
	95,
	7,
	3,
	38,
	17,
	0,
	2,
	0,
	29,
	0,
	11,
	39,
	8,
	0,
	22,
	0,
	12,
	45,
	20,
	0,
	19,
	72,
	200,
	32,
	32,
	8,
	2,
	36,
	18,
	0,
	50,
	29,
	113,
	6,
	2,
	1,
	2,
	37,
	22,
	0,
	26,
	5,
	2,
	1,
	2,
	31,
	15,
	0,
	328,
	18,
	16,
	0,
	2,
	12,
	2,
	33,
	125,
	0,
	80,
	921,
	103,
	110,
	18,
	195,
	2637,
	96,
	16,
	1071,
	18,
	5,
	26,
	3994,
	6,
	582,
	6842,
	29,
	1763,
	568,
	8,
	30,
	18,
	78,
	18,
	29,
	19,
	47,
	17,
	3,
	32,
	20,
	6,
	18,
	433,
	44,
	212,
	63,
	129,
	74,
	6,
	0,
	67,
	12,
	65,
	1,
	2,
	0,
	29,
	6135,
	9,
	1237,
	42,
	9,
	8936,
	3,
	2,
	6,
	2,
	1,
	2,
	290,
	16,
	0,
	30,
	2,
	3,
	0,
	15,
	3,
	9,
	395,
	2309,
	106,
	6,
	12,
	4,
	8,
	8,
	9,
	5991,
	84,
	2,
	70,
	2,
	1,
	3,
	0,
	3,
	1,
	3,
	3,
	2,
	11,
	2,
	0,
	2,
	6,
	2,
	64,
	2,
	3,
	3,
	7,
	2,
	6,
	2,
	27,
	2,
	3,
	2,
	4,
	2,
	0,
	4,
	6,
	2,
	339,
	3,
	24,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	7,
	1845,
	30,
	7,
	5,
	262,
	61,
	147,
	44,
	11,
	6,
	17,
	0,
	322,
	29,
	19,
	43,
	485,
	27,
	229,
	29,
	3,
	0,
	496,
	6,
	2,
	3,
	2,
	1,
	2,
	14,
	2,
	196,
	60,
	67,
	8,
	0,
	1205,
	3,
	2,
	26,
	2,
	1,
	2,
	0,
	3,
	0,
	2,
	9,
	2,
	3,
	2,
	0,
	2,
	0,
	7,
	0,
	5,
	0,
	2,
	0,
	2,
	0,
	2,
	2,
	2,
	1,
	2,
	0,
	3,
	0,
	2,
	0,
	2,
	0,
	2,
	0,
	2,
	0,
	2,
	1,
	2,
	0,
	3,
	3,
	2,
	6,
	2,
	3,
	2,
	3,
	2,
	0,
	2,
	9,
	2,
	16,
	6,
	2,
	2,
	4,
	2,
	16,
	4421,
	42719,
	33,
	4153,
	7,
	221,
	3,
	5761,
	15,
	7472,
	16,
	621,
	2467,
	541,
	1507,
	4938,
	6,
	4191
];
var nonASCIIidentifierChars = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
var nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
var reservedWords = {
	3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
	5: "class enum extends super const export import",
	6: "enum",
	strict: "implements interface let package private protected public static yield",
	strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
	5: ecma5AndLessKeywords,
	"5module": ecma5AndLessKeywords + " export import",
	6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = /* @__PURE__ */ new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = /* @__PURE__ */ new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set) {
	var pos = 65536;
	for (var i$1 = 0; i$1 < set.length; i$1 += 2) {
		pos += set[i$1];
		if (pos > code) return false;
		pos += set[i$1 + 1];
		if (pos >= code) return true;
	}
	return false;
}
function isIdentifierStart(code, astral) {
	if (code < 65) return code === 36;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123) return true;
	if (code <= 65535) return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
	if (astral === false) return false;
	return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
	if (code < 48) return code === 36;
	if (code < 58) return true;
	if (code < 65) return false;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123) return true;
	if (code <= 65535) return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
	if (astral === false) return false;
	return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType$1(label, conf) {
	if (conf === void 0) conf = {};
	this.label = label;
	this.keyword = conf.keyword;
	this.beforeExpr = !!conf.beforeExpr;
	this.startsExpr = !!conf.startsExpr;
	this.isLoop = !!conf.isLoop;
	this.isAssign = !!conf.isAssign;
	this.prefix = !!conf.prefix;
	this.postfix = !!conf.postfix;
	this.binop = conf.binop || null;
	this.updateContext = null;
};
function binop(name, prec) {
	return new TokenType(name, {
		beforeExpr: true,
		binop: prec
	});
}
var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options) {
	if (options === void 0) options = {};
	options.keyword = name;
	return keywords[name] = new TokenType(name, options);
}
var types$1$1 = {
	num: new TokenType("num", startsExpr),
	regexp: new TokenType("regexp", startsExpr),
	string: new TokenType("string", startsExpr),
	name: new TokenType("name", startsExpr),
	privateId: new TokenType("privateId", startsExpr),
	eof: new TokenType("eof"),
	bracketL: new TokenType("[", {
		beforeExpr: true,
		startsExpr: true
	}),
	bracketR: new TokenType("]"),
	braceL: new TokenType("{", {
		beforeExpr: true,
		startsExpr: true
	}),
	braceR: new TokenType("}"),
	parenL: new TokenType("(", {
		beforeExpr: true,
		startsExpr: true
	}),
	parenR: new TokenType(")"),
	comma: new TokenType(",", beforeExpr),
	semi: new TokenType(";", beforeExpr),
	colon: new TokenType(":", beforeExpr),
	dot: new TokenType("."),
	question: new TokenType("?", beforeExpr),
	questionDot: new TokenType("?."),
	arrow: new TokenType("=>", beforeExpr),
	template: new TokenType("template"),
	invalidTemplate: new TokenType("invalidTemplate"),
	ellipsis: new TokenType("...", beforeExpr),
	backQuote: new TokenType("`", startsExpr),
	dollarBraceL: new TokenType("${", {
		beforeExpr: true,
		startsExpr: true
	}),
	eq: new TokenType("=", {
		beforeExpr: true,
		isAssign: true
	}),
	assign: new TokenType("_=", {
		beforeExpr: true,
		isAssign: true
	}),
	incDec: new TokenType("++/--", {
		prefix: true,
		postfix: true,
		startsExpr: true
	}),
	prefix: new TokenType("!/~", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	logicalOR: binop("||", 1),
	logicalAND: binop("&&", 2),
	bitwiseOR: binop("|", 3),
	bitwiseXOR: binop("^", 4),
	bitwiseAND: binop("&", 5),
	equality: binop("==/!=/===/!==", 6),
	relational: binop("</>/<=/>=", 7),
	bitShift: binop("<</>>/>>>", 8),
	plusMin: new TokenType("+/-", {
		beforeExpr: true,
		binop: 9,
		prefix: true,
		startsExpr: true
	}),
	modulo: binop("%", 10),
	star: binop("*", 10),
	slash: binop("/", 10),
	starstar: new TokenType("**", { beforeExpr: true }),
	coalesce: binop("??", 1),
	_break: kw("break"),
	_case: kw("case", beforeExpr),
	_catch: kw("catch"),
	_continue: kw("continue"),
	_debugger: kw("debugger"),
	_default: kw("default", beforeExpr),
	_do: kw("do", {
		isLoop: true,
		beforeExpr: true
	}),
	_else: kw("else", beforeExpr),
	_finally: kw("finally"),
	_for: kw("for", { isLoop: true }),
	_function: kw("function", startsExpr),
	_if: kw("if"),
	_return: kw("return", beforeExpr),
	_switch: kw("switch"),
	_throw: kw("throw", beforeExpr),
	_try: kw("try"),
	_var: kw("var"),
	_const: kw("const"),
	_while: kw("while", { isLoop: true }),
	_with: kw("with"),
	_new: kw("new", {
		beforeExpr: true,
		startsExpr: true
	}),
	_this: kw("this", startsExpr),
	_super: kw("super", startsExpr),
	_class: kw("class", startsExpr),
	_extends: kw("extends", beforeExpr),
	_export: kw("export"),
	_import: kw("import", startsExpr),
	_null: kw("null", startsExpr),
	_true: kw("true", startsExpr),
	_false: kw("false", startsExpr),
	_in: kw("in", {
		beforeExpr: true,
		binop: 7
	}),
	_instanceof: kw("instanceof", {
		beforeExpr: true,
		binop: 7
	}),
	_typeof: kw("typeof", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	_void: kw("void", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	_delete: kw("delete", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	})
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
	return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
	if (end === void 0) end = code.length;
	for (var i$1 = from; i$1 < end; i$1++) {
		var next = code.charCodeAt(i$1);
		if (isNewLine(next)) return i$1 < end - 1 && next === 13 && code.charCodeAt(i$1 + 1) === 10 ? i$1 + 2 : i$1 + 1;
	}
	return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty$2 = ref.hasOwnProperty;
var toString$1 = ref.toString;
var hasOwn = Object.hasOwn || (function(obj, propName) {
	return hasOwnProperty$2.call(obj, propName);
});
var isArray = Array.isArray || (function(obj) {
	return toString$1.call(obj) === "[object Array]";
});
var regexpCache = Object.create(null);
function wordsRegexp(words) {
	return regexpCache[words] || (regexpCache[words] = /* @__PURE__ */ new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code) {
	if (code <= 65535) return String.fromCharCode(code);
	code -= 65536;
	return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position$1(line, col) {
	this.line = line;
	this.column = col;
};
Position.prototype.offset = function offset(n$1) {
	return new Position(this.line, this.column + n$1);
};
var SourceLocation = function SourceLocation$1(p, start, end) {
	this.start = start;
	this.end = end;
	if (p.sourceFile !== null) this.source = p.sourceFile;
};
function getLineInfo(input, offset) {
	for (var line = 1, cur = 0;;) {
		var nextBreak = nextLineBreak(input, cur, offset);
		if (nextBreak < 0) return new Position(line, offset - cur);
		++line;
		cur = nextBreak;
	}
}
var defaultOptions = {
	ecmaVersion: null,
	sourceType: "script",
	onInsertedSemicolon: null,
	onTrailingComma: null,
	allowReserved: null,
	allowReturnOutsideFunction: false,
	allowImportExportEverywhere: false,
	allowAwaitOutsideFunction: null,
	allowSuperOutsideMethod: null,
	allowHashBang: false,
	checkPrivateFields: true,
	locations: false,
	onToken: null,
	onComment: null,
	ranges: false,
	program: null,
	sourceFile: null,
	directSourceFile: null,
	preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
	var options = {};
	for (var opt in defaultOptions) options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
	if (options.ecmaVersion === "latest") options.ecmaVersion = 1e8;
	else if (options.ecmaVersion == null) {
		if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
			warnedAboutEcmaVersion = true;
			console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
		}
		options.ecmaVersion = 11;
	} else if (options.ecmaVersion >= 2015) options.ecmaVersion -= 2009;
	if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;
	if (!opts || opts.allowHashBang == null) options.allowHashBang = options.ecmaVersion >= 14;
	if (isArray(options.onToken)) {
		var tokens = options.onToken;
		options.onToken = function(token) {
			return tokens.push(token);
		};
	}
	if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);
	return options;
}
function pushComment(options, array) {
	return function(block, text, start, end, startLoc, endLoc) {
		var comment = {
			type: block ? "Block" : "Line",
			value: text,
			start,
			end
		};
		if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);
		if (options.ranges) comment.range = [start, end];
		array.push(comment);
	};
}
var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
	return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
var Parser = function Parser$1(options, input, startPos) {
	this.options = options = getOptions(options);
	this.sourceFile = options.sourceFile;
	this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
	var reserved = "";
	if (options.allowReserved !== true) {
		reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
		if (options.sourceType === "module") reserved += " await";
	}
	this.reservedWords = wordsRegexp(reserved);
	var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
	this.reservedWordsStrict = wordsRegexp(reservedStrict);
	this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
	this.input = String(input);
	this.containsEsc = false;
	if (startPos) {
		this.pos = startPos;
		this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
		this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
	} else {
		this.pos = this.lineStart = 0;
		this.curLine = 1;
	}
	this.type = types$1$1.eof;
	this.value = null;
	this.start = this.end = this.pos;
	this.startLoc = this.endLoc = this.curPosition();
	this.lastTokEndLoc = this.lastTokStartLoc = null;
	this.lastTokStart = this.lastTokEnd = this.pos;
	this.context = this.initialContext();
	this.exprAllowed = true;
	this.inModule = options.sourceType === "module";
	this.strict = this.inModule || this.strictDirective(this.pos);
	this.potentialArrowAt = -1;
	this.potentialArrowInForAwait = false;
	this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
	this.labels = [];
	this.undefinedExports = Object.create(null);
	if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
	this.scopeStack = [];
	this.enterScope(SCOPE_TOP);
	this.regexpState = null;
	this.privateNameStack = [];
};
var prototypeAccessors = {
	inFunction: { configurable: true },
	inGenerator: { configurable: true },
	inAsync: { configurable: true },
	canAwait: { configurable: true },
	allowSuper: { configurable: true },
	allowDirectSuper: { configurable: true },
	treatFunctionsAsVar: { configurable: true },
	allowNewDotTarget: { configurable: true },
	inClassStaticBlock: { configurable: true }
};
Parser.prototype.parse = function parse$8() {
	var node = this.options.program || this.startNode();
	this.nextToken();
	return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
	return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
	return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
	return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
	for (var i$1 = this.scopeStack.length - 1; i$1 >= 0; i$1--) {
		var scope = this.scopeStack[i$1];
		if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) return false;
		if (scope.flags & SCOPE_FUNCTION) return (scope.flags & SCOPE_ASYNC) > 0;
	}
	return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
	var ref$1 = this.currentThisScope();
	var flags = ref$1.flags;
	var inClassFieldInit = ref$1.inClassFieldInit;
	return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
	return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
	return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
	var ref$1 = this.currentThisScope();
	var flags = ref$1.flags;
	var inClassFieldInit = ref$1.inClassFieldInit;
	return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
	return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
	var plugins = [], len = arguments.length;
	while (len--) plugins[len] = arguments[len];
	var cls = this;
	for (var i$1 = 0; i$1 < plugins.length; i$1++) cls = plugins[i$1](cls);
	return cls;
};
Parser.parse = function parse$8(input, options) {
	return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
	var parser = new this(options, input, pos);
	parser.nextToken();
	return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
	return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
	if (this.options.ecmaVersion < 5) return false;
	for (;;) {
		skipWhiteSpace.lastIndex = start;
		start += skipWhiteSpace.exec(this.input)[0].length;
		var match = literal.exec(this.input.slice(start));
		if (!match) return false;
		if ((match[1] || match[2]) === "use strict") {
			skipWhiteSpace.lastIndex = start + match[0].length;
			var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
			var next = this.input.charAt(end);
			return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
		}
		start += match[0].length;
		skipWhiteSpace.lastIndex = start;
		start += skipWhiteSpace.exec(this.input)[0].length;
		if (this.input[start] === ";") start++;
	}
};
pp$9.eat = function(type) {
	if (this.type === type) {
		this.next();
		return true;
	} else return false;
};
pp$9.isContextual = function(name) {
	return this.type === types$1$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
	if (!this.isContextual(name)) return false;
	this.next();
	return true;
};
pp$9.expectContextual = function(name) {
	if (!this.eatContextual(name)) this.unexpected();
};
pp$9.canInsertSemicolon = function() {
	return this.type === types$1$1.eof || this.type === types$1$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
	if (this.canInsertSemicolon()) {
		if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
		return true;
	}
};
pp$9.semicolon = function() {
	if (!this.eat(types$1$1.semi) && !this.insertSemicolon()) this.unexpected();
};
pp$9.afterTrailingComma = function(tokType, notNext) {
	if (this.type === tokType) {
		if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
		if (!notNext) this.next();
		return true;
	}
};
pp$9.expect = function(type) {
	this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
	this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors$1() {
	this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
	if (!refDestructuringErrors) return;
	if (refDestructuringErrors.trailingComma > -1) this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
	var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
	if (parens > -1) this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
	if (!refDestructuringErrors) return false;
	var shorthandAssign = refDestructuringErrors.shorthandAssign;
	var doubleProto = refDestructuringErrors.doubleProto;
	if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;
	if (shorthandAssign >= 0) this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
	if (doubleProto >= 0) this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
};
pp$9.checkYieldAwaitInDefaultParams = function() {
	if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) this.raise(this.yieldPos, "Yield expression cannot be a default value");
	if (this.awaitPos) this.raise(this.awaitPos, "Await expression cannot be a default value");
};
pp$9.isSimpleAssignTarget = function(expr) {
	if (expr.type === "ParenthesizedExpression") return this.isSimpleAssignTarget(expr.expression);
	return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
	var exports$1 = Object.create(null);
	if (!node.body) node.body = [];
	while (this.type !== types$1$1.eof) {
		var stmt = this.parseStatement(null, true, exports$1);
		node.body.push(stmt);
	}
	if (this.inModule) for (var i$1 = 0, list$1 = Object.keys(this.undefinedExports); i$1 < list$1.length; i$1 += 1) {
		var name = list$1[i$1];
		this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
	}
	this.adaptDirectivePrologue(node.body);
	this.next();
	node.sourceType = this.options.sourceType;
	return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
	if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
	skipWhiteSpace.lastIndex = this.pos;
	var skip = skipWhiteSpace.exec(this.input);
	var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
	if (nextCh === 91 || nextCh === 92) return true;
	if (context) return false;
	if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) return true;
	if (isIdentifierStart(nextCh, true)) {
		var pos = next + 1;
		while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) ++pos;
		if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) return true;
		var ident = this.input.slice(next, pos);
		if (!keywordRelationalOperator.test(ident)) return true;
	}
	return false;
};
pp$8.isAsyncFunction = function() {
	if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
	skipWhiteSpace.lastIndex = this.pos;
	var skip = skipWhiteSpace.exec(this.input);
	var next = this.pos + skip[0].length, after;
	return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports$1) {
	var starttype = this.type, node = this.startNode(), kind;
	if (this.isLet(context)) {
		starttype = types$1$1._var;
		kind = "let";
	}
	switch (starttype) {
		case types$1$1._break:
		case types$1$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword);
		case types$1$1._debugger: return this.parseDebuggerStatement(node);
		case types$1$1._do: return this.parseDoStatement(node);
		case types$1$1._for: return this.parseForStatement(node);
		case types$1$1._function:
			if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) this.unexpected();
			return this.parseFunctionStatement(node, false, !context);
		case types$1$1._class:
			if (context) this.unexpected();
			return this.parseClass(node, true);
		case types$1$1._if: return this.parseIfStatement(node);
		case types$1$1._return: return this.parseReturnStatement(node);
		case types$1$1._switch: return this.parseSwitchStatement(node);
		case types$1$1._throw: return this.parseThrowStatement(node);
		case types$1$1._try: return this.parseTryStatement(node);
		case types$1$1._const:
		case types$1$1._var:
			kind = kind || this.value;
			if (context && kind !== "var") this.unexpected();
			return this.parseVarStatement(node, kind);
		case types$1$1._while: return this.parseWhileStatement(node);
		case types$1$1._with: return this.parseWithStatement(node);
		case types$1$1.braceL: return this.parseBlock(true, node);
		case types$1$1.semi: return this.parseEmptyStatement(node);
		case types$1$1._export:
		case types$1$1._import:
			if (this.options.ecmaVersion > 10 && starttype === types$1$1._import) {
				skipWhiteSpace.lastIndex = this.pos;
				var skip = skipWhiteSpace.exec(this.input);
				var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
				if (nextCh === 40 || nextCh === 46) return this.parseExpressionStatement(node, this.parseExpression());
			}
			if (!this.options.allowImportExportEverywhere) {
				if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
				if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
			}
			return starttype === types$1$1._import ? this.parseImport(node) : this.parseExport(node, exports$1);
		default:
			if (this.isAsyncFunction()) {
				if (context) this.unexpected();
				this.next();
				return this.parseFunctionStatement(node, true, !context);
			}
			var maybeName = this.value, expr = this.parseExpression();
			if (starttype === types$1$1.name && expr.type === "Identifier" && this.eat(types$1$1.colon)) return this.parseLabeledStatement(node, maybeName, expr, context);
			else return this.parseExpressionStatement(node, expr);
	}
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
	var isBreak = keyword === "break";
	this.next();
	if (this.eat(types$1$1.semi) || this.insertSemicolon()) node.label = null;
	else if (this.type !== types$1$1.name) this.unexpected();
	else {
		node.label = this.parseIdent();
		this.semicolon();
	}
	var i$1 = 0;
	for (; i$1 < this.labels.length; ++i$1) {
		var lab = this.labels[i$1];
		if (node.label == null || lab.name === node.label.name) {
			if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
			if (node.label && isBreak) break;
		}
	}
	if (i$1 === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
	return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
	this.next();
	this.semicolon();
	return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
	this.next();
	this.labels.push(loopLabel);
	node.body = this.parseStatement("do");
	this.labels.pop();
	this.expect(types$1$1._while);
	node.test = this.parseParenExpression();
	if (this.options.ecmaVersion >= 6) this.eat(types$1$1.semi);
	else this.semicolon();
	return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
	this.next();
	var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
	this.labels.push(loopLabel);
	this.enterScope(0);
	this.expect(types$1$1.parenL);
	if (this.type === types$1$1.semi) {
		if (awaitAt > -1) this.unexpected(awaitAt);
		return this.parseFor(node, null);
	}
	var isLet = this.isLet();
	if (this.type === types$1$1._var || this.type === types$1$1._const || isLet) {
		var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
		this.next();
		this.parseVar(init$1, true, kind);
		this.finishNode(init$1, "VariableDeclaration");
		if ((this.type === types$1$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
			if (this.options.ecmaVersion >= 9) if (this.type === types$1$1._in) {
				if (awaitAt > -1) this.unexpected(awaitAt);
			} else node.await = awaitAt > -1;
			return this.parseForIn(node, init$1);
		}
		if (awaitAt > -1) this.unexpected(awaitAt);
		return this.parseFor(node, init$1);
	}
	var startsWithLet = this.isContextual("let"), isForOf = false;
	var containsEsc = this.containsEsc;
	var refDestructuringErrors = new DestructuringErrors();
	var initPos = this.start;
	var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
	if (this.type === types$1$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
		if (awaitAt > -1) {
			if (this.type === types$1$1._in) this.unexpected(awaitAt);
			node.await = true;
		} else if (isForOf && this.options.ecmaVersion >= 8) {
			if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") this.unexpected();
			else if (this.options.ecmaVersion >= 9) node.await = false;
		}
		if (startsWithLet && isForOf) this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
		this.toAssignable(init, false, refDestructuringErrors);
		this.checkLValPattern(init);
		return this.parseForIn(node, init);
	} else this.checkExpressionErrors(refDestructuringErrors, true);
	if (awaitAt > -1) this.unexpected(awaitAt);
	return this.parseFor(node, init);
};
pp$8.parseFunctionStatement = function(node, isAsync$1, declarationPosition) {
	this.next();
	return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync$1);
};
pp$8.parseIfStatement = function(node) {
	this.next();
	node.test = this.parseParenExpression();
	node.consequent = this.parseStatement("if");
	node.alternate = this.eat(types$1$1._else) ? this.parseStatement("if") : null;
	return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
	if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
	this.next();
	if (this.eat(types$1$1.semi) || this.insertSemicolon()) node.argument = null;
	else {
		node.argument = this.parseExpression();
		this.semicolon();
	}
	return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
	this.next();
	node.discriminant = this.parseParenExpression();
	node.cases = [];
	this.expect(types$1$1.braceL);
	this.labels.push(switchLabel);
	this.enterScope(0);
	var cur;
	for (var sawDefault = false; this.type !== types$1$1.braceR;) if (this.type === types$1$1._case || this.type === types$1$1._default) {
		var isCase = this.type === types$1$1._case;
		if (cur) this.finishNode(cur, "SwitchCase");
		node.cases.push(cur = this.startNode());
		cur.consequent = [];
		this.next();
		if (isCase) cur.test = this.parseExpression();
		else {
			if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
			sawDefault = true;
			cur.test = null;
		}
		this.expect(types$1$1.colon);
	} else {
		if (!cur) this.unexpected();
		cur.consequent.push(this.parseStatement(null));
	}
	this.exitScope();
	if (cur) this.finishNode(cur, "SwitchCase");
	this.next();
	this.labels.pop();
	return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
	this.next();
	if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
	node.argument = this.parseExpression();
	this.semicolon();
	return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
	var param = this.parseBindingAtom();
	var simple = param.type === "Identifier";
	this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
	this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
	this.expect(types$1$1.parenR);
	return param;
};
pp$8.parseTryStatement = function(node) {
	this.next();
	node.block = this.parseBlock();
	node.handler = null;
	if (this.type === types$1$1._catch) {
		var clause = this.startNode();
		this.next();
		if (this.eat(types$1$1.parenL)) clause.param = this.parseCatchClauseParam();
		else {
			if (this.options.ecmaVersion < 10) this.unexpected();
			clause.param = null;
			this.enterScope(0);
		}
		clause.body = this.parseBlock(false);
		this.exitScope();
		node.handler = this.finishNode(clause, "CatchClause");
	}
	node.finalizer = this.eat(types$1$1._finally) ? this.parseBlock() : null;
	if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
	return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
	this.next();
	this.parseVar(node, false, kind, allowMissingInitializer);
	this.semicolon();
	return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
	this.next();
	node.test = this.parseParenExpression();
	this.labels.push(loopLabel);
	node.body = this.parseStatement("while");
	this.labels.pop();
	return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
	if (this.strict) this.raise(this.start, "'with' in strict mode");
	this.next();
	node.object = this.parseParenExpression();
	node.body = this.parseStatement("with");
	return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
	this.next();
	return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
	for (var i$1 = 0, list$1 = this.labels; i$1 < list$1.length; i$1 += 1) if (list$1[i$1].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
	var kind = this.type.isLoop ? "loop" : this.type === types$1$1._switch ? "switch" : null;
	for (var i$2 = this.labels.length - 1; i$2 >= 0; i$2--) {
		var label$1 = this.labels[i$2];
		if (label$1.statementStart === node.start) {
			label$1.statementStart = this.start;
			label$1.kind = kind;
		} else break;
	}
	this.labels.push({
		name: maybeName,
		kind,
		statementStart: this.start
	});
	node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
	this.labels.pop();
	node.label = expr;
	return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
	node.expression = expr;
	this.semicolon();
	return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
	if (createNewLexicalScope === void 0) createNewLexicalScope = true;
	if (node === void 0) node = this.startNode();
	node.body = [];
	this.expect(types$1$1.braceL);
	if (createNewLexicalScope) this.enterScope(0);
	while (this.type !== types$1$1.braceR) {
		var stmt = this.parseStatement(null);
		node.body.push(stmt);
	}
	if (exitStrict) this.strict = false;
	this.next();
	if (createNewLexicalScope) this.exitScope();
	return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init) {
	node.init = init;
	this.expect(types$1$1.semi);
	node.test = this.type === types$1$1.semi ? null : this.parseExpression();
	this.expect(types$1$1.semi);
	node.update = this.type === types$1$1.parenR ? null : this.parseExpression();
	this.expect(types$1$1.parenR);
	node.body = this.parseStatement("for");
	this.exitScope();
	this.labels.pop();
	return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init) {
	var isForIn = this.type === types$1$1._in;
	this.next();
	if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
	node.left = init;
	node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
	this.expect(types$1$1.parenR);
	node.body = this.parseStatement("for");
	this.exitScope();
	this.labels.pop();
	return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
	node.declarations = [];
	node.kind = kind;
	for (;;) {
		var decl = this.startNode();
		this.parseVarId(decl, kind);
		if (this.eat(types$1$1.eq)) decl.init = this.parseMaybeAssign(isFor);
		else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) this.unexpected();
		else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1$1._in || this.isContextual("of")))) this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
		else decl.init = null;
		node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
		if (!this.eat(types$1$1.comma)) break;
	}
	return node;
};
pp$8.parseVarId = function(decl, kind) {
	decl.id = this.parseBindingAtom();
	this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync$1, forInit) {
	this.initFunction(node);
	if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync$1) {
		if (this.type === types$1$1.star && statement & FUNC_HANGING_STATEMENT) this.unexpected();
		node.generator = this.eat(types$1$1.star);
	}
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync$1;
	if (statement & FUNC_STATEMENT) {
		node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1$1.name ? null : this.parseIdent();
		if (node.id && !(statement & FUNC_HANGING_STATEMENT)) this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
	}
	var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	this.enterScope(functionFlags(node.async, node.generator));
	if (!(statement & FUNC_STATEMENT)) node.id = this.type === types$1$1.name ? this.parseIdent() : null;
	this.parseFunctionParams(node);
	this.parseFunctionBody(node, allowExpressionBody, false, forInit);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
	this.expect(types$1$1.parenL);
	node.params = this.parseBindingList(types$1$1.parenR, false, this.options.ecmaVersion >= 8);
	this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
	this.next();
	var oldStrict = this.strict;
	this.strict = true;
	this.parseClassId(node, isStatement);
	this.parseClassSuper(node);
	var privateNameMap = this.enterClassBody();
	var classBody = this.startNode();
	var hadConstructor = false;
	classBody.body = [];
	this.expect(types$1$1.braceL);
	while (this.type !== types$1$1.braceR) {
		var element = this.parseClassElement(node.superClass !== null);
		if (element) {
			classBody.body.push(element);
			if (element.type === "MethodDefinition" && element.kind === "constructor") {
				if (hadConstructor) this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
				hadConstructor = true;
			} else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
		}
	}
	this.strict = oldStrict;
	this.next();
	node.body = this.finishNode(classBody, "ClassBody");
	this.exitClassBody();
	return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
	if (this.eat(types$1$1.semi)) return null;
	var ecmaVersion$1 = this.options.ecmaVersion;
	var node = this.startNode();
	var keyName = "";
	var isGenerator = false;
	var isAsync$1 = false;
	var kind = "method";
	var isStatic = false;
	if (this.eatContextual("static")) {
		if (ecmaVersion$1 >= 13 && this.eat(types$1$1.braceL)) {
			this.parseClassStaticBlock(node);
			return node;
		}
		if (this.isClassElementNameStart() || this.type === types$1$1.star) isStatic = true;
		else keyName = "static";
	}
	node.static = isStatic;
	if (!keyName && ecmaVersion$1 >= 8 && this.eatContextual("async")) if ((this.isClassElementNameStart() || this.type === types$1$1.star) && !this.canInsertSemicolon()) isAsync$1 = true;
	else keyName = "async";
	if (!keyName && (ecmaVersion$1 >= 9 || !isAsync$1) && this.eat(types$1$1.star)) isGenerator = true;
	if (!keyName && !isAsync$1 && !isGenerator) {
		var lastValue = this.value;
		if (this.eatContextual("get") || this.eatContextual("set")) if (this.isClassElementNameStart()) kind = lastValue;
		else keyName = lastValue;
	}
	if (keyName) {
		node.computed = false;
		node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
		node.key.name = keyName;
		this.finishNode(node.key, "Identifier");
	} else this.parseClassElementName(node);
	if (ecmaVersion$1 < 13 || this.type === types$1$1.parenL || kind !== "method" || isGenerator || isAsync$1) {
		var isConstructor = !node.static && checkKeyName(node, "constructor");
		var allowsDirectSuper = isConstructor && constructorAllowsSuper;
		if (isConstructor && kind !== "method") this.raise(node.key.start, "Constructor can't have get/set modifier");
		node.kind = isConstructor ? "constructor" : kind;
		this.parseClassMethod(node, isGenerator, isAsync$1, allowsDirectSuper);
	} else this.parseClassField(node);
	return node;
};
pp$8.isClassElementNameStart = function() {
	return this.type === types$1$1.name || this.type === types$1$1.privateId || this.type === types$1$1.num || this.type === types$1$1.string || this.type === types$1$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
	if (this.type === types$1$1.privateId) {
		if (this.value === "constructor") this.raise(this.start, "Classes can't have an element named '#constructor'");
		element.computed = false;
		element.key = this.parsePrivateIdent();
	} else this.parsePropertyName(element);
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync$1, allowsDirectSuper) {
	var key = method.key;
	if (method.kind === "constructor") {
		if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
		if (isAsync$1) this.raise(key.start, "Constructor can't be an async method");
	} else if (method.static && checkKeyName(method, "prototype")) this.raise(key.start, "Classes may not have a static property named prototype");
	var value = method.value = this.parseMethod(isGenerator, isAsync$1, allowsDirectSuper);
	if (method.kind === "get" && value.params.length !== 0) this.raiseRecoverable(value.start, "getter should have no params");
	if (method.kind === "set" && value.params.length !== 1) this.raiseRecoverable(value.start, "setter should have exactly one param");
	if (method.kind === "set" && value.params[0].type === "RestElement") this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
	return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
	if (checkKeyName(field, "constructor")) this.raise(field.key.start, "Classes can't have a field named 'constructor'");
	else if (field.static && checkKeyName(field, "prototype")) this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
	if (this.eat(types$1$1.eq)) {
		var scope = this.currentThisScope();
		var inClassFieldInit = scope.inClassFieldInit;
		scope.inClassFieldInit = true;
		field.value = this.parseMaybeAssign();
		scope.inClassFieldInit = inClassFieldInit;
	} else field.value = null;
	this.semicolon();
	return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
	node.body = [];
	var oldLabels = this.labels;
	this.labels = [];
	this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
	while (this.type !== types$1$1.braceR) {
		var stmt = this.parseStatement(null);
		node.body.push(stmt);
	}
	this.next();
	this.exitScope();
	this.labels = oldLabels;
	return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
	if (this.type === types$1$1.name) {
		node.id = this.parseIdent();
		if (isStatement) this.checkLValSimple(node.id, BIND_LEXICAL, false);
	} else {
		if (isStatement === true) this.unexpected();
		node.id = null;
	}
};
pp$8.parseClassSuper = function(node) {
	node.superClass = this.eat(types$1$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
	var element = {
		declared: Object.create(null),
		used: []
	};
	this.privateNameStack.push(element);
	return element.declared;
};
pp$8.exitClassBody = function() {
	var ref$1 = this.privateNameStack.pop();
	var declared = ref$1.declared;
	var used = ref$1.used;
	if (!this.options.checkPrivateFields) return;
	var len = this.privateNameStack.length;
	var parent = len === 0 ? null : this.privateNameStack[len - 1];
	for (var i$1 = 0; i$1 < used.length; ++i$1) {
		var id = used[i$1];
		if (!hasOwn(declared, id.name)) if (parent) parent.used.push(id);
		else this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
	}
};
function isPrivateNameConflicted(privateNameMap, element) {
	var name = element.key.name;
	var curr = privateNameMap[name];
	var next = "true";
	if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) next = (element.static ? "s" : "i") + element.kind;
	if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
		privateNameMap[name] = "true";
		return false;
	} else if (!curr) {
		privateNameMap[name] = next;
		return false;
	} else return true;
}
function checkKeyName(node, name) {
	var computed = node.computed;
	var key = node.key;
	return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports$1) {
	if (this.options.ecmaVersion >= 11) if (this.eatContextual("as")) {
		node.exported = this.parseModuleExportName();
		this.checkExport(exports$1, node.exported, this.lastTokStart);
	} else node.exported = null;
	this.expectContextual("from");
	if (this.type !== types$1$1.string) this.unexpected();
	node.source = this.parseExprAtom();
	if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
	this.semicolon();
	return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports$1) {
	this.next();
	if (this.eat(types$1$1.star)) return this.parseExportAllDeclaration(node, exports$1);
	if (this.eat(types$1$1._default)) {
		this.checkExport(exports$1, "default", this.lastTokStart);
		node.declaration = this.parseExportDefaultDeclaration();
		return this.finishNode(node, "ExportDefaultDeclaration");
	}
	if (this.shouldParseExportStatement()) {
		node.declaration = this.parseExportDeclaration(node);
		if (node.declaration.type === "VariableDeclaration") this.checkVariableExport(exports$1, node.declaration.declarations);
		else this.checkExport(exports$1, node.declaration.id, node.declaration.id.start);
		node.specifiers = [];
		node.source = null;
	} else {
		node.declaration = null;
		node.specifiers = this.parseExportSpecifiers(exports$1);
		if (this.eatContextual("from")) {
			if (this.type !== types$1$1.string) this.unexpected();
			node.source = this.parseExprAtom();
			if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
		} else {
			for (var i$1 = 0, list$1 = node.specifiers; i$1 < list$1.length; i$1 += 1) {
				var spec = list$1[i$1];
				this.checkUnreserved(spec.local);
				this.checkLocalExport(spec.local);
				if (spec.local.type === "Literal") this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
			}
			node.source = null;
		}
		this.semicolon();
	}
	return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
	return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
	var isAsync$1;
	if (this.type === types$1$1._function || (isAsync$1 = this.isAsyncFunction())) {
		var fNode = this.startNode();
		this.next();
		if (isAsync$1) this.next();
		return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync$1);
	} else if (this.type === types$1$1._class) {
		var cNode = this.startNode();
		return this.parseClass(cNode, "nullableID");
	} else {
		var declaration = this.parseMaybeAssign();
		this.semicolon();
		return declaration;
	}
};
pp$8.checkExport = function(exports$1, name, pos) {
	if (!exports$1) return;
	if (typeof name !== "string") name = name.type === "Identifier" ? name.name : name.value;
	if (hasOwn(exports$1, name)) this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
	exports$1[name] = true;
};
pp$8.checkPatternExport = function(exports$1, pat) {
	var type = pat.type;
	if (type === "Identifier") this.checkExport(exports$1, pat, pat.start);
	else if (type === "ObjectPattern") for (var i$1 = 0, list$1 = pat.properties; i$1 < list$1.length; i$1 += 1) {
		var prop = list$1[i$1];
		this.checkPatternExport(exports$1, prop);
	}
	else if (type === "ArrayPattern") for (var i$1$1 = 0, list$1$1 = pat.elements; i$1$1 < list$1$1.length; i$1$1 += 1) {
		var elt = list$1$1[i$1$1];
		if (elt) this.checkPatternExport(exports$1, elt);
	}
	else if (type === "Property") this.checkPatternExport(exports$1, pat.value);
	else if (type === "AssignmentPattern") this.checkPatternExport(exports$1, pat.left);
	else if (type === "RestElement") this.checkPatternExport(exports$1, pat.argument);
};
pp$8.checkVariableExport = function(exports$1, decls) {
	if (!exports$1) return;
	for (var i$1 = 0, list$1 = decls; i$1 < list$1.length; i$1 += 1) {
		var decl = list$1[i$1];
		this.checkPatternExport(exports$1, decl.id);
	}
};
pp$8.shouldParseExportStatement = function() {
	return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports$1) {
	var node = this.startNode();
	node.local = this.parseModuleExportName();
	node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
	this.checkExport(exports$1, node.exported, node.exported.start);
	return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports$1) {
	var nodes = [], first = true;
	this.expect(types$1$1.braceL);
	while (!this.eat(types$1$1.braceR)) {
		if (!first) {
			this.expect(types$1$1.comma);
			if (this.afterTrailingComma(types$1$1.braceR)) break;
		} else first = false;
		nodes.push(this.parseExportSpecifier(exports$1));
	}
	return nodes;
};
pp$8.parseImport = function(node) {
	this.next();
	if (this.type === types$1$1.string) {
		node.specifiers = empty$1;
		node.source = this.parseExprAtom();
	} else {
		node.specifiers = this.parseImportSpecifiers();
		this.expectContextual("from");
		node.source = this.type === types$1$1.string ? this.parseExprAtom() : this.unexpected();
	}
	if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
	this.semicolon();
	return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
	var node = this.startNode();
	node.imported = this.parseModuleExportName();
	if (this.eatContextual("as")) node.local = this.parseIdent();
	else {
		this.checkUnreserved(node.imported);
		node.local = node.imported;
	}
	this.checkLValSimple(node.local, BIND_LEXICAL);
	return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
	var node = this.startNode();
	node.local = this.parseIdent();
	this.checkLValSimple(node.local, BIND_LEXICAL);
	return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
	var node = this.startNode();
	this.next();
	this.expectContextual("as");
	node.local = this.parseIdent();
	this.checkLValSimple(node.local, BIND_LEXICAL);
	return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
	var nodes = [], first = true;
	if (this.type === types$1$1.name) {
		nodes.push(this.parseImportDefaultSpecifier());
		if (!this.eat(types$1$1.comma)) return nodes;
	}
	if (this.type === types$1$1.star) {
		nodes.push(this.parseImportNamespaceSpecifier());
		return nodes;
	}
	this.expect(types$1$1.braceL);
	while (!this.eat(types$1$1.braceR)) {
		if (!first) {
			this.expect(types$1$1.comma);
			if (this.afterTrailingComma(types$1$1.braceR)) break;
		} else first = false;
		nodes.push(this.parseImportSpecifier());
	}
	return nodes;
};
pp$8.parseWithClause = function() {
	var nodes = [];
	if (!this.eat(types$1$1._with)) return nodes;
	this.expect(types$1$1.braceL);
	var attributeKeys = {};
	var first = true;
	while (!this.eat(types$1$1.braceR)) {
		if (!first) {
			this.expect(types$1$1.comma);
			if (this.afterTrailingComma(types$1$1.braceR)) break;
		} else first = false;
		var attr = this.parseImportAttribute();
		var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
		if (hasOwn(attributeKeys, keyName)) this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
		attributeKeys[keyName] = true;
		nodes.push(attr);
	}
	return nodes;
};
pp$8.parseImportAttribute = function() {
	var node = this.startNode();
	node.key = this.type === types$1$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
	this.expect(types$1$1.colon);
	if (this.type !== types$1$1.string) this.unexpected();
	node.value = this.parseExprAtom();
	return this.finishNode(node, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
	if (this.options.ecmaVersion >= 13 && this.type === types$1$1.string) {
		var stringLiteral = this.parseLiteral(this.value);
		if (loneSurrogate.test(stringLiteral.value)) this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
		return stringLiteral;
	}
	return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
	for (var i$1 = 0; i$1 < statements.length && this.isDirectiveCandidate(statements[i$1]); ++i$1) statements[i$1].directive = statements[i$1].expression.raw.slice(1, -1);
};
pp$8.isDirectiveCandidate = function(statement) {
	return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === "\"" || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
	if (this.options.ecmaVersion >= 6 && node) switch (node.type) {
		case "Identifier":
			if (this.inAsync && node.name === "await") this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
			break;
		case "ObjectPattern":
		case "ArrayPattern":
		case "AssignmentPattern":
		case "RestElement": break;
		case "ObjectExpression":
			node.type = "ObjectPattern";
			if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
			for (var i$1 = 0, list$1 = node.properties; i$1 < list$1.length; i$1 += 1) {
				var prop = list$1[i$1];
				this.toAssignable(prop, isBinding);
				if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) this.raise(prop.argument.start, "Unexpected token");
			}
			break;
		case "Property":
			if (node.kind !== "init") this.raise(node.key.start, "Object pattern can't contain getter or setter");
			this.toAssignable(node.value, isBinding);
			break;
		case "ArrayExpression":
			node.type = "ArrayPattern";
			if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
			this.toAssignableList(node.elements, isBinding);
			break;
		case "SpreadElement":
			node.type = "RestElement";
			this.toAssignable(node.argument, isBinding);
			if (node.argument.type === "AssignmentPattern") this.raise(node.argument.start, "Rest elements cannot have a default value");
			break;
		case "AssignmentExpression":
			if (node.operator !== "=") this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
			node.type = "AssignmentPattern";
			delete node.operator;
			this.toAssignable(node.left, isBinding);
			break;
		case "ParenthesizedExpression":
			this.toAssignable(node.expression, isBinding, refDestructuringErrors);
			break;
		case "ChainExpression":
			this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
			break;
		case "MemberExpression": if (!isBinding) break;
		default: this.raise(node.start, "Assigning to rvalue");
	}
	else if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
	return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
	var end = exprList.length;
	for (var i$1 = 0; i$1 < end; i$1++) {
		var elt = exprList[i$1];
		if (elt) this.toAssignable(elt, isBinding);
	}
	if (end) {
		var last = exprList[end - 1];
		if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
	}
	return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
	var node = this.startNode();
	this.next();
	node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
	return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
	var node = this.startNode();
	this.next();
	if (this.options.ecmaVersion === 6 && this.type !== types$1$1.name) this.unexpected();
	node.argument = this.parseBindingAtom();
	return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
	if (this.options.ecmaVersion >= 6) switch (this.type) {
		case types$1$1.bracketL:
			var node = this.startNode();
			this.next();
			node.elements = this.parseBindingList(types$1$1.bracketR, true, true);
			return this.finishNode(node, "ArrayPattern");
		case types$1$1.braceL: return this.parseObj(true);
	}
	return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
	var elts = [], first = true;
	while (!this.eat(close)) {
		if (first) first = false;
		else this.expect(types$1$1.comma);
		if (allowEmpty && this.type === types$1$1.comma) elts.push(null);
		else if (allowTrailingComma && this.afterTrailingComma(close)) break;
		else if (this.type === types$1$1.ellipsis) {
			var rest = this.parseRestBinding();
			this.parseBindingListItem(rest);
			elts.push(rest);
			if (this.type === types$1$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
			this.expect(close);
			break;
		} else elts.push(this.parseAssignableListItem(allowModifiers));
	}
	return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
	var elem = this.parseMaybeDefault(this.start, this.startLoc);
	this.parseBindingListItem(elem);
	return elem;
};
pp$7.parseBindingListItem = function(param) {
	return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
	left = left || this.parseBindingAtom();
	if (this.options.ecmaVersion < 6 || !this.eat(types$1$1.eq)) return left;
	var node = this.startNodeAt(startPos, startLoc);
	node.left = left;
	node.right = this.parseMaybeAssign();
	return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE;
	var isBind = bindingType !== BIND_NONE;
	switch (expr.type) {
		case "Identifier":
			if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
			if (isBind) {
				if (bindingType === BIND_LEXICAL && expr.name === "let") this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
				if (checkClashes) {
					if (hasOwn(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
					checkClashes[expr.name] = true;
				}
				if (bindingType !== BIND_OUTSIDE) this.declareName(expr.name, bindingType, expr.start);
			}
			break;
		case "ChainExpression":
			this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
			break;
		case "MemberExpression":
			if (isBind) this.raiseRecoverable(expr.start, "Binding member expression");
			break;
		case "ParenthesizedExpression":
			if (isBind) this.raiseRecoverable(expr.start, "Binding parenthesized expression");
			return this.checkLValSimple(expr.expression, bindingType, checkClashes);
		default: this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
	}
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE;
	switch (expr.type) {
		case "ObjectPattern":
			for (var i$1 = 0, list$1 = expr.properties; i$1 < list$1.length; i$1 += 1) {
				var prop = list$1[i$1];
				this.checkLValInnerPattern(prop, bindingType, checkClashes);
			}
			break;
		case "ArrayPattern":
			for (var i$1$1 = 0, list$1$1 = expr.elements; i$1$1 < list$1$1.length; i$1$1 += 1) {
				var elem = list$1$1[i$1$1];
				if (elem) this.checkLValInnerPattern(elem, bindingType, checkClashes);
			}
			break;
		default: this.checkLValSimple(expr, bindingType, checkClashes);
	}
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE;
	switch (expr.type) {
		case "Property":
			this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
			break;
		case "AssignmentPattern":
			this.checkLValPattern(expr.left, bindingType, checkClashes);
			break;
		case "RestElement":
			this.checkLValPattern(expr.argument, bindingType, checkClashes);
			break;
		default: this.checkLValPattern(expr, bindingType, checkClashes);
	}
};
var TokContext = function TokContext$1(token, isExpr, preserveSpace, override, generator) {
	this.token = token;
	this.isExpr = !!isExpr;
	this.preserveSpace = !!preserveSpace;
	this.override = override;
	this.generator = !!generator;
};
var types$2 = {
	b_stat: new TokContext("{", false),
	b_expr: new TokContext("{", true),
	b_tmpl: new TokContext("${", false),
	p_stat: new TokContext("(", false),
	p_expr: new TokContext("(", true),
	q_tmpl: new TokContext("`", true, true, function(p) {
		return p.tryReadTemplateToken();
	}),
	f_stat: new TokContext("function", false),
	f_expr: new TokContext("function", true),
	f_expr_gen: new TokContext("function", true, false, null, true),
	f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
	return [types$2.b_stat];
};
pp$6.curContext = function() {
	return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
	var parent = this.curContext();
	if (parent === types$2.f_expr || parent === types$2.f_stat) return true;
	if (prevType === types$1$1.colon && (parent === types$2.b_stat || parent === types$2.b_expr)) return !parent.isExpr;
	if (prevType === types$1$1._return || prevType === types$1$1.name && this.exprAllowed) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	if (prevType === types$1$1._else || prevType === types$1$1.semi || prevType === types$1$1.eof || prevType === types$1$1.parenR || prevType === types$1$1.arrow) return true;
	if (prevType === types$1$1.braceL) return parent === types$2.b_stat;
	if (prevType === types$1$1._var || prevType === types$1$1._const || prevType === types$1$1.name) return false;
	return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
	for (var i$1 = this.context.length - 1; i$1 >= 1; i$1--) {
		var context = this.context[i$1];
		if (context.token === "function") return context.generator;
	}
	return false;
};
pp$6.updateContext = function(prevType) {
	var update, type = this.type;
	if (type.keyword && prevType === types$1$1.dot) this.exprAllowed = false;
	else if (update = type.updateContext) update.call(this, prevType);
	else this.exprAllowed = type.beforeExpr;
};
pp$6.overrideContext = function(tokenCtx) {
	if (this.curContext() !== tokenCtx) this.context[this.context.length - 1] = tokenCtx;
};
types$1$1.parenR.updateContext = types$1$1.braceR.updateContext = function() {
	if (this.context.length === 1) {
		this.exprAllowed = true;
		return;
	}
	var out = this.context.pop();
	if (out === types$2.b_stat && this.curContext().token === "function") out = this.context.pop();
	this.exprAllowed = !out.isExpr;
};
types$1$1.braceL.updateContext = function(prevType) {
	this.context.push(this.braceIsBlock(prevType) ? types$2.b_stat : types$2.b_expr);
	this.exprAllowed = true;
};
types$1$1.dollarBraceL.updateContext = function() {
	this.context.push(types$2.b_tmpl);
	this.exprAllowed = true;
};
types$1$1.parenL.updateContext = function(prevType) {
	var statementParens = prevType === types$1$1._if || prevType === types$1$1._for || prevType === types$1$1._with || prevType === types$1$1._while;
	this.context.push(statementParens ? types$2.p_stat : types$2.p_expr);
	this.exprAllowed = true;
};
types$1$1.incDec.updateContext = function() {};
types$1$1._function.updateContext = types$1$1._class.updateContext = function(prevType) {
	if (prevType.beforeExpr && prevType !== types$1$1._else && !(prevType === types$1$1.semi && this.curContext() !== types$2.p_stat) && !(prevType === types$1$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1$1.colon || prevType === types$1$1.braceL) && this.curContext() === types$2.b_stat)) this.context.push(types$2.f_expr);
	else this.context.push(types$2.f_stat);
	this.exprAllowed = false;
};
types$1$1.colon.updateContext = function() {
	if (this.curContext().token === "function") this.context.pop();
	this.exprAllowed = true;
};
types$1$1.backQuote.updateContext = function() {
	if (this.curContext() === types$2.q_tmpl) this.context.pop();
	else this.context.push(types$2.q_tmpl);
	this.exprAllowed = false;
};
types$1$1.star.updateContext = function(prevType) {
	if (prevType === types$1$1._function) {
		var index = this.context.length - 1;
		if (this.context[index] === types$2.f_expr) this.context[index] = types$2.f_expr_gen;
		else this.context[index] = types$2.f_gen;
	}
	this.exprAllowed = true;
};
types$1$1.name.updateContext = function(prevType) {
	var allowed = false;
	if (this.options.ecmaVersion >= 6 && prevType !== types$1$1.dot) {
		if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) allowed = true;
	}
	this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
	if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") return;
	if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
	var key = prop.key;
	var name;
	switch (key.type) {
		case "Identifier":
			name = key.name;
			break;
		case "Literal":
			name = String(key.value);
			break;
		default: return;
	}
	var kind = prop.kind;
	if (this.options.ecmaVersion >= 6) {
		if (name === "__proto__" && kind === "init") {
			if (propHash.proto) if (refDestructuringErrors) {
				if (refDestructuringErrors.doubleProto < 0) refDestructuringErrors.doubleProto = key.start;
			} else this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
			propHash.proto = true;
		}
		return;
	}
	name = "$" + name;
	var other = propHash[name];
	if (other) {
		var redefinition;
		if (kind === "init") redefinition = this.strict && other.init || other.get || other.set;
		else redefinition = other.init || other[kind];
		if (redefinition) this.raiseRecoverable(key.start, "Redefinition of property");
	} else other = propHash[name] = {
		init: false,
		get: false,
		set: false
	};
	other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
	if (this.type === types$1$1.comma) {
		var node = this.startNodeAt(startPos, startLoc);
		node.expressions = [expr];
		while (this.eat(types$1$1.comma)) node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
		return this.finishNode(node, "SequenceExpression");
	}
	return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
	if (this.isContextual("yield")) if (this.inGenerator) return this.parseYield(forInit);
	else this.exprAllowed = false;
	var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
	if (refDestructuringErrors) {
		oldParenAssign = refDestructuringErrors.parenthesizedAssign;
		oldTrailingComma = refDestructuringErrors.trailingComma;
		oldDoubleProto = refDestructuringErrors.doubleProto;
		refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
	} else {
		refDestructuringErrors = new DestructuringErrors();
		ownDestructuringErrors = true;
	}
	var startPos = this.start, startLoc = this.startLoc;
	if (this.type === types$1$1.parenL || this.type === types$1$1.name) {
		this.potentialArrowAt = this.start;
		this.potentialArrowInForAwait = forInit === "await";
	}
	var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
	if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
	if (this.type.isAssign) {
		var node = this.startNodeAt(startPos, startLoc);
		node.operator = this.value;
		if (this.type === types$1$1.eq) left = this.toAssignable(left, false, refDestructuringErrors);
		if (!ownDestructuringErrors) refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
		if (refDestructuringErrors.shorthandAssign >= left.start) refDestructuringErrors.shorthandAssign = -1;
		if (this.type === types$1$1.eq) this.checkLValPattern(left);
		else this.checkLValSimple(left);
		node.left = left;
		this.next();
		node.right = this.parseMaybeAssign(forInit);
		if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
		return this.finishNode(node, "AssignmentExpression");
	} else if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
	if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
	if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
	return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseExprOps(forInit, refDestructuringErrors);
	if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	if (this.eat(types$1$1.question)) {
		var node = this.startNodeAt(startPos, startLoc);
		node.test = expr;
		node.consequent = this.parseMaybeAssign();
		this.expect(types$1$1.colon);
		node.alternate = this.parseMaybeAssign(forInit);
		return this.finishNode(node, "ConditionalExpression");
	}
	return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
	if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
	var prec = this.type.binop;
	if (prec != null && (!forInit || this.type !== types$1$1._in)) {
		if (prec > minPrec) {
			var logical = this.type === types$1$1.logicalOR || this.type === types$1$1.logicalAND;
			var coalesce = this.type === types$1$1.coalesce;
			if (coalesce) prec = types$1$1.logicalAND.binop;
			var op = this.value;
			this.next();
			var startPos = this.start, startLoc = this.startLoc;
			var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
			var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
			if (logical && this.type === types$1$1.coalesce || coalesce && (this.type === types$1$1.logicalOR || this.type === types$1$1.logicalAND)) this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
			return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
		}
	}
	return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
	if (right.type === "PrivateIdentifier") this.raise(right.start, "Private identifier can only be left side of binary expression");
	var node = this.startNodeAt(startPos, startLoc);
	node.left = left;
	node.operator = op;
	node.right = right;
	return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
	var startPos = this.start, startLoc = this.startLoc, expr;
	if (this.isContextual("await") && this.canAwait) {
		expr = this.parseAwait(forInit);
		sawUnary = true;
	} else if (this.type.prefix) {
		var node = this.startNode(), update = this.type === types$1$1.incDec;
		node.operator = this.value;
		node.prefix = true;
		this.next();
		node.argument = this.parseMaybeUnary(null, true, update, forInit);
		this.checkExpressionErrors(refDestructuringErrors, true);
		if (update) this.checkLValSimple(node.argument);
		else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
		else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) this.raiseRecoverable(node.start, "Private fields can not be deleted");
		else sawUnary = true;
		expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	} else if (!sawUnary && this.type === types$1$1.privateId) {
		if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) this.unexpected();
		expr = this.parsePrivateIdent();
		if (this.type !== types$1$1._in) this.unexpected();
	} else {
		expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
		if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
		while (this.type.postfix && !this.canInsertSemicolon()) {
			var node$1 = this.startNodeAt(startPos, startLoc);
			node$1.operator = this.value;
			node$1.prefix = false;
			node$1.argument = expr;
			this.checkLValSimple(expr);
			this.next();
			expr = this.finishNode(node$1, "UpdateExpression");
		}
	}
	if (!incDec && this.eat(types$1$1.starstar)) if (sawUnary) this.unexpected(this.lastTokStart);
	else return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
	else return expr;
};
function isLocalVariableAccess(node) {
	return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
	return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseExprAtom(refDestructuringErrors, forInit);
	if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return expr;
	var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
	if (refDestructuringErrors && result.type === "MemberExpression") {
		if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1;
		if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1;
		if (refDestructuringErrors.trailingComma >= result.start) refDestructuringErrors.trailingComma = -1;
	}
	return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
	var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
	var optionalChained = false;
	while (true) {
		var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
		if (element.optional) optionalChained = true;
		if (element === base || element.type === "ArrowFunctionExpression") {
			if (optionalChained) {
				var chainNode = this.startNodeAt(startPos, startLoc);
				chainNode.expression = element;
				element = this.finishNode(chainNode, "ChainExpression");
			}
			return element;
		}
		base = element;
	}
};
pp$5.shouldParseAsyncArrow = function() {
	return !this.canInsertSemicolon() && this.eat(types$1$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
	return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
	var optionalSupported = this.options.ecmaVersion >= 11;
	var optional = optionalSupported && this.eat(types$1$1.questionDot);
	if (noCalls && optional) this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
	var computed = this.eat(types$1$1.bracketL);
	if (computed || optional && this.type !== types$1$1.parenL && this.type !== types$1$1.backQuote || this.eat(types$1$1.dot)) {
		var node = this.startNodeAt(startPos, startLoc);
		node.object = base;
		if (computed) {
			node.property = this.parseExpression();
			this.expect(types$1$1.bracketR);
		} else if (this.type === types$1$1.privateId && base.type !== "Super") node.property = this.parsePrivateIdent();
		else node.property = this.parseIdent(this.options.allowReserved !== "never");
		node.computed = !!computed;
		if (optionalSupported) node.optional = optional;
		base = this.finishNode(node, "MemberExpression");
	} else if (!noCalls && this.eat(types$1$1.parenL)) {
		var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		this.yieldPos = 0;
		this.awaitPos = 0;
		this.awaitIdentPos = 0;
		var exprList = this.parseExprList(types$1$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
		if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
			this.checkPatternErrors(refDestructuringErrors, false);
			this.checkYieldAwaitInDefaultParams();
			if (this.awaitIdentPos > 0) this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
			this.yieldPos = oldYieldPos;
			this.awaitPos = oldAwaitPos;
			this.awaitIdentPos = oldAwaitIdentPos;
			return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
		}
		this.checkExpressionErrors(refDestructuringErrors, true);
		this.yieldPos = oldYieldPos || this.yieldPos;
		this.awaitPos = oldAwaitPos || this.awaitPos;
		this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
		var node$1 = this.startNodeAt(startPos, startLoc);
		node$1.callee = base;
		node$1.arguments = exprList;
		if (optionalSupported) node$1.optional = optional;
		base = this.finishNode(node$1, "CallExpression");
	} else if (this.type === types$1$1.backQuote) {
		if (optional || optionalChained) this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
		var node$2 = this.startNodeAt(startPos, startLoc);
		node$2.tag = base;
		node$2.quasi = this.parseTemplate({ isTagged: true });
		base = this.finishNode(node$2, "TaggedTemplateExpression");
	}
	return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
	if (this.type === types$1$1.slash) this.readRegexp();
	var node, canBeArrow = this.potentialArrowAt === this.start;
	switch (this.type) {
		case types$1$1._super:
			if (!this.allowSuper) this.raise(this.start, "'super' keyword outside a method");
			node = this.startNode();
			this.next();
			if (this.type === types$1$1.parenL && !this.allowDirectSuper) this.raise(node.start, "super() call outside constructor of a subclass");
			if (this.type !== types$1$1.dot && this.type !== types$1$1.bracketL && this.type !== types$1$1.parenL) this.unexpected();
			return this.finishNode(node, "Super");
		case types$1$1._this:
			node = this.startNode();
			this.next();
			return this.finishNode(node, "ThisExpression");
		case types$1$1.name:
			var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
			var id = this.parseIdent(false);
			if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1$1._function)) {
				this.overrideContext(types$2.f_expr);
				return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
			}
			if (canBeArrow && !this.canInsertSemicolon()) {
				if (this.eat(types$1$1.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
				if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
					id = this.parseIdent(false);
					if (this.canInsertSemicolon() || !this.eat(types$1$1.arrow)) this.unexpected();
					return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
				}
			}
			return id;
		case types$1$1.regexp:
			var value = this.value;
			node = this.parseLiteral(value.value);
			node.regex = {
				pattern: value.pattern,
				flags: value.flags
			};
			return node;
		case types$1$1.num:
		case types$1$1.string: return this.parseLiteral(this.value);
		case types$1$1._null:
		case types$1$1._true:
		case types$1$1._false:
			node = this.startNode();
			node.value = this.type === types$1$1._null ? null : this.type === types$1$1._true;
			node.raw = this.type.keyword;
			this.next();
			return this.finishNode(node, "Literal");
		case types$1$1.parenL:
			var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
			if (refDestructuringErrors) {
				if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) refDestructuringErrors.parenthesizedAssign = start;
				if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = start;
			}
			return expr;
		case types$1$1.bracketL:
			node = this.startNode();
			this.next();
			node.elements = this.parseExprList(types$1$1.bracketR, true, true, refDestructuringErrors);
			return this.finishNode(node, "ArrayExpression");
		case types$1$1.braceL:
			this.overrideContext(types$2.b_expr);
			return this.parseObj(false, refDestructuringErrors);
		case types$1$1._function:
			node = this.startNode();
			this.next();
			return this.parseFunction(node, 0);
		case types$1$1._class: return this.parseClass(this.startNode(), false);
		case types$1$1._new: return this.parseNew();
		case types$1$1.backQuote: return this.parseTemplate();
		case types$1$1._import: if (this.options.ecmaVersion >= 11) return this.parseExprImport(forNew);
		else return this.unexpected();
		default: return this.parseExprAtomDefault();
	}
};
pp$5.parseExprAtomDefault = function() {
	this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
	var node = this.startNode();
	if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword import");
	this.next();
	if (this.type === types$1$1.parenL && !forNew) return this.parseDynamicImport(node);
	else if (this.type === types$1$1.dot) {
		var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
		meta.name = "import";
		node.meta = this.finishNode(meta, "Identifier");
		return this.parseImportMeta(node);
	} else this.unexpected();
};
pp$5.parseDynamicImport = function(node) {
	this.next();
	node.source = this.parseMaybeAssign();
	if (this.options.ecmaVersion >= 16) if (!this.eat(types$1$1.parenR)) {
		this.expect(types$1$1.comma);
		if (!this.afterTrailingComma(types$1$1.parenR)) {
			node.options = this.parseMaybeAssign();
			if (!this.eat(types$1$1.parenR)) {
				this.expect(types$1$1.comma);
				if (!this.afterTrailingComma(types$1$1.parenR)) this.unexpected();
			}
		} else node.options = null;
	} else node.options = null;
	else if (!this.eat(types$1$1.parenR)) {
		var errorPos = this.start;
		if (this.eat(types$1$1.comma) && this.eat(types$1$1.parenR)) this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
		else this.unexpected(errorPos);
	}
	return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
	this.next();
	var containsEsc = this.containsEsc;
	node.property = this.parseIdent(true);
	if (node.property.name !== "meta") this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
	if (containsEsc) this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
	if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
	return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
	var node = this.startNode();
	node.value = value;
	node.raw = this.input.slice(this.start, this.end);
	if (node.raw.charCodeAt(node.raw.length - 1) === 110) node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
	this.next();
	return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
	this.expect(types$1$1.parenL);
	var val = this.parseExpression();
	this.expect(types$1$1.parenR);
	return val;
};
pp$5.shouldParseArrow = function(exprList) {
	return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
	var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
	if (this.options.ecmaVersion >= 6) {
		this.next();
		var innerStartPos = this.start, innerStartLoc = this.startLoc;
		var exprList = [], first = true, lastIsComma = false;
		var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
		this.yieldPos = 0;
		this.awaitPos = 0;
		while (this.type !== types$1$1.parenR) {
			first ? first = false : this.expect(types$1$1.comma);
			if (allowTrailingComma && this.afterTrailingComma(types$1$1.parenR, true)) {
				lastIsComma = true;
				break;
			} else if (this.type === types$1$1.ellipsis) {
				spreadStart = this.start;
				exprList.push(this.parseParenItem(this.parseRestBinding()));
				if (this.type === types$1$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
				break;
			} else exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
		}
		var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
		this.expect(types$1$1.parenR);
		if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1$1.arrow)) {
			this.checkPatternErrors(refDestructuringErrors, false);
			this.checkYieldAwaitInDefaultParams();
			this.yieldPos = oldYieldPos;
			this.awaitPos = oldAwaitPos;
			return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
		}
		if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
		if (spreadStart) this.unexpected(spreadStart);
		this.checkExpressionErrors(refDestructuringErrors, true);
		this.yieldPos = oldYieldPos || this.yieldPos;
		this.awaitPos = oldAwaitPos || this.awaitPos;
		if (exprList.length > 1) {
			val = this.startNodeAt(innerStartPos, innerStartLoc);
			val.expressions = exprList;
			this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
		} else val = exprList[0];
	} else val = this.parseParenExpression();
	if (this.options.preserveParens) {
		var par = this.startNodeAt(startPos, startLoc);
		par.expression = val;
		return this.finishNode(par, "ParenthesizedExpression");
	} else return val;
};
pp$5.parseParenItem = function(item) {
	return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
	return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
	if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
	var node = this.startNode();
	this.next();
	if (this.options.ecmaVersion >= 6 && this.type === types$1$1.dot) {
		var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
		meta.name = "new";
		node.meta = this.finishNode(meta, "Identifier");
		this.next();
		var containsEsc = this.containsEsc;
		node.property = this.parseIdent(true);
		if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
		if (containsEsc) this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
		if (!this.allowNewDotTarget) this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
		return this.finishNode(node, "MetaProperty");
	}
	var startPos = this.start, startLoc = this.startLoc;
	node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
	if (this.eat(types$1$1.parenL)) node.arguments = this.parseExprList(types$1$1.parenR, this.options.ecmaVersion >= 8, false);
	else node.arguments = empty;
	return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref$1) {
	var isTagged = ref$1.isTagged;
	var elem = this.startNode();
	if (this.type === types$1$1.invalidTemplate) {
		if (!isTagged) this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
		elem.value = {
			raw: this.value.replace(/\r\n?/g, "\n"),
			cooked: null
		};
	} else elem.value = {
		raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
		cooked: this.value
	};
	this.next();
	elem.tail = this.type === types$1$1.backQuote;
	return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref$1) {
	if (ref$1 === void 0) ref$1 = {};
	var isTagged = ref$1.isTagged;
	if (isTagged === void 0) isTagged = false;
	var node = this.startNode();
	this.next();
	node.expressions = [];
	var curElt = this.parseTemplateElement({ isTagged });
	node.quasis = [curElt];
	while (!curElt.tail) {
		if (this.type === types$1$1.eof) this.raise(this.pos, "Unterminated template literal");
		this.expect(types$1$1.dollarBraceL);
		node.expressions.push(this.parseExpression());
		this.expect(types$1$1.braceR);
		node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
	}
	this.next();
	return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
	return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1$1.name || this.type === types$1$1.num || this.type === types$1$1.string || this.type === types$1$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
	var node = this.startNode(), first = true, propHash = {};
	node.properties = [];
	this.next();
	while (!this.eat(types$1$1.braceR)) {
		if (!first) {
			this.expect(types$1$1.comma);
			if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1$1.braceR)) break;
		} else first = false;
		var prop = this.parseProperty(isPattern, refDestructuringErrors);
		if (!isPattern) this.checkPropClash(prop, propHash, refDestructuringErrors);
		node.properties.push(prop);
	}
	return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
	var prop = this.startNode(), isGenerator, isAsync$1, startPos, startLoc;
	if (this.options.ecmaVersion >= 9 && this.eat(types$1$1.ellipsis)) {
		if (isPattern) {
			prop.argument = this.parseIdent(false);
			if (this.type === types$1$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
			return this.finishNode(prop, "RestElement");
		}
		prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
		if (this.type === types$1$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
		return this.finishNode(prop, "SpreadElement");
	}
	if (this.options.ecmaVersion >= 6) {
		prop.method = false;
		prop.shorthand = false;
		if (isPattern || refDestructuringErrors) {
			startPos = this.start;
			startLoc = this.startLoc;
		}
		if (!isPattern) isGenerator = this.eat(types$1$1.star);
	}
	var containsEsc = this.containsEsc;
	this.parsePropertyName(prop);
	if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
		isAsync$1 = true;
		isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1$1.star);
		this.parsePropertyName(prop);
	} else isAsync$1 = false;
	this.parsePropertyValue(prop, isPattern, isGenerator, isAsync$1, startPos, startLoc, refDestructuringErrors, containsEsc);
	return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
	prop.kind = prop.key.name;
	this.parsePropertyName(prop);
	prop.value = this.parseMethod(false);
	var paramCount = prop.kind === "get" ? 0 : 1;
	if (prop.value.params.length !== paramCount) {
		var start = prop.value.start;
		if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");
		else this.raiseRecoverable(start, "setter should have exactly one param");
	} else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync$1, startPos, startLoc, refDestructuringErrors, containsEsc) {
	if ((isGenerator || isAsync$1) && this.type === types$1$1.colon) this.unexpected();
	if (this.eat(types$1$1.colon)) {
		prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
		prop.kind = "init";
	} else if (this.options.ecmaVersion >= 6 && this.type === types$1$1.parenL) {
		if (isPattern) this.unexpected();
		prop.kind = "init";
		prop.method = true;
		prop.value = this.parseMethod(isGenerator, isAsync$1);
	} else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types$1$1.comma && this.type !== types$1$1.braceR && this.type !== types$1$1.eq) {
		if (isGenerator || isAsync$1) this.unexpected();
		this.parseGetterSetter(prop);
	} else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
		if (isGenerator || isAsync$1) this.unexpected();
		this.checkUnreserved(prop.key);
		if (prop.key.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = startPos;
		prop.kind = "init";
		if (isPattern) prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		else if (this.type === types$1$1.eq && refDestructuringErrors) {
			if (refDestructuringErrors.shorthandAssign < 0) refDestructuringErrors.shorthandAssign = this.start;
			prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		} else prop.value = this.copyNode(prop.key);
		prop.shorthand = true;
	} else this.unexpected();
};
pp$5.parsePropertyName = function(prop) {
	if (this.options.ecmaVersion >= 6) if (this.eat(types$1$1.bracketL)) {
		prop.computed = true;
		prop.key = this.parseMaybeAssign();
		this.expect(types$1$1.bracketR);
		return prop.key;
	} else prop.computed = false;
	return prop.key = this.type === types$1$1.num || this.type === types$1$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
	node.id = null;
	if (this.options.ecmaVersion >= 6) node.generator = node.expression = false;
	if (this.options.ecmaVersion >= 8) node.async = false;
};
pp$5.parseMethod = function(isGenerator, isAsync$1, allowDirectSuper) {
	var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.initFunction(node);
	if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync$1;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	this.enterScope(functionFlags(isAsync$1, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
	this.expect(types$1$1.parenL);
	node.params = this.parseBindingList(types$1$1.parenR, false, this.options.ecmaVersion >= 8);
	this.checkYieldAwaitInDefaultParams();
	this.parseFunctionBody(node, false, true, false);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync$1, forInit) {
	var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.enterScope(functionFlags(isAsync$1, false) | SCOPE_ARROW);
	this.initFunction(node);
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync$1;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	node.params = this.toAssignableList(params, true);
	this.parseFunctionBody(node, true, false, forInit);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
	var isExpression = isArrowFunction && this.type !== types$1$1.braceL;
	var oldStrict = this.strict, useStrict = false;
	if (isExpression) {
		node.body = this.parseMaybeAssign(forInit);
		node.expression = true;
		this.checkParams(node, false);
	} else {
		var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
		if (!oldStrict || nonSimple) {
			useStrict = this.strictDirective(this.end);
			if (useStrict && nonSimple) this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
		}
		var oldLabels = this.labels;
		this.labels = [];
		if (useStrict) this.strict = true;
		this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
		if (this.strict && node.id) this.checkLValSimple(node.id, BIND_OUTSIDE);
		node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
		node.expression = false;
		this.adaptDirectivePrologue(node.body.body);
		this.labels = oldLabels;
	}
	this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
	for (var i$1 = 0, list$1 = params; i$1 < list$1.length; i$1 += 1) if (list$1[i$1].type !== "Identifier") return false;
	return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
	var nameHash = Object.create(null);
	for (var i$1 = 0, list$1 = node.params; i$1 < list$1.length; i$1 += 1) {
		var param = list$1[i$1];
		this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
	}
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
	var elts = [], first = true;
	while (!this.eat(close)) {
		if (!first) {
			this.expect(types$1$1.comma);
			if (allowTrailingComma && this.afterTrailingComma(close)) break;
		} else first = false;
		var elt = void 0;
		if (allowEmpty && this.type === types$1$1.comma) elt = null;
		else if (this.type === types$1$1.ellipsis) {
			elt = this.parseSpread(refDestructuringErrors);
			if (refDestructuringErrors && this.type === types$1$1.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
		} else elt = this.parseMaybeAssign(false, refDestructuringErrors);
		elts.push(elt);
	}
	return elts;
};
pp$5.checkUnreserved = function(ref$1) {
	var start = ref$1.start;
	var end = ref$1.end;
	var name = ref$1.name;
	if (this.inGenerator && name === "yield") this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
	if (this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
	if (this.currentThisScope().inClassFieldInit && name === "arguments") this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
	if (this.inClassStaticBlock && (name === "arguments" || name === "await")) this.raise(start, "Cannot use " + name + " in class static initialization block");
	if (this.keywords.test(name)) this.raise(start, "Unexpected keyword '" + name + "'");
	if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) return;
	if ((this.strict ? this.reservedWordsStrict : this.reservedWords).test(name)) {
		if (!this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
		this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
	}
};
pp$5.parseIdent = function(liberal) {
	var node = this.parseIdentNode();
	this.next(!!liberal);
	this.finishNode(node, "Identifier");
	if (!liberal) {
		this.checkUnreserved(node);
		if (node.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = node.start;
	}
	return node;
};
pp$5.parseIdentNode = function() {
	var node = this.startNode();
	if (this.type === types$1$1.name) node.name = this.value;
	else if (this.type.keyword) {
		node.name = this.type.keyword;
		if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) this.context.pop();
		this.type = types$1$1.name;
	} else this.unexpected();
	return node;
};
pp$5.parsePrivateIdent = function() {
	var node = this.startNode();
	if (this.type === types$1$1.privateId) node.name = this.value;
	else this.unexpected();
	this.next();
	this.finishNode(node, "PrivateIdentifier");
	if (this.options.checkPrivateFields) if (this.privateNameStack.length === 0) this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
	else this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
	return node;
};
pp$5.parseYield = function(forInit) {
	if (!this.yieldPos) this.yieldPos = this.start;
	var node = this.startNode();
	this.next();
	if (this.type === types$1$1.semi || this.canInsertSemicolon() || this.type !== types$1$1.star && !this.type.startsExpr) {
		node.delegate = false;
		node.argument = null;
	} else {
		node.delegate = this.eat(types$1$1.star);
		node.argument = this.parseMaybeAssign(forInit);
	}
	return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
	if (!this.awaitPos) this.awaitPos = this.start;
	var node = this.startNode();
	this.next();
	node.argument = this.parseMaybeUnary(null, true, false, forInit);
	return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
	var loc = getLineInfo(this.input, pos);
	message += " (" + loc.line + ":" + loc.column + ")";
	var err = new SyntaxError(message);
	err.pos = pos;
	err.loc = loc;
	err.raisedAt = this.pos;
	throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
	if (this.options.locations) return new Position(this.curLine, this.pos - this.lineStart);
};
var pp$3 = Parser.prototype;
var Scope = function Scope$1(flags) {
	this.flags = flags;
	this.var = [];
	this.lexical = [];
	this.functions = [];
	this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
	this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
	this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
	return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
	var redeclared = false;
	if (bindingType === BIND_LEXICAL) {
		var scope = this.currentScope();
		redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
		scope.lexical.push(name);
		if (this.inModule && scope.flags & SCOPE_TOP) delete this.undefinedExports[name];
	} else if (bindingType === BIND_SIMPLE_CATCH) this.currentScope().lexical.push(name);
	else if (bindingType === BIND_FUNCTION) {
		var scope$2 = this.currentScope();
		if (this.treatFunctionsAsVar) redeclared = scope$2.lexical.indexOf(name) > -1;
		else redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
		scope$2.functions.push(name);
	} else for (var i$1 = this.scopeStack.length - 1; i$1 >= 0; --i$1) {
		var scope$3 = this.scopeStack[i$1];
		if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
			redeclared = true;
			break;
		}
		scope$3.var.push(name);
		if (this.inModule && scope$3.flags & SCOPE_TOP) delete this.undefinedExports[name];
		if (scope$3.flags & SCOPE_VAR) break;
	}
	if (redeclared) this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
};
pp$3.checkLocalExport = function(id) {
	if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) this.undefinedExports[id.name] = id;
};
pp$3.currentScope = function() {
	return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
	for (var i$1 = this.scopeStack.length - 1;; i$1--) {
		var scope = this.scopeStack[i$1];
		if (scope.flags & SCOPE_VAR) return scope;
	}
};
pp$3.currentThisScope = function() {
	for (var i$1 = this.scopeStack.length - 1;; i$1--) {
		var scope = this.scopeStack[i$1];
		if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) return scope;
	}
};
var Node = function Node$1(parser, pos, loc) {
	this.type = "";
	this.start = pos;
	this.end = 0;
	if (parser.options.locations) this.loc = new SourceLocation(parser, loc);
	if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
	if (parser.options.ranges) this.range = [pos, 0];
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
	return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
	return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
	node.type = type;
	node.end = pos;
	if (this.options.locations) node.loc.end = loc;
	if (this.options.ranges) node.range[1] = pos;
	return node;
}
pp$2.finishNode = function(node, type) {
	return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
	return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
	var newNode = new Node(this, node.start, this.startLoc);
	for (var prop in node) newNode[prop] = node[prop];
	return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
	9: ecma9BinaryProperties,
	10: ecma10BinaryProperties,
	11: ecma11BinaryProperties,
	12: ecma12BinaryProperties,
	13: ecma13BinaryProperties,
	14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
	9: "",
	10: "",
	11: "",
	12: "",
	13: "",
	14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
	9: ecma9ScriptValues,
	10: ecma10ScriptValues,
	11: ecma11ScriptValues,
	12: ecma12ScriptValues,
	13: ecma13ScriptValues,
	14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion$1) {
	var d = data[ecmaVersion$1] = {
		binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion$1] + " " + unicodeGeneralCategoryValues),
		binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion$1]),
		nonBinary: {
			General_Category: wordsRegexp(unicodeGeneralCategoryValues),
			Script: wordsRegexp(unicodeScriptValues[ecmaVersion$1])
		}
	};
	d.nonBinary.Script_Extensions = d.nonBinary.Script;
	d.nonBinary.gc = d.nonBinary.General_Category;
	d.nonBinary.sc = d.nonBinary.Script;
	d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (var i = 0, list = [
	9,
	10,
	11,
	12,
	13,
	14
]; i < list.length; i += 1) {
	var ecmaVersion = list[i];
	buildUnicodeData(ecmaVersion);
}
var pp$1 = Parser.prototype;
var BranchID = function BranchID$1(parent, base) {
	this.parent = parent;
	this.base = base || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
	for (var self = this; self; self = self.parent) for (var other = alt; other; other = other.parent) if (self.base === other.base && self !== other) return true;
	return false;
};
BranchID.prototype.sibling = function sibling() {
	return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState$1(parser) {
	this.parser = parser;
	this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
	this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
	this.source = "";
	this.flags = "";
	this.start = 0;
	this.switchU = false;
	this.switchV = false;
	this.switchN = false;
	this.pos = 0;
	this.lastIntValue = 0;
	this.lastStringValue = "";
	this.lastAssertionIsQuantifiable = false;
	this.numCapturingParens = 0;
	this.maxBackReference = 0;
	this.groupNames = Object.create(null);
	this.backReferenceNames = [];
	this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
	var unicodeSets = flags.indexOf("v") !== -1;
	var unicode = flags.indexOf("u") !== -1;
	this.start = start | 0;
	this.source = pattern + "";
	this.flags = flags;
	if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
		this.switchU = true;
		this.switchV = true;
		this.switchN = true;
	} else {
		this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
		this.switchV = false;
		this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
	}
};
RegExpValidationState.prototype.raise = function raise(message) {
	this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i$1, forceU) {
	if (forceU === void 0) forceU = false;
	var s = this.source;
	var l = s.length;
	if (i$1 >= l) return -1;
	var c = s.charCodeAt(i$1);
	if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i$1 + 1 >= l) return c;
	var next = s.charCodeAt(i$1 + 1);
	return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i$1, forceU) {
	if (forceU === void 0) forceU = false;
	var s = this.source;
	var l = s.length;
	if (i$1 >= l) return l;
	var c = s.charCodeAt(i$1), next;
	if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i$1 + 1 >= l || (next = s.charCodeAt(i$1 + 1)) < 56320 || next > 57343) return i$1 + 1;
	return i$1 + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
	if (forceU === void 0) forceU = false;
	return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
	if (forceU === void 0) forceU = false;
	return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
	if (forceU === void 0) forceU = false;
	this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
	if (forceU === void 0) forceU = false;
	if (this.current(forceU) === ch) {
		this.advance(forceU);
		return true;
	}
	return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
	if (forceU === void 0) forceU = false;
	var pos = this.pos;
	for (var i$1 = 0, list$1 = chs; i$1 < list$1.length; i$1 += 1) {
		var ch = list$1[i$1];
		var current = this.at(pos, forceU);
		if (current === -1 || current !== ch) return false;
		pos = this.nextIndex(pos, forceU);
	}
	this.pos = pos;
	return true;
};
/**
* Validate the flags part of a given RegExpLiteral.
*
* @param {RegExpValidationState} state The state to validate RegExp.
* @returns {void}
*/
pp$1.validateRegExpFlags = function(state) {
	var validFlags = state.validFlags;
	var flags = state.flags;
	var u = false;
	var v = false;
	for (var i$1 = 0; i$1 < flags.length; i$1++) {
		var flag = flags.charAt(i$1);
		if (validFlags.indexOf(flag) === -1) this.raise(state.start, "Invalid regular expression flag");
		if (flags.indexOf(flag, i$1 + 1) > -1) this.raise(state.start, "Duplicate regular expression flag");
		if (flag === "u") u = true;
		if (flag === "v") v = true;
	}
	if (this.options.ecmaVersion >= 15 && u && v) this.raise(state.start, "Invalid regular expression flag");
};
function hasProp(obj) {
	for (var _ in obj) return true;
	return false;
}
/**
* Validate the pattern part of a given RegExpLiteral.
*
* @param {RegExpValidationState} state The state to validate RegExp.
* @returns {void}
*/
pp$1.validateRegExpPattern = function(state) {
	this.regexp_pattern(state);
	if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
		state.switchN = true;
		this.regexp_pattern(state);
	}
};
pp$1.regexp_pattern = function(state) {
	state.pos = 0;
	state.lastIntValue = 0;
	state.lastStringValue = "";
	state.lastAssertionIsQuantifiable = false;
	state.numCapturingParens = 0;
	state.maxBackReference = 0;
	state.groupNames = Object.create(null);
	state.backReferenceNames.length = 0;
	state.branchID = null;
	this.regexp_disjunction(state);
	if (state.pos !== state.source.length) {
		if (state.eat(41)) state.raise("Unmatched ')'");
		if (state.eat(93) || state.eat(125)) state.raise("Lone quantifier brackets");
	}
	if (state.maxBackReference > state.numCapturingParens) state.raise("Invalid escape");
	for (var i$1 = 0, list$1 = state.backReferenceNames; i$1 < list$1.length; i$1 += 1) {
		var name = list$1[i$1];
		if (!state.groupNames[name]) state.raise("Invalid named capture referenced");
	}
};
pp$1.regexp_disjunction = function(state) {
	var trackDisjunction = this.options.ecmaVersion >= 16;
	if (trackDisjunction) state.branchID = new BranchID(state.branchID, null);
	this.regexp_alternative(state);
	while (state.eat(124)) {
		if (trackDisjunction) state.branchID = state.branchID.sibling();
		this.regexp_alternative(state);
	}
	if (trackDisjunction) state.branchID = state.branchID.parent;
	if (this.regexp_eatQuantifier(state, true)) state.raise("Nothing to repeat");
	if (state.eat(123)) state.raise("Lone quantifier brackets");
};
pp$1.regexp_alternative = function(state) {
	while (state.pos < state.source.length && this.regexp_eatTerm(state));
};
pp$1.regexp_eatTerm = function(state) {
	if (this.regexp_eatAssertion(state)) {
		if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
			if (state.switchU) state.raise("Invalid quantifier");
		}
		return true;
	}
	if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
		this.regexp_eatQuantifier(state);
		return true;
	}
	return false;
};
pp$1.regexp_eatAssertion = function(state) {
	var start = state.pos;
	state.lastAssertionIsQuantifiable = false;
	if (state.eat(94) || state.eat(36)) return true;
	if (state.eat(92)) {
		if (state.eat(66) || state.eat(98)) return true;
		state.pos = start;
	}
	if (state.eat(40) && state.eat(63)) {
		var lookbehind = false;
		if (this.options.ecmaVersion >= 9) lookbehind = state.eat(60);
		if (state.eat(61) || state.eat(33)) {
			this.regexp_disjunction(state);
			if (!state.eat(41)) state.raise("Unterminated group");
			state.lastAssertionIsQuantifiable = !lookbehind;
			return true;
		}
	}
	state.pos = start;
	return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
	if (noError === void 0) noError = false;
	if (this.regexp_eatQuantifierPrefix(state, noError)) {
		state.eat(63);
		return true;
	}
	return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
	return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
	var start = state.pos;
	if (state.eat(123)) {
		var min = 0, max = -1;
		if (this.regexp_eatDecimalDigits(state)) {
			min = state.lastIntValue;
			if (state.eat(44) && this.regexp_eatDecimalDigits(state)) max = state.lastIntValue;
			if (state.eat(125)) {
				if (max !== -1 && max < min && !noError) state.raise("numbers out of order in {} quantifier");
				return true;
			}
		}
		if (state.switchU && !noError) state.raise("Incomplete quantifier");
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatAtom = function(state) {
	return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
	var start = state.pos;
	if (state.eat(92)) {
		if (this.regexp_eatAtomEscape(state)) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
	var start = state.pos;
	if (state.eat(40)) {
		if (state.eat(63)) {
			if (this.options.ecmaVersion >= 16) {
				var addModifiers = this.regexp_eatModifiers(state);
				var hasHyphen = state.eat(45);
				if (addModifiers || hasHyphen) {
					for (var i$1 = 0; i$1 < addModifiers.length; i$1++) {
						var modifier = addModifiers.charAt(i$1);
						if (addModifiers.indexOf(modifier, i$1 + 1) > -1) state.raise("Duplicate regular expression modifiers");
					}
					if (hasHyphen) {
						var removeModifiers = this.regexp_eatModifiers(state);
						if (!addModifiers && !removeModifiers && state.current() === 58) state.raise("Invalid regular expression modifiers");
						for (var i$1$1 = 0; i$1$1 < removeModifiers.length; i$1$1++) {
							var modifier$1 = removeModifiers.charAt(i$1$1);
							if (removeModifiers.indexOf(modifier$1, i$1$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) state.raise("Duplicate regular expression modifiers");
						}
					}
				}
			}
			if (state.eat(58)) {
				this.regexp_disjunction(state);
				if (state.eat(41)) return true;
				state.raise("Unterminated group");
			}
		}
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
	if (state.eat(40)) {
		if (this.options.ecmaVersion >= 9) this.regexp_groupSpecifier(state);
		else if (state.current() === 63) state.raise("Invalid group");
		this.regexp_disjunction(state);
		if (state.eat(41)) {
			state.numCapturingParens += 1;
			return true;
		}
		state.raise("Unterminated group");
	}
	return false;
};
pp$1.regexp_eatModifiers = function(state) {
	var modifiers = "";
	var ch = 0;
	while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
		modifiers += codePointToString(ch);
		state.advance();
	}
	return modifiers;
};
function isRegularExpressionModifier(ch) {
	return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
	return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
	if (this.regexp_eatBracedQuantifier(state, true)) state.raise("Nothing to repeat");
	return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
	var ch = state.current();
	if (isSyntaxCharacter(ch)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
function isSyntaxCharacter(ch) {
	return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
	var start = state.pos;
	var ch = 0;
	while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) state.advance();
	return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
	var ch = state.current();
	if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_groupSpecifier = function(state) {
	if (state.eat(63)) {
		if (!this.regexp_eatGroupName(state)) state.raise("Invalid group");
		var trackDisjunction = this.options.ecmaVersion >= 16;
		var known = state.groupNames[state.lastStringValue];
		if (known) if (trackDisjunction) {
			for (var i$1 = 0, list$1 = known; i$1 < list$1.length; i$1 += 1) if (!list$1[i$1].separatedFrom(state.branchID)) state.raise("Duplicate capture group name");
		} else state.raise("Duplicate capture group name");
		if (trackDisjunction) (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
		else state.groupNames[state.lastStringValue] = true;
	}
};
pp$1.regexp_eatGroupName = function(state) {
	state.lastStringValue = "";
	if (state.eat(60)) {
		if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) return true;
		state.raise("Invalid capture group name");
	}
	return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
	state.lastStringValue = "";
	if (this.regexp_eatRegExpIdentifierStart(state)) {
		state.lastStringValue += codePointToString(state.lastIntValue);
		while (this.regexp_eatRegExpIdentifierPart(state)) state.lastStringValue += codePointToString(state.lastIntValue);
		return true;
	}
	return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
	var start = state.pos;
	var forceU = this.options.ecmaVersion >= 11;
	var ch = state.current(forceU);
	state.advance(forceU);
	if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
	if (isRegExpIdentifierStart(ch)) {
		state.lastIntValue = ch;
		return true;
	}
	state.pos = start;
	return false;
};
function isRegExpIdentifierStart(ch) {
	return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
	var start = state.pos;
	var forceU = this.options.ecmaVersion >= 11;
	var ch = state.current(forceU);
	state.advance(forceU);
	if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
	if (isRegExpIdentifierPart(ch)) {
		state.lastIntValue = ch;
		return true;
	}
	state.pos = start;
	return false;
};
function isRegExpIdentifierPart(ch) {
	return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
	if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) return true;
	if (state.switchU) {
		if (state.current() === 99) state.raise("Invalid unicode escape");
		state.raise("Invalid escape");
	}
	return false;
};
pp$1.regexp_eatBackReference = function(state) {
	var start = state.pos;
	if (this.regexp_eatDecimalEscape(state)) {
		var n$1 = state.lastIntValue;
		if (state.switchU) {
			if (n$1 > state.maxBackReference) state.maxBackReference = n$1;
			return true;
		}
		if (n$1 <= state.numCapturingParens) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatKGroupName = function(state) {
	if (state.eat(107)) {
		if (this.regexp_eatGroupName(state)) {
			state.backReferenceNames.push(state.lastStringValue);
			return true;
		}
		state.raise("Invalid named reference");
	}
	return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
	return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
	var start = state.pos;
	if (state.eat(99)) {
		if (this.regexp_eatControlLetter(state)) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatZero = function(state) {
	if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
		state.lastIntValue = 0;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatControlEscape = function(state) {
	var ch = state.current();
	if (ch === 116) {
		state.lastIntValue = 9;
		state.advance();
		return true;
	}
	if (ch === 110) {
		state.lastIntValue = 10;
		state.advance();
		return true;
	}
	if (ch === 118) {
		state.lastIntValue = 11;
		state.advance();
		return true;
	}
	if (ch === 102) {
		state.lastIntValue = 12;
		state.advance();
		return true;
	}
	if (ch === 114) {
		state.lastIntValue = 13;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatControlLetter = function(state) {
	var ch = state.current();
	if (isControlLetter(ch)) {
		state.lastIntValue = ch % 32;
		state.advance();
		return true;
	}
	return false;
};
function isControlLetter(ch) {
	return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
	if (forceU === void 0) forceU = false;
	var start = state.pos;
	var switchU = forceU || state.switchU;
	if (state.eat(117)) {
		if (this.regexp_eatFixedHexDigits(state, 4)) {
			var lead = state.lastIntValue;
			if (switchU && lead >= 55296 && lead <= 56319) {
				var leadSurrogateEnd = state.pos;
				if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
					var trail = state.lastIntValue;
					if (trail >= 56320 && trail <= 57343) {
						state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
						return true;
					}
				}
				state.pos = leadSurrogateEnd;
				state.lastIntValue = lead;
			}
			return true;
		}
		if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) return true;
		if (switchU) state.raise("Invalid unicode escape");
		state.pos = start;
	}
	return false;
};
function isValidUnicode(ch) {
	return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
	if (state.switchU) {
		if (this.regexp_eatSyntaxCharacter(state)) return true;
		if (state.eat(47)) {
			state.lastIntValue = 47;
			return true;
		}
		return false;
	}
	var ch = state.current();
	if (ch !== 99 && (!state.switchN || ch !== 107)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
	state.lastIntValue = 0;
	var ch = state.current();
	if (ch >= 49 && ch <= 57) {
		do {
			state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
			state.advance();
		} while ((ch = state.current()) >= 48 && ch <= 57);
		return true;
	}
	return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
	var ch = state.current();
	if (isCharacterClassEscape(ch)) {
		state.lastIntValue = -1;
		state.advance();
		return CharSetOk;
	}
	var negate = false;
	if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
		state.lastIntValue = -1;
		state.advance();
		var result;
		if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
			if (negate && result === CharSetString) state.raise("Invalid property name");
			return result;
		}
		state.raise("Invalid property name");
	}
	return CharSetNone;
};
function isCharacterClassEscape(ch) {
	return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
	var start = state.pos;
	if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
		var name = state.lastStringValue;
		if (this.regexp_eatUnicodePropertyValue(state)) {
			var value = state.lastStringValue;
			this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
			return CharSetOk;
		}
	}
	state.pos = start;
	if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
		var nameOrValue = state.lastStringValue;
		return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
	}
	return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
	if (!hasOwn(state.unicodeProperties.nonBinary, name)) state.raise("Invalid property name");
	if (!state.unicodeProperties.nonBinary[name].test(value)) state.raise("Invalid property value");
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
	if (state.unicodeProperties.binary.test(nameOrValue)) return CharSetOk;
	if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) return CharSetString;
	state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
	var ch = 0;
	state.lastStringValue = "";
	while (isUnicodePropertyNameCharacter(ch = state.current())) {
		state.lastStringValue += codePointToString(ch);
		state.advance();
	}
	return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
	return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
	var ch = 0;
	state.lastStringValue = "";
	while (isUnicodePropertyValueCharacter(ch = state.current())) {
		state.lastStringValue += codePointToString(ch);
		state.advance();
	}
	return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
	return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
	return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
	if (state.eat(91)) {
		var negate = state.eat(94);
		var result = this.regexp_classContents(state);
		if (!state.eat(93)) state.raise("Unterminated character class");
		if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
		return true;
	}
	return false;
};
pp$1.regexp_classContents = function(state) {
	if (state.current() === 93) return CharSetOk;
	if (state.switchV) return this.regexp_classSetExpression(state);
	this.regexp_nonEmptyClassRanges(state);
	return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
	while (this.regexp_eatClassAtom(state)) {
		var left = state.lastIntValue;
		if (state.eat(45) && this.regexp_eatClassAtom(state)) {
			var right = state.lastIntValue;
			if (state.switchU && (left === -1 || right === -1)) state.raise("Invalid character class");
			if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
		}
	}
};
pp$1.regexp_eatClassAtom = function(state) {
	var start = state.pos;
	if (state.eat(92)) {
		if (this.regexp_eatClassEscape(state)) return true;
		if (state.switchU) {
			var ch$1 = state.current();
			if (ch$1 === 99 || isOctalDigit(ch$1)) state.raise("Invalid class escape");
			state.raise("Invalid escape");
		}
		state.pos = start;
	}
	var ch = state.current();
	if (ch !== 93) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatClassEscape = function(state) {
	var start = state.pos;
	if (state.eat(98)) {
		state.lastIntValue = 8;
		return true;
	}
	if (state.switchU && state.eat(45)) {
		state.lastIntValue = 45;
		return true;
	}
	if (!state.switchU && state.eat(99)) {
		if (this.regexp_eatClassControlLetter(state)) return true;
		state.pos = start;
	}
	return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
	var result = CharSetOk, subResult;
	if (this.regexp_eatClassSetRange(state));
	else if (subResult = this.regexp_eatClassSetOperand(state)) {
		if (subResult === CharSetString) result = CharSetString;
		var start = state.pos;
		while (state.eatChars([38, 38])) {
			if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
				if (subResult !== CharSetString) result = CharSetOk;
				continue;
			}
			state.raise("Invalid character in character class");
		}
		if (start !== state.pos) return result;
		while (state.eatChars([45, 45])) {
			if (this.regexp_eatClassSetOperand(state)) continue;
			state.raise("Invalid character in character class");
		}
		if (start !== state.pos) return result;
	} else state.raise("Invalid character in character class");
	for (;;) {
		if (this.regexp_eatClassSetRange(state)) continue;
		subResult = this.regexp_eatClassSetOperand(state);
		if (!subResult) return result;
		if (subResult === CharSetString) result = CharSetString;
	}
};
pp$1.regexp_eatClassSetRange = function(state) {
	var start = state.pos;
	if (this.regexp_eatClassSetCharacter(state)) {
		var left = state.lastIntValue;
		if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
			var right = state.lastIntValue;
			if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
			return true;
		}
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
	if (this.regexp_eatClassSetCharacter(state)) return CharSetOk;
	return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
	var start = state.pos;
	if (state.eat(91)) {
		var negate = state.eat(94);
		var result = this.regexp_classContents(state);
		if (state.eat(93)) {
			if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
			return result;
		}
		state.pos = start;
	}
	if (state.eat(92)) {
		var result$1 = this.regexp_eatCharacterClassEscape(state);
		if (result$1) return result$1;
		state.pos = start;
	}
	return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
	var start = state.pos;
	if (state.eatChars([92, 113])) {
		if (state.eat(123)) {
			var result = this.regexp_classStringDisjunctionContents(state);
			if (state.eat(125)) return result;
		} else state.raise("Invalid escape");
		state.pos = start;
	}
	return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
	var result = this.regexp_classString(state);
	while (state.eat(124)) if (this.regexp_classString(state) === CharSetString) result = CharSetString;
	return result;
};
pp$1.regexp_classString = function(state) {
	var count = 0;
	while (this.regexp_eatClassSetCharacter(state)) count++;
	return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
	var start = state.pos;
	if (state.eat(92)) {
		if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) return true;
		if (state.eat(98)) {
			state.lastIntValue = 8;
			return true;
		}
		state.pos = start;
		return false;
	}
	var ch = state.current();
	if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) return false;
	if (isClassSetSyntaxCharacter(ch)) return false;
	state.advance();
	state.lastIntValue = ch;
	return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
	return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
	return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
	var ch = state.current();
	if (isClassSetReservedPunctuator(ch)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
function isClassSetReservedPunctuator(ch) {
	return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
	var ch = state.current();
	if (isDecimalDigit(ch) || ch === 95) {
		state.lastIntValue = ch % 32;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
	var start = state.pos;
	if (state.eat(120)) {
		if (this.regexp_eatFixedHexDigits(state, 2)) return true;
		if (state.switchU) state.raise("Invalid escape");
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
	var start = state.pos;
	var ch = 0;
	state.lastIntValue = 0;
	while (isDecimalDigit(ch = state.current())) {
		state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
		state.advance();
	}
	return state.pos !== start;
};
function isDecimalDigit(ch) {
	return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
	var start = state.pos;
	var ch = 0;
	state.lastIntValue = 0;
	while (isHexDigit(ch = state.current())) {
		state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		state.advance();
	}
	return state.pos !== start;
};
function isHexDigit(ch) {
	return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
	if (ch >= 65 && ch <= 70) return 10 + (ch - 65);
	if (ch >= 97 && ch <= 102) return 10 + (ch - 97);
	return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
	if (this.regexp_eatOctalDigit(state)) {
		var n1 = state.lastIntValue;
		if (this.regexp_eatOctalDigit(state)) {
			var n2 = state.lastIntValue;
			if (n1 <= 3 && this.regexp_eatOctalDigit(state)) state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
			else state.lastIntValue = n1 * 8 + n2;
		} else state.lastIntValue = n1;
		return true;
	}
	return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
	var ch = state.current();
	if (isOctalDigit(ch)) {
		state.lastIntValue = ch - 48;
		state.advance();
		return true;
	}
	state.lastIntValue = 0;
	return false;
};
function isOctalDigit(ch) {
	return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
	var start = state.pos;
	state.lastIntValue = 0;
	for (var i$1 = 0; i$1 < length; ++i$1) {
		var ch = state.current();
		if (!isHexDigit(ch)) {
			state.pos = start;
			return false;
		}
		state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		state.advance();
	}
	return true;
};
var Token = function Token$1(p) {
	this.type = p.type;
	this.value = p.value;
	this.start = p.start;
	this.end = p.end;
	if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
	if (p.options.ranges) this.range = [p.start, p.end];
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
	if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
	if (this.options.onToken) this.options.onToken(new Token(this));
	this.lastTokEnd = this.end;
	this.lastTokStart = this.start;
	this.lastTokEndLoc = this.endLoc;
	this.lastTokStartLoc = this.startLoc;
	this.nextToken();
};
pp.getToken = function() {
	this.next();
	return new Token(this);
};
if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function() {
	var this$1$1 = this;
	return { next: function() {
		var token = this$1$1.getToken();
		return {
			done: token.type === types$1$1.eof,
			value: token
		};
	} };
};
pp.nextToken = function() {
	var curContext = this.curContext();
	if (!curContext || !curContext.preserveSpace) this.skipSpace();
	this.start = this.pos;
	if (this.options.locations) this.startLoc = this.curPosition();
	if (this.pos >= this.input.length) return this.finishToken(types$1$1.eof);
	if (curContext.override) return curContext.override(this);
	else this.readToken(this.fullCharCodeAtPos());
};
pp.readToken = function(code) {
	if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) return this.readWord();
	return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
	var code = this.input.charCodeAt(this.pos);
	if (code <= 55295 || code >= 56320) return code;
	var next = this.input.charCodeAt(this.pos + 1);
	return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
	var startLoc = this.options.onComment && this.curPosition();
	var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
	if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
	this.pos = end + 2;
	if (this.options.locations) for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
		++this.curLine;
		pos = this.lineStart = nextBreak;
	}
	if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};
pp.skipLineComment = function(startSkip) {
	var start = this.pos;
	var startLoc = this.options.onComment && this.curPosition();
	var ch = this.input.charCodeAt(this.pos += startSkip);
	while (this.pos < this.input.length && !isNewLine(ch)) ch = this.input.charCodeAt(++this.pos);
	if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};
pp.skipSpace = function() {
	loop: while (this.pos < this.input.length) {
		var ch = this.input.charCodeAt(this.pos);
		switch (ch) {
			case 32:
			case 160:
				++this.pos;
				break;
			case 13: if (this.input.charCodeAt(this.pos + 1) === 10) ++this.pos;
			case 10:
			case 8232:
			case 8233:
				++this.pos;
				if (this.options.locations) {
					++this.curLine;
					this.lineStart = this.pos;
				}
				break;
			case 47:
				switch (this.input.charCodeAt(this.pos + 1)) {
					case 42:
						this.skipBlockComment();
						break;
					case 47:
						this.skipLineComment(2);
						break;
					default: break loop;
				}
				break;
			default: if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) ++this.pos;
			else break loop;
		}
	}
};
pp.finishToken = function(type, val) {
	this.end = this.pos;
	if (this.options.locations) this.endLoc = this.curPosition();
	var prevType = this.type;
	this.type = type;
	this.value = val;
	this.updateContext(prevType);
};
pp.readToken_dot = function() {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next >= 48 && next <= 57) return this.readNumber(true);
	var next2 = this.input.charCodeAt(this.pos + 2);
	if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
		this.pos += 3;
		return this.finishToken(types$1$1.ellipsis);
	} else {
		++this.pos;
		return this.finishToken(types$1$1.dot);
	}
};
pp.readToken_slash = function() {
	var next = this.input.charCodeAt(this.pos + 1);
	if (this.exprAllowed) {
		++this.pos;
		return this.readRegexp();
	}
	if (next === 61) return this.finishOp(types$1$1.assign, 2);
	return this.finishOp(types$1$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	var size = 1;
	var tokentype = code === 42 ? types$1$1.star : types$1$1.modulo;
	if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
		++size;
		tokentype = types$1$1.starstar;
		next = this.input.charCodeAt(this.pos + 2);
	}
	if (next === 61) return this.finishOp(types$1$1.assign, size + 1);
	return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === code) {
		if (this.options.ecmaVersion >= 12) {
			if (this.input.charCodeAt(this.pos + 2) === 61) return this.finishOp(types$1$1.assign, 3);
		}
		return this.finishOp(code === 124 ? types$1$1.logicalOR : types$1$1.logicalAND, 2);
	}
	if (next === 61) return this.finishOp(types$1$1.assign, 2);
	return this.finishOp(code === 124 ? types$1$1.bitwiseOR : types$1$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
	if (this.input.charCodeAt(this.pos + 1) === 61) return this.finishOp(types$1$1.assign, 2);
	return this.finishOp(types$1$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === code) {
		if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
			this.skipLineComment(3);
			this.skipSpace();
			return this.nextToken();
		}
		return this.finishOp(types$1$1.incDec, 2);
	}
	if (next === 61) return this.finishOp(types$1$1.assign, 2);
	return this.finishOp(types$1$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	var size = 1;
	if (next === code) {
		size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
		if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(types$1$1.assign, size + 1);
		return this.finishOp(types$1$1.bitShift, size);
	}
	if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
		this.skipLineComment(4);
		this.skipSpace();
		return this.nextToken();
	}
	if (next === 61) size = 2;
	return this.finishOp(types$1$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === 61) return this.finishOp(types$1$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
	if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
		this.pos += 2;
		return this.finishToken(types$1$1.arrow);
	}
	return this.finishOp(code === 61 ? types$1$1.eq : types$1$1.prefix, 1);
};
pp.readToken_question = function() {
	var ecmaVersion$1 = this.options.ecmaVersion;
	if (ecmaVersion$1 >= 11) {
		var next = this.input.charCodeAt(this.pos + 1);
		if (next === 46) {
			var next2 = this.input.charCodeAt(this.pos + 2);
			if (next2 < 48 || next2 > 57) return this.finishOp(types$1$1.questionDot, 2);
		}
		if (next === 63) {
			if (ecmaVersion$1 >= 12) {
				if (this.input.charCodeAt(this.pos + 2) === 61) return this.finishOp(types$1$1.assign, 3);
			}
			return this.finishOp(types$1$1.coalesce, 2);
		}
	}
	return this.finishOp(types$1$1.question, 1);
};
pp.readToken_numberSign = function() {
	var ecmaVersion$1 = this.options.ecmaVersion;
	var code = 35;
	if (ecmaVersion$1 >= 13) {
		++this.pos;
		code = this.fullCharCodeAtPos();
		if (isIdentifierStart(code, true) || code === 92) return this.finishToken(types$1$1.privateId, this.readWord1());
	}
	this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
	switch (code) {
		case 46: return this.readToken_dot();
		case 40:
			++this.pos;
			return this.finishToken(types$1$1.parenL);
		case 41:
			++this.pos;
			return this.finishToken(types$1$1.parenR);
		case 59:
			++this.pos;
			return this.finishToken(types$1$1.semi);
		case 44:
			++this.pos;
			return this.finishToken(types$1$1.comma);
		case 91:
			++this.pos;
			return this.finishToken(types$1$1.bracketL);
		case 93:
			++this.pos;
			return this.finishToken(types$1$1.bracketR);
		case 123:
			++this.pos;
			return this.finishToken(types$1$1.braceL);
		case 125:
			++this.pos;
			return this.finishToken(types$1$1.braceR);
		case 58:
			++this.pos;
			return this.finishToken(types$1$1.colon);
		case 96:
			if (this.options.ecmaVersion < 6) break;
			++this.pos;
			return this.finishToken(types$1$1.backQuote);
		case 48:
			var next = this.input.charCodeAt(this.pos + 1);
			if (next === 120 || next === 88) return this.readRadixNumber(16);
			if (this.options.ecmaVersion >= 6) {
				if (next === 111 || next === 79) return this.readRadixNumber(8);
				if (next === 98 || next === 66) return this.readRadixNumber(2);
			}
		case 49:
		case 50:
		case 51:
		case 52:
		case 53:
		case 54:
		case 55:
		case 56:
		case 57: return this.readNumber(false);
		case 34:
		case 39: return this.readString(code);
		case 47: return this.readToken_slash();
		case 37:
		case 42: return this.readToken_mult_modulo_exp(code);
		case 124:
		case 38: return this.readToken_pipe_amp(code);
		case 94: return this.readToken_caret();
		case 43:
		case 45: return this.readToken_plus_min(code);
		case 60:
		case 62: return this.readToken_lt_gt(code);
		case 61:
		case 33: return this.readToken_eq_excl(code);
		case 63: return this.readToken_question();
		case 126: return this.finishOp(types$1$1.prefix, 1);
		case 35: return this.readToken_numberSign();
	}
	this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
	var str = this.input.slice(this.pos, this.pos + size);
	this.pos += size;
	return this.finishToken(type, str);
};
pp.readRegexp = function() {
	var escaped, inClass, start = this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
		var ch = this.input.charAt(this.pos);
		if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
		if (!escaped) {
			if (ch === "[") inClass = true;
			else if (ch === "]" && inClass) inClass = false;
			else if (ch === "/" && !inClass) break;
			escaped = ch === "\\";
		} else escaped = false;
		++this.pos;
	}
	var pattern = this.input.slice(start, this.pos);
	++this.pos;
	var flagsStart = this.pos;
	var flags = this.readWord1();
	if (this.containsEsc) this.unexpected(flagsStart);
	var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
	state.reset(start, pattern, flags);
	this.validateRegExpFlags(state);
	this.validateRegExpPattern(state);
	var value = null;
	try {
		value = new RegExp(pattern, flags);
	} catch (e) {}
	return this.finishToken(types$1$1.regexp, {
		pattern,
		flags,
		value
	});
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
	var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
	var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
	var start = this.pos, total = 0, lastCode = 0;
	for (var i$1 = 0, e = len == null ? Infinity : len; i$1 < e; ++i$1, ++this.pos) {
		var code = this.input.charCodeAt(this.pos), val = void 0;
		if (allowSeparators && code === 95) {
			if (isLegacyOctalNumericLiteral) this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
			if (lastCode === 95) this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
			if (i$1 === 0) this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
			lastCode = code;
			continue;
		}
		if (code >= 97) val = code - 97 + 10;
		else if (code >= 65) val = code - 65 + 10;
		else if (code >= 48 && code <= 57) val = code - 48;
		else val = Infinity;
		if (val >= radix) break;
		lastCode = code;
		total = total * radix + val;
	}
	if (allowSeparators && lastCode === 95) this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
	if (this.pos === start || len != null && this.pos - start !== len) return null;
	return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
	if (isLegacyOctalNumericLiteral) return parseInt(str, 8);
	return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
	if (typeof BigInt !== "function") return null;
	return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
	var start = this.pos;
	this.pos += 2;
	var val = this.readInt(radix);
	if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
	if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
		val = stringToBigInt(this.input.slice(start, this.pos));
		++this.pos;
	} else if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	return this.finishToken(types$1$1.num, val);
};
pp.readNumber = function(startsWithDot) {
	var start = this.pos;
	if (!startsWithDot && this.readInt(10, void 0, true) === null) this.raise(start, "Invalid number");
	var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
	if (octal && this.strict) this.raise(start, "Invalid number");
	var next = this.input.charCodeAt(this.pos);
	if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
		var val$1 = stringToBigInt(this.input.slice(start, this.pos));
		++this.pos;
		if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
		return this.finishToken(types$1$1.num, val$1);
	}
	if (octal && /[89]/.test(this.input.slice(start, this.pos))) octal = false;
	if (next === 46 && !octal) {
		++this.pos;
		this.readInt(10);
		next = this.input.charCodeAt(this.pos);
	}
	if ((next === 69 || next === 101) && !octal) {
		next = this.input.charCodeAt(++this.pos);
		if (next === 43 || next === 45) ++this.pos;
		if (this.readInt(10) === null) this.raise(start, "Invalid number");
	}
	if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	var val = stringToNumber(this.input.slice(start, this.pos), octal);
	return this.finishToken(types$1$1.num, val);
};
pp.readCodePoint = function() {
	var ch = this.input.charCodeAt(this.pos), code;
	if (ch === 123) {
		if (this.options.ecmaVersion < 6) this.unexpected();
		var codePos = ++this.pos;
		code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
		++this.pos;
		if (code > 1114111) this.invalidStringToken(codePos, "Code point out of bounds");
	} else code = this.readHexChar(4);
	return code;
};
pp.readString = function(quote) {
	var out = "", chunkStart = ++this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
		var ch = this.input.charCodeAt(this.pos);
		if (ch === quote) break;
		if (ch === 92) {
			out += this.input.slice(chunkStart, this.pos);
			out += this.readEscapedChar(false);
			chunkStart = this.pos;
		} else if (ch === 8232 || ch === 8233) {
			if (this.options.ecmaVersion < 10) this.raise(this.start, "Unterminated string constant");
			++this.pos;
			if (this.options.locations) {
				this.curLine++;
				this.lineStart = this.pos;
			}
		} else {
			if (isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
			++this.pos;
		}
	}
	out += this.input.slice(chunkStart, this.pos++);
	return this.finishToken(types$1$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
	this.inTemplateElement = true;
	try {
		this.readTmplToken();
	} catch (err) {
		if (err === INVALID_TEMPLATE_ESCAPE_ERROR) this.readInvalidTemplateToken();
		else throw err;
	}
	this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
	if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw INVALID_TEMPLATE_ESCAPE_ERROR;
	else this.raise(position, message);
};
pp.readTmplToken = function() {
	var out = "", chunkStart = this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
		var ch = this.input.charCodeAt(this.pos);
		if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
			if (this.pos === this.start && (this.type === types$1$1.template || this.type === types$1$1.invalidTemplate)) if (ch === 36) {
				this.pos += 2;
				return this.finishToken(types$1$1.dollarBraceL);
			} else {
				++this.pos;
				return this.finishToken(types$1$1.backQuote);
			}
			out += this.input.slice(chunkStart, this.pos);
			return this.finishToken(types$1$1.template, out);
		}
		if (ch === 92) {
			out += this.input.slice(chunkStart, this.pos);
			out += this.readEscapedChar(true);
			chunkStart = this.pos;
		} else if (isNewLine(ch)) {
			out += this.input.slice(chunkStart, this.pos);
			++this.pos;
			switch (ch) {
				case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
				case 10:
					out += "\n";
					break;
				default:
					out += String.fromCharCode(ch);
					break;
			}
			if (this.options.locations) {
				++this.curLine;
				this.lineStart = this.pos;
			}
			chunkStart = this.pos;
		} else ++this.pos;
	}
};
pp.readInvalidTemplateToken = function() {
	for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
		case "\\":
			++this.pos;
			break;
		case "$": if (this.input[this.pos + 1] !== "{") break;
		case "`": return this.finishToken(types$1$1.invalidTemplate, this.input.slice(this.start, this.pos));
		case "\r": if (this.input[this.pos + 1] === "\n") ++this.pos;
		case "\n":
		case "\u2028":
		case "\u2029":
			++this.curLine;
			this.lineStart = this.pos + 1;
			break;
	}
	this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
	var ch = this.input.charCodeAt(++this.pos);
	++this.pos;
	switch (ch) {
		case 110: return "\n";
		case 114: return "\r";
		case 120: return String.fromCharCode(this.readHexChar(2));
		case 117: return codePointToString(this.readCodePoint());
		case 116: return "	";
		case 98: return "\b";
		case 118: return "\v";
		case 102: return "\f";
		case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
		case 10:
			if (this.options.locations) {
				this.lineStart = this.pos;
				++this.curLine;
			}
			return "";
		case 56:
		case 57:
			if (this.strict) this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
			if (inTemplate) {
				var codePos = this.pos - 1;
				this.invalidStringToken(codePos, "Invalid escape sequence in template string");
			}
		default:
			if (ch >= 48 && ch <= 55) {
				var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
				var octal = parseInt(octalStr, 8);
				if (octal > 255) {
					octalStr = octalStr.slice(0, -1);
					octal = parseInt(octalStr, 8);
				}
				this.pos += octalStr.length - 1;
				ch = this.input.charCodeAt(this.pos);
				if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
				return String.fromCharCode(octal);
			}
			if (isNewLine(ch)) {
				if (this.options.locations) {
					this.lineStart = this.pos;
					++this.curLine;
				}
				return "";
			}
			return String.fromCharCode(ch);
	}
};
pp.readHexChar = function(len) {
	var codePos = this.pos;
	var n$1 = this.readInt(16, len);
	if (n$1 === null) this.invalidStringToken(codePos, "Bad character escape sequence");
	return n$1;
};
pp.readWord1 = function() {
	this.containsEsc = false;
	var word = "", first = true, chunkStart = this.pos;
	var astral = this.options.ecmaVersion >= 6;
	while (this.pos < this.input.length) {
		var ch = this.fullCharCodeAtPos();
		if (isIdentifierChar(ch, astral)) this.pos += ch <= 65535 ? 1 : 2;
		else if (ch === 92) {
			this.containsEsc = true;
			word += this.input.slice(chunkStart, this.pos);
			var escStart = this.pos;
			if (this.input.charCodeAt(++this.pos) !== 117) this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
			++this.pos;
			var esc = this.readCodePoint();
			if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this.invalidStringToken(escStart, "Invalid Unicode escape");
			word += codePointToString(esc);
			chunkStart = this.pos;
		} else break;
		first = false;
	}
	return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
	var word = this.readWord1();
	var type = types$1$1.name;
	if (this.keywords.test(word)) type = keywords[word];
	return this.finishToken(type, word);
};
var version$1 = "8.14.0";
Parser.acorn = {
	Parser,
	version: version$1,
	defaultOptions,
	Position,
	SourceLocation,
	getLineInfo,
	Node,
	TokenType,
	tokTypes: types$1$1,
	keywordTypes: keywords,
	TokContext,
	tokContexts: types$2,
	isIdentifierChar,
	isIdentifierStart,
	Token,
	isNewLine,
	lineBreak,
	lineBreakG,
	nonASCIIwhitespace
};

//#endregion
//#region ../../node_modules/.pnpm/ufo@1.5.4/node_modules/ufo/dist/index.mjs
const r = String.fromCharCode;
const TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
const JOIN_LEADING_SLASH_RE = /^\.?\//;
function hasTrailingSlash(input = "", respectQueryAndFragment) {
	if (!respectQueryAndFragment) return input.endsWith("/");
	return TRAILING_SLASH_RE.test(input);
}
function withTrailingSlash$1(input = "", respectQueryAndFragment) {
	if (!respectQueryAndFragment) return input.endsWith("/") ? input : input + "/";
	if (hasTrailingSlash(input, true)) return input || "/";
	let path = input;
	let fragment = "";
	const fragmentIndex = input.indexOf("#");
	if (fragmentIndex >= 0) {
		path = input.slice(0, fragmentIndex);
		fragment = input.slice(fragmentIndex);
		if (!path) return fragment;
	}
	const [s0, ...s] = path.split("?");
	return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function isNonEmptyURL(url) {
	return url && url !== "/";
}
function joinURL(base, ...input) {
	let url = base || "";
	for (const segment of input.filter((url2) => isNonEmptyURL(url2))) if (url) {
		const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
		url = withTrailingSlash$1(url) + _segment;
	} else url = segment;
	return url;
}
const protocolRelative = Symbol.for("ufo:protocolRelative");

//#endregion
//#region ../../node_modules/.pnpm/pathe@2.0.1/node_modules/pathe/dist/shared/pathe.BLwDEnA5.mjs
const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
const isAbsolute = function(p) {
	return _IS_ABSOLUTE_RE.test(p);
};

//#endregion
//#region ../../node_modules/.pnpm/mlly@1.7.4/node_modules/mlly/dist/index.mjs
const BUILTIN_MODULES = new Set(builtinModules);
function normalizeSlash(path) {
	return path.replace(/\\/g, "/");
}
/**
* @typedef ErrnoExceptionFields
* @property {number | undefined} [errnode]
* @property {string | undefined} [code]
* @property {string | undefined} [path]
* @property {string | undefined} [syscall]
* @property {string | undefined} [url]
*
* @typedef {Error & ErrnoExceptionFields} ErrnoException
*/
const own$1 = {}.hasOwnProperty;
const classRegExp = /^([A-Z][a-z\d]*)+$/;
const kTypes = new Set([
	"string",
	"function",
	"number",
	"object",
	"Function",
	"Object",
	"boolean",
	"bigint",
	"symbol"
]);
const codes = {};
/**
* Create a list string in the form like 'A and B' or 'A, B, ..., and Z'.
* We cannot use Intl.ListFormat because it's not available in
* --without-intl builds.
*
* @param {Array<string>} array
*   An array of strings.
* @param {string} [type]
*   The list type to be inserted before the last element.
* @returns {string}
*/
function formatList(array, type = "and") {
	return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
}
/** @type {Map<string, MessageFunction | string>} */
const messages = /* @__PURE__ */ new Map();
const nodeInternalPrefix = "__node_internal_";
/** @type {number} */
let userStackTraceLimit;
codes.ERR_INVALID_ARG_TYPE = createError(
	"ERR_INVALID_ARG_TYPE",
	/**
	* @param {string} name
	* @param {Array<string> | string} expected
	* @param {unknown} actual
	*/
	(name, expected, actual) => {
		assert(typeof name === "string", "'name' must be a string");
		if (!Array.isArray(expected)) expected = [expected];
		let message = "The ";
		if (name.endsWith(" argument")) message += `${name} `;
		else {
			const type = name.includes(".") ? "property" : "argument";
			message += `"${name}" ${type} `;
		}
		message += "must be ";
		/** @type {Array<string>} */
		const types$3 = [];
		/** @type {Array<string>} */
		const instances = [];
		/** @type {Array<string>} */
		const other = [];
		for (const value of expected) {
			assert(typeof value === "string", "All expected entries have to be of type string");
			if (kTypes.has(value)) types$3.push(value.toLowerCase());
			else if (classRegExp.exec(value) === null) {
				assert(value !== "object", "The value \"object\" should be written as \"Object\"");
				other.push(value);
			} else instances.push(value);
		}
		if (instances.length > 0) {
			const pos = types$3.indexOf("object");
			if (pos !== -1) {
				types$3.slice(pos, 1);
				instances.push("Object");
			}
		}
		if (types$3.length > 0) {
			message += `${types$3.length > 1 ? "one of type" : "of type"} ${formatList(types$3, "or")}`;
			if (instances.length > 0 || other.length > 0) message += " or ";
		}
		if (instances.length > 0) {
			message += `an instance of ${formatList(instances, "or")}`;
			if (other.length > 0) message += " or ";
		}
		if (other.length > 0) if (other.length > 1) message += `one of ${formatList(other, "or")}`;
		else {
			if (other[0].toLowerCase() !== other[0]) message += "an ";
			message += `${other[0]}`;
		}
		message += `. Received ${determineSpecificType(actual)}`;
		return message;
	},
	TypeError
);
codes.ERR_INVALID_MODULE_SPECIFIER = createError(
	"ERR_INVALID_MODULE_SPECIFIER",
	/**
	* @param {string} request
	* @param {string} reason
	* @param {string} [base]
	*/
	(request$1, reason, base = void 0) => {
		return `Invalid module "${request$1}" ${reason}${base ? ` imported from ${base}` : ""}`;
	},
	TypeError
);
codes.ERR_INVALID_PACKAGE_CONFIG = createError(
	"ERR_INVALID_PACKAGE_CONFIG",
	/**
	* @param {string} path
	* @param {string} [base]
	* @param {string} [message]
	*/
	(path, base, message) => {
		return `Invalid package config ${path}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
	},
	Error
);
codes.ERR_INVALID_PACKAGE_TARGET = createError(
	"ERR_INVALID_PACKAGE_TARGET",
	/**
	* @param {string} packagePath
	* @param {string} key
	* @param {unknown} target
	* @param {boolean} [isImport=false]
	* @param {string} [base]
	*/
	(packagePath, key, target$1, isImport = false, base = void 0) => {
		const relatedError = typeof target$1 === "string" && !isImport && target$1.length > 0 && !target$1.startsWith("./");
		if (key === ".") {
			assert(isImport === false);
			return `Invalid "exports" main target ${JSON.stringify(target$1)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? "; targets must start with \"./\"" : ""}`;
		}
		return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target$1)} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? "; targets must start with \"./\"" : ""}`;
	},
	Error
);
codes.ERR_MODULE_NOT_FOUND = createError(
	"ERR_MODULE_NOT_FOUND",
	/**
	* @param {string} path
	* @param {string} base
	* @param {boolean} [exactUrl]
	*/
	(path, base, exactUrl = false) => {
		return `Cannot find ${exactUrl ? "module" : "package"} '${path}' imported from ${base}`;
	},
	Error
);
codes.ERR_NETWORK_IMPORT_DISALLOWED = createError("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
	"ERR_PACKAGE_IMPORT_NOT_DEFINED",
	/**
	* @param {string} specifier
	* @param {string} packagePath
	* @param {string} base
	*/
	(specifier, packagePath, base) => {
		return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
	},
	TypeError
);
codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
	"ERR_PACKAGE_PATH_NOT_EXPORTED",
	/**
	* @param {string} packagePath
	* @param {string} subpath
	* @param {string} [base]
	*/
	(packagePath, subpath, base = void 0) => {
		if (subpath === ".") return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
		return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
	},
	Error
);
codes.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error);
codes.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError("ERR_UNSUPPORTED_RESOLVE_REQUEST", "Failed to resolve module specifier \"%s\" from \"%s\": Invalid relative URL or base scheme is not hierarchical.", TypeError);
codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
	"ERR_UNKNOWN_FILE_EXTENSION",
	/**
	* @param {string} extension
	* @param {string} path
	*/
	(extension, path) => {
		return `Unknown file extension "${extension}" for ${path}`;
	},
	TypeError
);
codes.ERR_INVALID_ARG_VALUE = createError(
	"ERR_INVALID_ARG_VALUE",
	/**
	* @param {string} name
	* @param {unknown} value
	* @param {string} [reason='is invalid']
	*/
	(name, value, reason = "is invalid") => {
		let inspected = inspect(value);
		if (inspected.length > 128) inspected = `${inspected.slice(0, 128)}...`;
		return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
	},
	TypeError
);
/**
* Utility function for registering the error codes. Only used here. Exported
* *only* to allow for testing.
* @param {string} sym
* @param {MessageFunction | string} value
* @param {ErrorConstructor} constructor
* @returns {new (...parameters: Array<any>) => Error}
*/
function createError(sym, value, constructor) {
	messages.set(sym, value);
	return makeNodeErrorWithCode(constructor, sym);
}
/**
* @param {ErrorConstructor} Base
* @param {string} key
* @returns {ErrorConstructor}
*/
function makeNodeErrorWithCode(Base, key) {
	return NodeError;
	/**
	* @param {Array<unknown>} parameters
	*/
	function NodeError(...parameters) {
		const limit = Error.stackTraceLimit;
		if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
		const error = new Base();
		if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
		const message = getMessage(key, parameters, error);
		Object.defineProperties(error, {
			message: {
				value: message,
				enumerable: false,
				writable: true,
				configurable: true
			},
			toString: {
				value() {
					return `${this.name} [${key}]: ${this.message}`;
				},
				enumerable: false,
				writable: true,
				configurable: true
			}
		});
		captureLargerStackTrace(error);
		error.code = key;
		return error;
	}
}
/**
* @returns {boolean}
*/
function isErrorStackTraceLimitWritable() {
	try {
		if (v8.startupSnapshot.isBuildingSnapshot()) return false;
	} catch {}
	const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
	if (desc === void 0) return Object.isExtensible(Error);
	return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
/**
* This function removes unnecessary frames from Node.js core errors.
* @template {(...parameters: unknown[]) => unknown} T
* @param {T} wrappedFunction
* @returns {T}
*/
function hideStackFrames(wrappedFunction) {
	const hidden = nodeInternalPrefix + wrappedFunction.name;
	Object.defineProperty(wrappedFunction, "name", { value: hidden });
	return wrappedFunction;
}
const captureLargerStackTrace = hideStackFrames(
	/**
	* @param {Error} error
	* @returns {Error}
	*/
	function(error) {
		const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
		if (stackTraceLimitIsWritable) {
			userStackTraceLimit = Error.stackTraceLimit;
			Error.stackTraceLimit = Number.POSITIVE_INFINITY;
		}
		Error.captureStackTrace(error);
		if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
		return error;
	}
);
/**
* @param {string} key
* @param {Array<unknown>} parameters
* @param {Error} self
* @returns {string}
*/
function getMessage(key, parameters, self) {
	const message = messages.get(key);
	assert(message !== void 0, "expected `message` to be found");
	if (typeof message === "function") {
		assert(message.length <= parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`);
		return Reflect.apply(message, self, parameters);
	}
	const regex = /%[dfijoOs]/g;
	let expectedLength = 0;
	while (regex.exec(message) !== null) expectedLength++;
	assert(expectedLength === parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`);
	if (parameters.length === 0) return message;
	parameters.unshift(message);
	return Reflect.apply(format, null, parameters);
}
/**
* Determine the specific type of a value for type-mismatch errors.
* @param {unknown} value
* @returns {string}
*/
function determineSpecificType(value) {
	if (value === null || value === void 0) return String(value);
	if (typeof value === "function" && value.name) return `function ${value.name}`;
	if (typeof value === "object") {
		if (value.constructor && value.constructor.name) return `an instance of ${value.constructor.name}`;
		return `${inspect(value, { depth: -1 })}`;
	}
	let inspected = inspect(value, { colors: false });
	if (inspected.length > 28) inspected = `${inspected.slice(0, 25)}...`;
	return `type ${typeof value} (${inspected})`;
}
const hasOwnProperty$1 = {}.hasOwnProperty;
const { ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1 } = codes;
/** @type {Map<string, PackageConfig>} */
const cache = /* @__PURE__ */ new Map();
/**
* @param {string} jsonPath
* @param {{specifier: URL | string, base?: URL}} options
* @returns {PackageConfig}
*/
function read(jsonPath, { base, specifier }) {
	const existing = cache.get(jsonPath);
	if (existing) return existing;
	/** @type {string | undefined} */
	let string;
	try {
		string = fs.readFileSync(path4.toNamespacedPath(jsonPath), "utf8");
	} catch (error) {
		const exception = error;
		if (exception.code !== "ENOENT") throw exception;
	}
	/** @type {PackageConfig} */
	const result = {
		exists: false,
		pjsonPath: jsonPath,
		main: void 0,
		name: void 0,
		type: "none",
		exports: void 0,
		imports: void 0
	};
	if (string !== void 0) {
		/** @type {Record<string, unknown>} */
		let parsed;
		try {
			parsed = JSON.parse(string);
		} catch (error_) {
			const cause = error_;
			const error = new ERR_INVALID_PACKAGE_CONFIG$1(jsonPath, (base ? `"${specifier}" from ` : "") + fileURLToPath(base || specifier), cause.message);
			error.cause = cause;
			throw error;
		}
		result.exists = true;
		if (hasOwnProperty$1.call(parsed, "name") && typeof parsed.name === "string") result.name = parsed.name;
		if (hasOwnProperty$1.call(parsed, "main") && typeof parsed.main === "string") result.main = parsed.main;
		if (hasOwnProperty$1.call(parsed, "exports")) result.exports = parsed.exports;
		if (hasOwnProperty$1.call(parsed, "imports")) result.imports = parsed.imports;
		if (hasOwnProperty$1.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module")) result.type = parsed.type;
	}
	cache.set(jsonPath, result);
	return result;
}
/**
* @param {URL | string} resolved
* @returns {PackageConfig}
*/
function getPackageScopeConfig(resolved) {
	let packageJSONUrl = new URL("package.json", resolved);
	while (true) {
		if (packageJSONUrl.pathname.endsWith("node_modules/package.json")) break;
		const packageConfig = read(fileURLToPath(packageJSONUrl), { specifier: resolved });
		if (packageConfig.exists) return packageConfig;
		const lastPackageJSONUrl = packageJSONUrl;
		packageJSONUrl = new URL("../package.json", packageJSONUrl);
		if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;
	}
	return {
		pjsonPath: fileURLToPath(packageJSONUrl),
		exists: false,
		type: "none"
	};
}
/**
* Returns the package type for a given URL.
* @param {URL} url - The URL to get the package type for.
* @returns {PackageType}
*/
function getPackageType(url) {
	return getPackageScopeConfig(url).type;
}
const { ERR_UNKNOWN_FILE_EXTENSION } = codes;
const hasOwnProperty = {}.hasOwnProperty;
/** @type {Record<string, string>} */
const extensionFormatMap = {
	__proto__: null,
	".cjs": "commonjs",
	".js": "module",
	".json": "json",
	".mjs": "module"
};
/**
* @param {string | null} mime
* @returns {string | null}
*/
function mimeToFormat(mime) {
	if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime)) return "module";
	if (mime === "application/json") return "json";
	return null;
}
/**
* @callback ProtocolHandler
* @param {URL} parsed
* @param {{parentURL: string, source?: Buffer}} context
* @param {boolean} ignoreErrors
* @returns {string | null | void}
*/
/**
* @type {Record<string, ProtocolHandler>}
*/
const protocolHandlers = {
	__proto__: null,
	"data:": getDataProtocolModuleFormat,
	"file:": getFileProtocolModuleFormat,
	"http:": getHttpProtocolModuleFormat,
	"https:": getHttpProtocolModuleFormat,
	"node:"() {
		return "builtin";
	}
};
/**
* @param {URL} parsed
*/
function getDataProtocolModuleFormat(parsed) {
	const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [
		null,
		null,
		null
	];
	return mimeToFormat(mime);
}
/**
* Returns the file extension from a URL.
*
* Should give similar result to
* `require('node:path').extname(require('node:url').fileURLToPath(url))`
* when used with a `file:` URL.
*
* @param {URL} url
* @returns {string}
*/
function extname$1(url) {
	const pathname = url.pathname;
	let index = pathname.length;
	while (index--) {
		const code = pathname.codePointAt(index);
		if (code === 47) return "";
		if (code === 46) return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
	}
	return "";
}
/**
* @type {ProtocolHandler}
*/
function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
	const value = extname$1(url);
	if (value === ".js") {
		const packageType = getPackageType(url);
		if (packageType !== "none") return packageType;
		return "commonjs";
	}
	if (value === "") {
		const packageType = getPackageType(url);
		if (packageType === "none" || packageType === "commonjs") return "commonjs";
		return "module";
	}
	const format$2 = extensionFormatMap[value];
	if (format$2) return format$2;
	if (ignoreErrors) return;
	throw new ERR_UNKNOWN_FILE_EXTENSION(value, fileURLToPath(url));
}
function getHttpProtocolModuleFormat() {}
/**
* @param {URL} url
* @param {{parentURL: string}} context
* @returns {string | null}
*/
function defaultGetFormatWithoutErrors(url, context) {
	const protocol = url.protocol;
	if (!hasOwnProperty.call(protocolHandlers, protocol)) return null;
	return protocolHandlers[protocol](url, context, true) || null;
}
const RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
const { ERR_NETWORK_IMPORT_DISALLOWED, ERR_INVALID_MODULE_SPECIFIER, ERR_INVALID_PACKAGE_CONFIG, ERR_INVALID_PACKAGE_TARGET, ERR_MODULE_NOT_FOUND, ERR_PACKAGE_IMPORT_NOT_DEFINED, ERR_PACKAGE_PATH_NOT_EXPORTED, ERR_UNSUPPORTED_DIR_IMPORT, ERR_UNSUPPORTED_RESOLVE_REQUEST } = codes;
const own = {}.hasOwnProperty;
const invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
const deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
const invalidPackageNameRegEx = /^\.|%|\\/;
const patternRegEx = /\*/g;
const encodedSeparatorRegEx = /%2f|%5c/i;
/** @type {Set<string>} */
const emittedPackageWarnings = /* @__PURE__ */ new Set();
const doubleSlashRegEx = /[/\\]{2}/;
/**
*
* @param {string} target
* @param {string} request
* @param {string} match
* @param {URL} packageJsonUrl
* @param {boolean} internal
* @param {URL} base
* @param {boolean} isTarget
*/
function emitInvalidSegmentDeprecation(target$1, request$1, match, packageJsonUrl, internal, base, isTarget) {
	if (process2.noDeprecation) return;
	const pjsonPath = fileURLToPath(packageJsonUrl);
	const double = doubleSlashRegEx.exec(isTarget ? target$1 : request$1) !== null;
	process2.emitWarning(`Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target$1}" for module request "${request$1}" ${request$1 === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ""}.`, "DeprecationWarning", "DEP0166");
}
/**
* @param {URL} url
* @param {URL} packageJsonUrl
* @param {URL} base
* @param {string} [main]
* @returns {void}
*/
function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
	if (process2.noDeprecation) return;
	if (defaultGetFormatWithoutErrors(url, { parentURL: base.href }) !== "module") return;
	const urlPath = fileURLToPath(url.href);
	const packagePath = fileURLToPath(new URL$1(".", packageJsonUrl));
	const basePath = fileURLToPath(base);
	if (!main) process2.emitWarning(`No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(packagePath.length)}", imported from ${basePath}.\nDefault "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
	else if (path4.resolve(packagePath, main) !== urlPath) process2.emitWarning(`Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(packagePath.length)}", imported from ${basePath}.\n Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
}
/**
* @param {string} path
* @returns {Stats | undefined}
*/
function tryStatSync(path) {
	try {
		return statSync(path);
	} catch {}
}
/**
* Legacy CommonJS main resolution:
* 1. let M = pkg_url + (json main field)
* 2. TRY(M, M.js, M.json, M.node)
* 3. TRY(M/index.js, M/index.json, M/index.node)
* 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)
* 5. NOT_FOUND
*
* @param {URL} url
* @returns {boolean}
*/
function fileExists(url) {
	const stats = statSync(url, { throwIfNoEntry: false });
	const isFile = stats ? stats.isFile() : void 0;
	return isFile === null || isFile === void 0 ? false : isFile;
}
/**
* @param {URL} packageJsonUrl
* @param {PackageConfig} packageConfig
* @param {URL} base
* @returns {URL}
*/
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
	/** @type {URL | undefined} */
	let guess;
	if (packageConfig.main !== void 0) {
		guess = new URL$1(packageConfig.main, packageJsonUrl);
		if (fileExists(guess)) return guess;
		const tries$1 = [
			`./${packageConfig.main}.js`,
			`./${packageConfig.main}.json`,
			`./${packageConfig.main}.node`,
			`./${packageConfig.main}/index.js`,
			`./${packageConfig.main}/index.json`,
			`./${packageConfig.main}/index.node`
		];
		let i$2 = -1;
		while (++i$2 < tries$1.length) {
			guess = new URL$1(tries$1[i$2], packageJsonUrl);
			if (fileExists(guess)) break;
			guess = void 0;
		}
		if (guess) {
			emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
			return guess;
		}
	}
	const tries = [
		"./index.js",
		"./index.json",
		"./index.node"
	];
	let i$1 = -1;
	while (++i$1 < tries.length) {
		guess = new URL$1(tries[i$1], packageJsonUrl);
		if (fileExists(guess)) break;
		guess = void 0;
	}
	if (guess) {
		emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
		return guess;
	}
	throw new ERR_MODULE_NOT_FOUND(fileURLToPath(new URL$1(".", packageJsonUrl)), fileURLToPath(base));
}
/**
* @param {URL} resolved
* @param {URL} base
* @param {boolean} [preserveSymlinks]
* @returns {URL}
*/
function finalizeResolution(resolved, base, preserveSymlinks) {
	if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, "must not include encoded \"/\" or \"\\\" characters", fileURLToPath(base));
	/** @type {string} */
	let filePath;
	try {
		filePath = fileURLToPath(resolved);
	} catch (error) {
		const cause = error;
		Object.defineProperty(cause, "input", { value: String(resolved) });
		Object.defineProperty(cause, "module", { value: String(base) });
		throw cause;
	}
	const stats = tryStatSync(filePath.endsWith("/") ? filePath.slice(-1) : filePath);
	if (stats && stats.isDirectory()) {
		const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, fileURLToPath(base));
		error.url = String(resolved);
		throw error;
	}
	if (!stats || !stats.isFile()) {
		const error = new ERR_MODULE_NOT_FOUND(filePath || resolved.pathname, base && fileURLToPath(base), true);
		error.url = String(resolved);
		throw error;
	}
	{
		const real = realpathSync(filePath);
		const { search, hash } = resolved;
		resolved = pathToFileURL(real + (filePath.endsWith(path4.sep) ? "/" : ""));
		resolved.search = search;
		resolved.hash = hash;
	}
	return resolved;
}
/**
* @param {string} specifier
* @param {URL | undefined} packageJsonUrl
* @param {URL} base
* @returns {Error}
*/
function importNotDefined(specifier, packageJsonUrl, base) {
	return new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl && fileURLToPath(new URL$1(".", packageJsonUrl)), fileURLToPath(base));
}
/**
* @param {string} subpath
* @param {URL} packageJsonUrl
* @param {URL} base
* @returns {Error}
*/
function exportsNotFound(subpath, packageJsonUrl, base) {
	return new ERR_PACKAGE_PATH_NOT_EXPORTED(fileURLToPath(new URL$1(".", packageJsonUrl)), subpath, base && fileURLToPath(base));
}
/**
* @param {string} request
* @param {string} match
* @param {URL} packageJsonUrl
* @param {boolean} internal
* @param {URL} [base]
* @returns {never}
*/
function throwInvalidSubpath(request$1, match, packageJsonUrl, internal, base) {
	throw new ERR_INVALID_MODULE_SPECIFIER(request$1, `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${fileURLToPath(packageJsonUrl)}`, base && fileURLToPath(base));
}
/**
* @param {string} subpath
* @param {unknown} target
* @param {URL} packageJsonUrl
* @param {boolean} internal
* @param {URL} [base]
* @returns {Error}
*/
function invalidPackageTarget(subpath, target$1, packageJsonUrl, internal, base) {
	target$1 = typeof target$1 === "object" && target$1 !== null ? JSON.stringify(target$1, null, "") : `${target$1}`;
	return new ERR_INVALID_PACKAGE_TARGET(fileURLToPath(new URL$1(".", packageJsonUrl)), subpath, target$1, internal, base && fileURLToPath(base));
}
/**
* @param {string} target
* @param {string} subpath
* @param {string} match
* @param {URL} packageJsonUrl
* @param {URL} base
* @param {boolean} pattern
* @param {boolean} internal
* @param {boolean} isPathMap
* @param {Set<string> | undefined} conditions
* @returns {URL}
*/
function resolvePackageTargetString(target$1, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
	if (subpath !== "" && !pattern && target$1[target$1.length - 1] !== "/") throw invalidPackageTarget(match, target$1, packageJsonUrl, internal, base);
	if (!target$1.startsWith("./")) {
		if (internal && !target$1.startsWith("../") && !target$1.startsWith("/")) {
			let isURL = false;
			try {
				new URL$1(target$1);
				isURL = true;
			} catch {}
			if (!isURL) return packageResolve(pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target$1, () => subpath) : target$1 + subpath, packageJsonUrl, conditions);
		}
		throw invalidPackageTarget(match, target$1, packageJsonUrl, internal, base);
	}
	if (invalidSegmentRegEx.exec(target$1.slice(2)) !== null) if (deprecatedInvalidSegmentRegEx.exec(target$1.slice(2)) === null) {
		if (!isPathMap) {
			const request$1 = pattern ? match.replace("*", () => subpath) : match + subpath;
			emitInvalidSegmentDeprecation(pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target$1, () => subpath) : target$1, request$1, match, packageJsonUrl, internal, base, true);
		}
	} else throw invalidPackageTarget(match, target$1, packageJsonUrl, internal, base);
	const resolved = new URL$1(target$1, packageJsonUrl);
	const resolvedPath = resolved.pathname;
	const packagePath = new URL$1(".", packageJsonUrl).pathname;
	if (!resolvedPath.startsWith(packagePath)) throw invalidPackageTarget(match, target$1, packageJsonUrl, internal, base);
	if (subpath === "") return resolved;
	if (invalidSegmentRegEx.exec(subpath) !== null) {
		const request$1 = pattern ? match.replace("*", () => subpath) : match + subpath;
		if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
			if (!isPathMap) emitInvalidSegmentDeprecation(pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target$1, () => subpath) : target$1, request$1, match, packageJsonUrl, internal, base, false);
		} else throwInvalidSubpath(request$1, match, packageJsonUrl, internal, base);
	}
	if (pattern) return new URL$1(RegExpPrototypeSymbolReplace.call(patternRegEx, resolved.href, () => subpath));
	return new URL$1(subpath, resolved);
}
/**
* @param {string} key
* @returns {boolean}
*/
function isArrayIndex(key) {
	const keyNumber = Number(key);
	if (`${keyNumber}` !== key) return false;
	return keyNumber >= 0 && keyNumber < 4294967295;
}
/**
* @param {URL} packageJsonUrl
* @param {unknown} target
* @param {string} subpath
* @param {string} packageSubpath
* @param {URL} base
* @param {boolean} pattern
* @param {boolean} internal
* @param {boolean} isPathMap
* @param {Set<string> | undefined} conditions
* @returns {URL | null}
*/
function resolvePackageTarget(packageJsonUrl, target$1, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
	if (typeof target$1 === "string") return resolvePackageTargetString(target$1, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, isPathMap, conditions);
	if (Array.isArray(target$1)) {
		/** @type {Array<unknown>} */
		const targetList = target$1;
		if (targetList.length === 0) return null;
		/** @type {ErrnoException | null | undefined} */
		let lastException;
		let i$1 = -1;
		while (++i$1 < targetList.length) {
			const targetItem = targetList[i$1];
			/** @type {URL | null} */
			let resolveResult;
			try {
				resolveResult = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
			} catch (error) {
				const exception = error;
				lastException = exception;
				if (exception.code === "ERR_INVALID_PACKAGE_TARGET") continue;
				throw error;
			}
			if (resolveResult === void 0) continue;
			if (resolveResult === null) {
				lastException = null;
				continue;
			}
			return resolveResult;
		}
		if (lastException === void 0 || lastException === null) return null;
		throw lastException;
	}
	if (typeof target$1 === "object" && target$1 !== null) {
		const keys = Object.getOwnPropertyNames(target$1);
		let i$1 = -1;
		while (++i$1 < keys.length) {
			const key = keys[i$1];
			if (isArrayIndex(key)) throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJsonUrl), base, "\"exports\" cannot contain numeric property keys.");
		}
		i$1 = -1;
		while (++i$1 < keys.length) {
			const key = keys[i$1];
			if (key === "default" || conditions && conditions.has(key)) {
				const conditionalTarget = target$1[key];
				const resolveResult = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
				if (resolveResult === void 0) continue;
				return resolveResult;
			}
		}
		return null;
	}
	if (target$1 === null) return null;
	throw invalidPackageTarget(packageSubpath, target$1, packageJsonUrl, internal, base);
}
/**
* @param {unknown} exports
* @param {URL} packageJsonUrl
* @param {URL} base
* @returns {boolean}
*/
function isConditionalExportsMainSugar(exports$1, packageJsonUrl, base) {
	if (typeof exports$1 === "string" || Array.isArray(exports$1)) return true;
	if (typeof exports$1 !== "object" || exports$1 === null) return false;
	const keys = Object.getOwnPropertyNames(exports$1);
	let isConditionalSugar = false;
	let i$1 = 0;
	let keyIndex = -1;
	while (++keyIndex < keys.length) {
		const key = keys[keyIndex];
		const currentIsConditionalSugar = key === "" || key[0] !== ".";
		if (i$1++ === 0) isConditionalSugar = currentIsConditionalSugar;
		else if (isConditionalSugar !== currentIsConditionalSugar) throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJsonUrl), base, "\"exports\" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.");
	}
	return isConditionalSugar;
}
/**
* @param {string} match
* @param {URL} pjsonUrl
* @param {URL} base
*/
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
	if (process2.noDeprecation) return;
	const pjsonPath = fileURLToPath(pjsonUrl);
	if (emittedPackageWarnings.has(pjsonPath + "|" + match)) return;
	emittedPackageWarnings.add(pjsonPath + "|" + match);
	process2.emitWarning(`Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155");
}
/**
* @param {URL} packageJsonUrl
* @param {string} packageSubpath
* @param {Record<string, unknown>} packageConfig
* @param {URL} base
* @param {Set<string> | undefined} conditions
* @returns {URL}
*/
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
	let exports$1 = packageConfig.exports;
	if (isConditionalExportsMainSugar(exports$1, packageJsonUrl, base)) exports$1 = { ".": exports$1 };
	if (own.call(exports$1, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
		const target$1 = exports$1[packageSubpath];
		const resolveResult = resolvePackageTarget(packageJsonUrl, target$1, "", packageSubpath, base, false, false, false, conditions);
		if (resolveResult === null || resolveResult === void 0) throw exportsNotFound(packageSubpath, packageJsonUrl, base);
		return resolveResult;
	}
	let bestMatch = "";
	let bestMatchSubpath = "";
	const keys = Object.getOwnPropertyNames(exports$1);
	let i$1 = -1;
	while (++i$1 < keys.length) {
		const key = keys[i$1];
		const patternIndex = key.indexOf("*");
		if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
			if (packageSubpath.endsWith("/")) emitTrailingSlashPatternDeprecation(packageSubpath, packageJsonUrl, base);
			const patternTrailer = key.slice(patternIndex + 1);
			if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
				bestMatch = key;
				bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length);
			}
		}
	}
	if (bestMatch) {
		const target$1 = exports$1[bestMatch];
		const resolveResult = resolvePackageTarget(packageJsonUrl, target$1, bestMatchSubpath, bestMatch, base, true, false, packageSubpath.endsWith("/"), conditions);
		if (resolveResult === null || resolveResult === void 0) throw exportsNotFound(packageSubpath, packageJsonUrl, base);
		return resolveResult;
	}
	throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
/**
* @param {string} a
* @param {string} b
*/
function patternKeyCompare(a, b) {
	const aPatternIndex = a.indexOf("*");
	const bPatternIndex = b.indexOf("*");
	const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
	const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
	if (baseLengthA > baseLengthB) return -1;
	if (baseLengthB > baseLengthA) return 1;
	if (aPatternIndex === -1) return 1;
	if (bPatternIndex === -1) return -1;
	if (a.length > b.length) return -1;
	if (b.length > a.length) return 1;
	return 0;
}
/**
* @param {string} name
* @param {URL} base
* @param {Set<string>} [conditions]
* @returns {URL}
*/
function packageImportsResolve(name, base, conditions) {
	if (name === "#" || name.startsWith("#/") || name.endsWith("/")) throw new ERR_INVALID_MODULE_SPECIFIER(name, "is not a valid internal imports specifier name", fileURLToPath(base));
	/** @type {URL | undefined} */
	let packageJsonUrl;
	const packageConfig = getPackageScopeConfig(base);
	if (packageConfig.exists) {
		packageJsonUrl = pathToFileURL(packageConfig.pjsonPath);
		const imports = packageConfig.imports;
		if (imports) if (own.call(imports, name) && !name.includes("*")) {
			const resolveResult = resolvePackageTarget(packageJsonUrl, imports[name], "", name, base, false, true, false, conditions);
			if (resolveResult !== null && resolveResult !== void 0) return resolveResult;
		} else {
			let bestMatch = "";
			let bestMatchSubpath = "";
			const keys = Object.getOwnPropertyNames(imports);
			let i$1 = -1;
			while (++i$1 < keys.length) {
				const key = keys[i$1];
				const patternIndex = key.indexOf("*");
				if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
					const patternTrailer = key.slice(patternIndex + 1);
					if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
						bestMatch = key;
						bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length);
					}
				}
			}
			if (bestMatch) {
				const target$1 = imports[bestMatch];
				const resolveResult = resolvePackageTarget(packageJsonUrl, target$1, bestMatchSubpath, bestMatch, base, true, true, false, conditions);
				if (resolveResult !== null && resolveResult !== void 0) return resolveResult;
			}
		}
	}
	throw importNotDefined(name, packageJsonUrl, base);
}
/**
* @param {string} specifier
* @param {URL} base
*/
function parsePackageName(specifier, base) {
	let separatorIndex = specifier.indexOf("/");
	let validPackageName = true;
	let isScoped = false;
	if (specifier[0] === "@") {
		isScoped = true;
		if (separatorIndex === -1 || specifier.length === 0) validPackageName = false;
		else separatorIndex = specifier.indexOf("/", separatorIndex + 1);
	}
	const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
	if (invalidPackageNameRegEx.exec(packageName) !== null) validPackageName = false;
	if (!validPackageName) throw new ERR_INVALID_MODULE_SPECIFIER(specifier, "is not a valid package name", fileURLToPath(base));
	return {
		packageName,
		packageSubpath: "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex)),
		isScoped
	};
}
/**
* @param {string} specifier
* @param {URL} base
* @param {Set<string> | undefined} conditions
* @returns {URL}
*/
function packageResolve(specifier, base, conditions) {
	if (builtinModules.includes(specifier)) return new URL$1("node:" + specifier);
	const { packageName, packageSubpath, isScoped } = parsePackageName(specifier, base);
	const packageConfig = getPackageScopeConfig(base);
	/* c8 ignore next 16 */
	if (packageConfig.exists) {
		const packageJsonUrl$1 = pathToFileURL(packageConfig.pjsonPath);
		if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) return packageExportsResolve(packageJsonUrl$1, packageSubpath, packageConfig, base, conditions);
	}
	let packageJsonUrl = new URL$1("./node_modules/" + packageName + "/package.json", base);
	let packageJsonPath = fileURLToPath(packageJsonUrl);
	/** @type {string} */
	let lastPath;
	do {
		const stat = tryStatSync(packageJsonPath.slice(0, -13));
		if (!stat || !stat.isDirectory()) {
			lastPath = packageJsonPath;
			packageJsonUrl = new URL$1((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJsonUrl);
			packageJsonPath = fileURLToPath(packageJsonUrl);
			continue;
		}
		const packageConfig$1 = read(packageJsonPath, {
			base,
			specifier
		});
		if (packageConfig$1.exports !== void 0 && packageConfig$1.exports !== null) return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig$1, base, conditions);
		if (packageSubpath === ".") return legacyMainResolve(packageJsonUrl, packageConfig$1, base);
		return new URL$1(packageSubpath, packageJsonUrl);
	} while (packageJsonPath.length !== lastPath.length);
	throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base), false);
}
/**
* @param {string} specifier
* @returns {boolean}
*/
function isRelativeSpecifier(specifier) {
	if (specifier[0] === ".") {
		if (specifier.length === 1 || specifier[1] === "/") return true;
		if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) return true;
	}
	return false;
}
/**
* @param {string} specifier
* @returns {boolean}
*/
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
	if (specifier === "") return false;
	if (specifier[0] === "/") return true;
	return isRelativeSpecifier(specifier);
}
/**
* The Resolver Algorithm Specification as detailed in the Node docs (which is
* sync and slightly lower-level than `resolve`).
*
* @param {string} specifier
*   `/example.js`, `./example.js`, `../example.js`, `some-package`, `fs`, etc.
* @param {URL} base
*   Full URL (to a file) that `specifier` is resolved relative from.
* @param {Set<string>} [conditions]
*   Conditions.
* @param {boolean} [preserveSymlinks]
*   Keep symlinks instead of resolving them.
* @returns {URL}
*   A URL object to the found thing.
*/
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
	const protocol = base.protocol;
	const isRemote = protocol === "data:" || protocol === "http:" || protocol === "https:";
	/** @type {URL | undefined} */
	let resolved;
	if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) try {
		resolved = new URL$1(specifier, base);
	} catch (error_) {
		const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
		error.cause = error_;
		throw error;
	}
	else if (protocol === "file:" && specifier[0] === "#") resolved = packageImportsResolve(specifier, base, conditions);
	else try {
		resolved = new URL$1(specifier);
	} catch (error_) {
		if (isRemote && !builtinModules.includes(specifier)) {
			const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
			error.cause = error_;
			throw error;
		}
		resolved = packageResolve(specifier, base, conditions);
	}
	assert(resolved !== void 0, "expected to be defined");
	if (resolved.protocol !== "file:") return resolved;
	return finalizeResolution(resolved, base);
}
function fileURLToPath$1(id) {
	if (typeof id === "string" && !id.startsWith("file://")) return normalizeSlash(id);
	return normalizeSlash(fileURLToPath(id));
}
function pathToFileURL$1(id) {
	return pathToFileURL(fileURLToPath$1(id)).toString();
}
function normalizeid(id) {
	if (typeof id !== "string") id = id.toString();
	if (/(node|data|http|https|file):/.test(id)) return id;
	if (BUILTIN_MODULES.has(id)) return "node:" + id;
	return "file://" + encodeURI(normalizeSlash(id));
}
const DEFAULT_CONDITIONS_SET = /* @__PURE__ */ new Set(["node", "import"]);
const DEFAULT_EXTENSIONS = [
	".mjs",
	".cjs",
	".js",
	".json"
];
const NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
	"ERR_MODULE_NOT_FOUND",
	"ERR_UNSUPPORTED_DIR_IMPORT",
	"MODULE_NOT_FOUND",
	"ERR_PACKAGE_PATH_NOT_EXPORTED"
]);
function _tryModuleResolve(id, url, conditions) {
	try {
		return moduleResolve(id, url, conditions);
	} catch (error) {
		if (!NOT_FOUND_ERRORS.has(error?.code)) throw error;
	}
}
function _resolve(id, options = {}) {
	if (typeof id !== "string") if (id instanceof URL) id = fileURLToPath$1(id);
	else throw new TypeError("input must be a `string` or `URL`");
	if (/(node|data|http|https):/.test(id)) return id;
	if (BUILTIN_MODULES.has(id)) return "node:" + id;
	if (id.startsWith("file://")) id = fileURLToPath$1(id);
	if (isAbsolute(id)) try {
		if (statSync(id).isFile()) return pathToFileURL$1(id);
	} catch (error) {
		if (error?.code !== "ENOENT") throw error;
	}
	const conditionsSet = options.conditions ? new Set(options.conditions) : DEFAULT_CONDITIONS_SET;
	const _urls = (Array.isArray(options.url) ? options.url : [options.url]).filter(Boolean).map((url) => new URL(normalizeid(url.toString())));
	if (_urls.length === 0) _urls.push(new URL(pathToFileURL$1(process.cwd())));
	const urls = [..._urls];
	for (const url of _urls) if (url.protocol === "file:") urls.push(new URL("./", url), new URL(joinURL(url.pathname, "_index.js"), url), new URL("node_modules", url));
	let resolved;
	for (const url of urls) {
		resolved = _tryModuleResolve(id, url, conditionsSet);
		if (resolved) break;
		for (const prefix of ["", "/index"]) {
			for (const extension of options.extensions || DEFAULT_EXTENSIONS) {
				resolved = _tryModuleResolve(joinURL(id, prefix) + extension, url, conditionsSet);
				if (resolved) break;
			}
			if (resolved) break;
		}
		if (resolved) break;
	}
	if (!resolved) {
		const error = /* @__PURE__ */ new Error(`Cannot find module ${id} imported from ${urls.join(", ")}`);
		error.code = "ERR_MODULE_NOT_FOUND";
		throw error;
	}
	return pathToFileURL$1(resolved);
}
function resolveSync(id, options) {
	return _resolve(id, options);
}
function resolvePathSync(id, options) {
	return fileURLToPath$1(resolveSync(id, options));
}

//#endregion
//#region src/nodejs-compat.ts
var NodeJsCompat = class {
	externals;
	entries;
	#env;
	/**
	* Map of module identifiers to an array of:
	* - `injectedName`: the name injected on `globalThis`
	* - `exportName`: the export name from the module
	* - `importName`: the imported name
	*/
	#injectsByModule;
	/**
	* Map of virtual module to injectable module ID,
	* which then maps via `injectsByModule` to the global code to be injected.
	*/
	#virtualModulePathToSpecifier;
	constructor(workerConfig) {
		const { env } = defineEnv({ presets: [getCloudflarePreset({
			compatibilityDate: workerConfig.compatibility_date,
			compatibilityFlags: workerConfig.compatibility_flags
		})] });
		this.#env = env;
		this.externals = new Set(env.external);
		this.entries = this.#getEntries();
		const { injectsByModule, virtualModulePathToSpecifier } = this.#getInjects();
		this.#injectsByModule = injectsByModule;
		this.#virtualModulePathToSpecifier = virtualModulePathToSpecifier;
	}
	/**
	* Gets a set of module specifiers for all possible Node.js compat polyfill entry-points
	*/
	#getEntries() {
		const entries = new Set(Object.values(this.#env.alias));
		for (const globalInject of Object.values(this.#env.inject)) if (typeof globalInject === "string") entries.add(globalInject);
		else {
			assert(globalInject[0] !== void 0, "Expected first element of globalInject to be defined");
			entries.add(globalInject[0]);
		}
		this.#env.polyfill.forEach((polyfill) => entries.add(polyfill));
		this.externals.forEach((external) => entries.delete(external));
		return entries;
	}
	#getInjects() {
		const injectsByModule = /* @__PURE__ */ new Map();
		const virtualModulePathToSpecifier = /* @__PURE__ */ new Map();
		const virtualModulePrefix = `\0_nodejs_global_inject-`;
		for (const [injectedName, moduleSpecifier] of Object.entries(this.#env.inject)) {
			const [module$2, exportName, importName] = Array.isArray(moduleSpecifier) ? [
				moduleSpecifier[0],
				moduleSpecifier[1],
				moduleSpecifier[1]
			] : [
				moduleSpecifier,
				"default",
				"defaultExport"
			];
			if (!injectsByModule.has(module$2)) {
				injectsByModule.set(module$2, []);
				virtualModulePathToSpecifier.set(`${virtualModulePrefix}${module$2.replaceAll("/", "-")}`, module$2);
			}
			const injects = injectsByModule.get(module$2);
			assert(injects, `expected injects for "${module$2}" to be defined`);
			injects.push({
				injectedName,
				exportName,
				importName
			});
		}
		return {
			injectsByModule,
			virtualModulePathToSpecifier
		};
	}
	/**
	* Does the given module ID resolve to a virtual module corresponding to a global injection module?
	*/
	isGlobalVirtualModule(source) {
		return this.#virtualModulePathToSpecifier.has(source);
	}
	/**
	* Get the contents of the virtual module corresponding to a global injection module.
	*/
	getGlobalVirtualModule(source) {
		const module$2 = this.#virtualModulePathToSpecifier.get(source);
		if (!module$2) return;
		const injects = this.#injectsByModule.get(module$2);
		assert(injects, `expected injects for "${module$2}" to be defined`);
		return [`import { ${injects.map(({ exportName, importName }) => importName === exportName ? exportName : `${exportName} as ${importName}`).join(", ")} } from "${module$2}";`, ...injects.map(({ injectedName, importName }) => `globalThis.${injectedName} = ${importName};`)].join("\n");
	}
	/**
	* Gets the necessary global polyfills to inject into the entry-point of the user's code.
	*/
	injectGlobalCode() {
		return `${Array.from(this.#virtualModulePathToSpecifier.keys()).map((moduleId) => `import "${moduleId}";`).join("\n")}${this.#env.polyfill.map((polyfillPath) => `import "${polyfillPath}";`).join("\n")}`;
	}
	/**
	* Resolves the `source` to a Node.js compat alias if possible.
	*
	* If there is an alias, the return value is an object with:
	* - `unresolved`: a bare import path to the polyfill (e.g. `unenv/runtime/node/crypto`)
	* - `resolved`: an absolute path to the polyfill (e.g. `/path/to/project/node_modules/unenv/runtime/node/child_process/index.mjs`)
	*/
	resolveNodeJsImport(source) {
		const alias = this.#env.alias[source];
		if (alias && !this.externals.has(alias)) return {
			unresolved: alias,
			resolved: resolvePathSync(alias, { url: import.meta.url })
		};
		if (this.entries.has(source)) return {
			unresolved: source,
			resolved: resolvePathSync(source, { url: import.meta.url })
		};
	}
};
/**
* Returns `true` if the given combination of compat dates and flags enables Node.js compatibility.
*/
function hasNodeJsCompat(workerConfig) {
	const nodeCompatMode = getNodeCompat(workerConfig.compatibility_date, workerConfig.compatibility_flags ?? []).mode;
	if (nodeCompatMode === "v2") return true;
	if (nodeCompatMode === "v1") throw new Error(`Unsupported Node.js compat mode (v1). Only the v2 mode is supported, either change your compat date to "2024-09-23" or later, or set the "nodejs_compat_v2" compatibility flag`);
	return false;
}
/**
* Returns true if Node.js async local storage (ALS) is enabled (and not full Node.js compatibility mode).
*/
function hasNodeJsAls(workerConfig) {
	return workerConfig !== void 0 && getNodeCompat(workerConfig.compatibility_date, workerConfig.compatibility_flags ?? []).mode === "als";
}
/**
* All the Node.js modules including their `node:...` aliases.
*/
const nodeJsBuiltins = new Set([...builtinModules, ...builtinModules.map((m) => `node:${m}`)]);
const NODEJS_MODULES_RE = /* @__PURE__ */ new RegExp(`^(node:)?(${builtinModules.join("|")})$`);
function isNodeAlsModule(modulePath) {
	return /^(?:node:)?async_hooks$/.test(modulePath);
}
function assertHasNodeJsCompat(nodeJsCompat) {
	assert(nodeJsCompat, `expected nodeJsCompat to be defined`);
}
var NodeJsCompatWarnings = class {
	sources = /* @__PURE__ */ new Map();
	timer;
	constructor(environmentName, resolvedViteConfig) {
		this.environmentName = environmentName;
		this.resolvedViteConfig = resolvedViteConfig;
	}
	registerImport(source, importer = "<unknown>") {
		const importers = this.sources.get(source) ?? /* @__PURE__ */ new Set();
		this.sources.set(source, importers);
		importers.add(importer);
		this.renderWarningsOnIdle();
	}
	renderWarningsOnIdle() {
		if (this.timer) clearTimeout(this.timer);
		this.timer = setTimeout(() => {
			this.renderWarnings();
			this.timer = void 0;
		}, 500);
	}
	renderWarnings() {
		if (this.sources.size > 0) {
			let message = `Unexpected Node.js imports for environment "${this.environmentName}". Do you need to enable the "nodejs_compat" compatibility flag? Refer to https://developers.cloudflare.com/workers/runtime-apis/nodejs/ for more details.
`;
			this.sources.forEach((importers, source) => {
				importers.forEach((importer) => {
					message += ` - "${source}" imported from "${nodePath.relative(this.resolvedViteConfig.root, importer)}"\n`;
				});
			});
			this.resolvedViteConfig.logger.warn(message, { timestamp: true });
			this.sources.clear();
		}
	}
};

//#endregion
//#region src/workers-configs.ts
/**
* Set of worker config options that are not applicable when using Vite
*/
const nonApplicableWorkerConfigs = {
	replacedByVite: {
		alias: {
			viteReplacement: "resolve.alias",
			viteDocs: "https://vite.dev/config/shared-options.html#resolve-alias"
		},
		define: {
			viteReplacement: "define",
			viteDocs: "https://vite.dev/config/shared-options.html#define"
		},
		minify: {
			viteReplacement: "build.minify",
			viteDocs: "https://vite.dev/config/build-options.html#build-minify"
		}
	},
	notRelevant: [
		"base_dir",
		"build",
		"find_additional_modules",
		"no_bundle",
		"preserve_file_names",
		"rules",
		"site",
		"tsconfig"
	]
};
/**
* The non applicable configs that can be and default to `undefined`
*/
const nullableNonApplicable = [
	"alias",
	"base_dir",
	"find_additional_modules",
	"minify",
	"no_bundle",
	"preserve_file_names",
	"site",
	"tsconfig"
];
function readWorkerConfig(configPath, env) {
	const nonApplicable = {
		replacedByVite: /* @__PURE__ */ new Set(),
		notRelevant: /* @__PURE__ */ new Set()
	};
	const config = wrangler.unstable_readConfig({
		config: configPath,
		env
	}, { preserveOriginalMain: true });
	const raw = structuredClone(config);
	nullableNonApplicable.forEach((prop) => {
		if (config[prop] !== void 0) {
			if (isReplacedByVite(prop)) nonApplicable.replacedByVite.add(prop);
			if (isNotRelevant(prop)) nonApplicable.notRelevant.add(prop);
		}
		delete config[prop];
	});
	if (config.build && (config.build.command || config.build.cwd)) nonApplicable.notRelevant.add("build");
	delete config["build"];
	if (config.define && Object.keys(config.define).length > 0) nonApplicable.replacedByVite.add("define");
	delete config["define"];
	if (config.rules.length > 0) nonApplicable.notRelevant.add("rules");
	return {
		raw,
		nonApplicable,
		config
	};
}
function getWarningForWorkersConfigs(configs) {
	if (!("auxiliaryWorkers" in configs) || configs.auxiliaryWorkers.length === 0) {
		const nonApplicableLines = getWorkerNonApplicableWarnLines(configs.entryWorker, `  - `);
		if (nonApplicableLines.length === 0) return;
		const lines$1 = [`\n\n\x1b[43mWARNING\x1b[0m: your worker config${configs.entryWorker.config.configPath ? ` (at \`${nodePath.relative("", configs.entryWorker.config.configPath)}\`)` : ""} contains the following configuration options which are ignored since they are not applicable when using Vite:`];
		nonApplicableLines.forEach((line) => lines$1.push(line));
		lines$1.push("");
		return lines$1.join("\n");
	}
	const lines = [];
	const processWorkerConfig = (workerConfig, isEntryWorker = false) => {
		const nonApplicableLines = getWorkerNonApplicableWarnLines(workerConfig, `    - `);
		if (nonApplicableLines.length > 0) {
			lines.push(`  - (${isEntryWorker ? "entry" : "auxiliary"}) worker${workerConfig.config.name ? ` "${workerConfig.config.name}"` : ""}${workerConfig.config.configPath ? ` (config at \`${nodePath.relative("", workerConfig.config.configPath)}\`)` : ""}`);
			nonApplicableLines.forEach((line) => lines.push(line));
		}
	};
	processWorkerConfig(configs.entryWorker, true);
	configs.auxiliaryWorkers.forEach((config) => processWorkerConfig(config));
	if (lines.length === 0) return;
	return [
		"\n\x1B[43mWARNING\x1B[0m: your workers configs contain configuration options which are ignored since they are not applicable when using Vite:",
		...lines,
		""
	].join("\n");
}
function getWorkerNonApplicableWarnLines(workerConfig, linePrefix) {
	const lines = [];
	const { replacedByVite, notRelevant } = workerConfig.nonApplicable;
	for (const config of replacedByVite) lines.push(`${linePrefix}\`${config}\` which is replaced by Vite's \`${nonApplicableWorkerConfigs.replacedByVite[config].viteReplacement}\` (docs: ${nonApplicableWorkerConfigs.replacedByVite[config].viteDocs})`);
	if (notRelevant.size > 0) lines.push(`${linePrefix}${[...notRelevant].map((config) => `\`${config}\``).join(", ")} which ${notRelevant.size > 1 ? "are" : "is"} not relevant in the context of a Vite project`);
	return lines;
}
function isReplacedByVite(configName) {
	return configName in nonApplicableWorkerConfigs["replacedByVite"];
}
function isNotRelevant(configName) {
	return nonApplicableWorkerConfigs.notRelevant.includes(configName);
}
function missingFieldErrorMessage(field, configPath, env) {
	return `No '${field}' field provided${configPath ? ` in '${configPath}'` : ""}${env ? ` for '${env}' environment` : ""}`;
}
/**
* Reads and sanitizes a worker config from a wrangler config file.
*/
function readWorkerConfigFromFile(configPath, env, opts) {
	if (opts?.visitedConfigPaths?.has(configPath)) throw new Error(`Duplicate Wrangler config path found: ${configPath}`);
	const result = readWorkerConfig(configPath, env);
	opts?.visitedConfigPaths?.add(configPath);
	return result;
}
/**
* Validates required fields and determines whether the config represents
* an assets-only worker or a worker with server logic.
*
* @param config The sanitized worker config (after merging defaults, file config, and config())
* @param raw The raw config (before sanitization)
* @param nonApplicable The non-applicable config map
* @param opts Options for validation
*/
function resolveWorkerType(config, raw, nonApplicable, opts) {
	if (!config.name) throw new Error(missingFieldErrorMessage("name", opts?.configPath, opts?.env));
	if (!config.topLevelName) throw new Error(missingFieldErrorMessage("top-level name", opts?.configPath, opts?.env));
	if (!config.compatibility_date) throw new Error(missingFieldErrorMessage("compatibility_date", opts?.configPath, opts?.env));
	const requiredFields = {
		topLevelName: config.topLevelName,
		name: config.name,
		compatibility_date: config.compatibility_date
	};
	if (opts?.isEntryWorker && !config.main) return {
		type: "assets-only",
		raw,
		config: {
			...config,
			...requiredFields
		},
		nonApplicable
	};
	if (!config.main) throw new Error(missingFieldErrorMessage("main", opts?.configPath, opts?.env));
	const resolvedMain = maybeResolveMain(config.main, opts?.configPath, opts?.root);
	return {
		type: "worker",
		raw,
		config: {
			...config,
			...requiredFields,
			main: resolvedMain
		},
		nonApplicable
	};
}
const ENTRY_MODULE_EXTENSIONS = [
	".js",
	".mjs",
	".ts",
	".mts",
	".jsx",
	".tsx"
];
/**
* If `main` ends with a valid file extension it is resolved to an absolute path.
* Else `main` is returned as is so that it can be resolved by Vite.
* This enables resolving entry modules relative to the Worker config while also supporting virtual modules and package exports.
*/
function maybeResolveMain(main, configPath, root) {
	if (!ENTRY_MODULE_EXTENSIONS.some((extension) => main.endsWith(extension))) return main;
	const baseDir = configPath ? nodePath.dirname(configPath) : root;
	if (!baseDir) return main;
	const resolvedMain = nodePath.resolve(baseDir, main);
	if (!fs$1.existsSync(resolvedMain)) throw new Error(`The provided Wrangler config main field (${resolvedMain}) doesn't point to an existing file`);
	return resolvedMain;
}
/**
* Returns the path to a wrangler config for a worker after having it validated
* (throws appropriate errors in case the validation fails)
*
* @param root the root of the vite project
* @param requestedConfigPath the requested config path, if any
* @param isForAuxiliaryWorker whether the config path is being requested for an auxiliary worker
* @returns a valid path to a config file, or undefined for entry workers when no config is found
*/
function getValidatedWranglerConfigPath(root, requestedConfigPath, isForAuxiliaryWorker = false) {
	if (requestedConfigPath) {
		const configPath = nodePath.resolve(root, requestedConfigPath);
		const errorMessagePrefix = `The provided configPath (${configPath})${isForAuxiliaryWorker ? " requested for one of your auxiliary workers" : ""}`;
		const fileExtension = nodePath.extname(configPath).slice(1);
		if (!allowedWranglerConfigExtensions.includes(fileExtension)) {
			const foundExtensionMessage = !fileExtension ? "no extension found" : `"${fileExtension}" found`;
			throw new Error(`${errorMessagePrefix} doesn't point to a file with the correct file extension. It should point to a jsonc, json or toml file (${foundExtensionMessage} instead)`);
		}
		const mainStat = fs$1.statSync(configPath, { throwIfNoEntry: false });
		if (!mainStat) throw new Error(`${errorMessagePrefix} doesn't point to an existing file`);
		if (mainStat.isDirectory()) throw new Error(`${errorMessagePrefix} points to a directory. It should point to a file.`);
		return configPath;
	}
	if (isForAuxiliaryWorker) return;
	return findWranglerConfig(root);
}
function findWranglerConfig(root) {
	for (const extension of allowedWranglerConfigExtensions) {
		const configPath = nodePath.join(root, `wrangler.${extension}`);
		if (fs$1.existsSync(configPath)) return configPath;
	}
}
const allowedWranglerConfigExtensions = [
	"jsonc",
	"json",
	"toml"
];

//#endregion
//#region src/plugin-config.ts
function filterEntryWorkerConfig(config) {
	const { topLevelName: _topLevelName, name: _name,...filteredConfig } = config;
	return filteredConfig;
}
function customizeWorkerConfig(options) {
	const configResult = typeof options.configCustomizer === "function" ? "entryWorkerConfig" in options ? options.configCustomizer(options.workerConfig, { entryWorkerConfig: filterEntryWorkerConfig(options.entryWorkerConfig) }) : options.configCustomizer(options.workerConfig) : options.configCustomizer;
	if (configResult) return defu(configResult, options.workerConfig);
	return options.workerConfig;
}
/**
* Resolves the config for a single worker, applying defaults, file config, and config().
*/
function resolveWorkerConfig(options) {
	const isEntryWorker = !("entryWorkerConfig" in options);
	let workerConfig;
	let raw;
	let nonApplicable;
	if (options.configPath) ({raw, config: workerConfig, nonApplicable} = readWorkerConfigFromFile(options.configPath, options.env, { visitedConfigPaths: options.visitedConfigPaths }));
	else {
		workerConfig = { ...wrangler.unstable_defaultWranglerConfig };
		raw = structuredClone(workerConfig);
		nonApplicable = {
			replacedByVite: /* @__PURE__ */ new Set(),
			notRelevant: /* @__PURE__ */ new Set()
		};
	}
	workerConfig = "entryWorkerConfig" in options ? customizeWorkerConfig({
		workerConfig,
		configCustomizer: options.configCustomizer,
		entryWorkerConfig: options.entryWorkerConfig
	}) : customizeWorkerConfig({
		workerConfig,
		configCustomizer: options.configCustomizer
	});
	const { date } = getLocalWorkerdCompatibilityDate({ projectPath: options.root });
	workerConfig.compatibility_date ??= date;
	if (isEntryWorker) workerConfig.name ??= wrangler.unstable_getWorkerNameFromProject(options.root);
	workerConfig.topLevelName ??= workerConfig.name;
	return resolveWorkerType(workerConfig, raw, nonApplicable, {
		isEntryWorker,
		configPath: options.configPath,
		root: options.root,
		env: options.env
	});
}
function resolvePluginConfig(pluginConfig, userConfig, viteEnv) {
	const shared = {
		persistState: pluginConfig.persistState ?? true,
		inspectorPort: pluginConfig.inspectorPort,
		experimental: pluginConfig.experimental ?? {}
	};
	const root = userConfig.root ? nodePath.resolve(userConfig.root) : process.cwd();
	const prefixedEnv = vite.loadEnv(viteEnv.mode, root, ["CLOUDFLARE_", "WRANGLER_HYPERDRIVE_LOCAL_CONNECTION_STRING_"]);
	Object.assign(process.env, prefixedEnv);
	if (viteEnv.isPreview) return {
		...shared,
		remoteBindings: pluginConfig.remoteBindings ?? true,
		type: "preview",
		workers: getWorkerConfigs(root)
	};
	const configPaths = /* @__PURE__ */ new Set();
	const cloudflareEnv = prefixedEnv.CLOUDFLARE_ENV;
	const entryWorkerResolvedConfig = resolveWorkerConfig({
		root,
		configPath: getValidatedWranglerConfigPath(root, pluginConfig.configPath),
		env: prefixedEnv.CLOUDFLARE_ENV,
		configCustomizer: pluginConfig.config,
		visitedConfigPaths: configPaths
	});
	if (entryWorkerResolvedConfig.type === "assets-only") return {
		...shared,
		type: "assets-only",
		cloudflareEnv,
		config: entryWorkerResolvedConfig.config,
		configPaths,
		remoteBindings: pluginConfig.remoteBindings ?? true,
		rawConfigs: { entryWorker: entryWorkerResolvedConfig }
	};
	const entryWorkerConfig = entryWorkerResolvedConfig.config;
	const entryWorkerEnvironmentName = pluginConfig.viteEnvironment?.name ?? workerNameToEnvironmentName(entryWorkerConfig.topLevelName);
	let staticRouting;
	if (Array.isArray(entryWorkerConfig.assets?.run_worker_first)) staticRouting = parseStaticRouting(entryWorkerConfig.assets.run_worker_first);
	const environmentNameToWorkerMap = new Map([[entryWorkerEnvironmentName, resolveWorker(entryWorkerConfig)]]);
	const auxiliaryWorkersResolvedConfigs = [];
	for (const auxiliaryWorker of pluginConfig.auxiliaryWorkers ?? []) {
		const workerResolvedConfig = resolveWorkerConfig({
			root,
			configPath: getValidatedWranglerConfigPath(root, auxiliaryWorker.configPath, true),
			env: cloudflareEnv,
			configCustomizer: "config" in auxiliaryWorker ? auxiliaryWorker.config : void 0,
			entryWorkerConfig,
			visitedConfigPaths: configPaths
		});
		auxiliaryWorkersResolvedConfigs.push(workerResolvedConfig);
		const workerEnvironmentName = auxiliaryWorker.viteEnvironment?.name ?? workerNameToEnvironmentName(workerResolvedConfig.config.topLevelName);
		if (environmentNameToWorkerMap.has(workerEnvironmentName)) throw new Error(`Duplicate Vite environment name found: ${workerEnvironmentName}`);
		environmentNameToWorkerMap.set(workerEnvironmentName, resolveWorker(workerResolvedConfig.config));
	}
	return {
		...shared,
		type: "workers",
		cloudflareEnv,
		configPaths,
		environmentNameToWorkerMap,
		entryWorkerEnvironmentName,
		staticRouting,
		remoteBindings: pluginConfig.remoteBindings ?? true,
		rawConfigs: {
			entryWorker: entryWorkerResolvedConfig,
			auxiliaryWorkers: auxiliaryWorkersResolvedConfigs
		}
	};
}
function workerNameToEnvironmentName(workerName) {
	return workerName.replaceAll("-", "_");
}
function resolveWorker(workerConfig) {
	return {
		config: workerConfig,
		nodeJsCompat: hasNodeJsCompat(workerConfig) ? new NodeJsCompat(workerConfig) : void 0
	};
}

//#endregion
//#region ../../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
const comma = ",".charCodeAt(0);
const semicolon = ";".charCodeAt(0);
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const intToChar = new Uint8Array(64);
const charToInt = new Uint8Array(128);
for (let i$1 = 0; i$1 < 64; i$1++) {
	const c = chars.charCodeAt(i$1);
	intToChar[i$1] = c;
	charToInt[c] = i$1;
}
function encodeInteger(builder, num, relative$1) {
	let delta = num - relative$1;
	delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
	do {
		let clamped = delta & 31;
		delta >>>= 5;
		if (delta > 0) clamped |= 32;
		builder.write(intToChar[clamped]);
	} while (delta > 0);
	return num;
}
const bufLength = 1024 * 16;
const td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? { decode(buf) {
	return Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength).toString();
} } : { decode(buf) {
	let out = "";
	for (let i$1 = 0; i$1 < buf.length; i$1++) out += String.fromCharCode(buf[i$1]);
	return out;
} };
var StringWriter = class {
	constructor() {
		this.pos = 0;
		this.out = "";
		this.buffer = new Uint8Array(bufLength);
	}
	write(v) {
		const { buffer } = this;
		buffer[this.pos++] = v;
		if (this.pos === bufLength) {
			this.out += td.decode(buffer);
			this.pos = 0;
		}
	}
	flush() {
		const { buffer, out, pos } = this;
		return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
	}
};
function encode(decoded) {
	const writer = new StringWriter();
	let sourcesIndex = 0;
	let sourceLine = 0;
	let sourceColumn = 0;
	let namesIndex = 0;
	for (let i$1 = 0; i$1 < decoded.length; i$1++) {
		const line = decoded[i$1];
		if (i$1 > 0) writer.write(semicolon);
		if (line.length === 0) continue;
		let genColumn = 0;
		for (let j = 0; j < line.length; j++) {
			const segment = line[j];
			if (j > 0) writer.write(comma);
			genColumn = encodeInteger(writer, segment[0], genColumn);
			if (segment.length === 1) continue;
			sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
			sourceLine = encodeInteger(writer, segment[2], sourceLine);
			sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
			if (segment.length === 4) continue;
			namesIndex = encodeInteger(writer, segment[4], namesIndex);
		}
	}
	return writer.flush();
}

//#endregion
//#region ../../node_modules/.pnpm/magic-string@0.30.17/node_modules/magic-string/dist/magic-string.es.mjs
var BitSet = class BitSet {
	constructor(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	}
	add(n$1) {
		this.bits[n$1 >> 5] |= 1 << (n$1 & 31);
	}
	has(n$1) {
		return !!(this.bits[n$1 >> 5] & 1 << (n$1 & 31));
	}
};
var Chunk = class Chunk {
	constructor(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;
		this.intro = "";
		this.outro = "";
		this.content = content;
		this.storeName = false;
		this.edited = false;
		this.previous = null;
		this.next = null;
	}
	appendLeft(content) {
		this.outro += content;
	}
	appendRight(content) {
		this.intro = this.intro + content;
	}
	clone() {
		const chunk = new Chunk(this.start, this.end, this.original);
		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;
		return chunk;
	}
	contains(index) {
		return this.start < index && index < this.end;
	}
	eachNext(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	}
	eachPrevious(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	}
	edit(content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = "";
			this.outro = "";
		}
		this.storeName = storeName;
		this.edited = true;
		return this;
	}
	prependLeft(content) {
		this.outro = content + this.outro;
	}
	prependRight(content) {
		this.intro = content + this.intro;
	}
	reset() {
		this.intro = "";
		this.outro = "";
		if (this.edited) {
			this.content = this.original;
			this.storeName = false;
			this.edited = false;
		}
	}
	split(index) {
		const sliceIndex = index - this.start;
		const originalBefore = this.original.slice(0, sliceIndex);
		const originalAfter = this.original.slice(sliceIndex);
		this.original = originalBefore;
		const newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = "";
		this.end = index;
		if (this.edited) {
			newChunk.edit("", false);
			this.content = "";
		} else this.content = originalBefore;
		newChunk.next = this.next;
		if (newChunk.next) newChunk.next.previous = newChunk;
		newChunk.previous = this;
		this.next = newChunk;
		return newChunk;
	}
	toString() {
		return this.intro + this.content + this.outro;
	}
	trimEnd(rx) {
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit("", void 0, true);
				if (this.edited) this.edit(trimmed, this.storeName, true);
			}
			return true;
		} else {
			this.edit("", void 0, true);
			this.intro = this.intro.replace(rx, "");
			if (this.intro.length) return true;
		}
	}
	trimStart(rx) {
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				const newChunk = this.split(this.end - trimmed.length);
				if (this.edited) newChunk.edit(trimmed, this.storeName, true);
				this.edit("", void 0, true);
			}
			return true;
		} else {
			this.edit("", void 0, true);
			this.outro = this.outro.replace(rx, "");
			if (this.outro.length) return true;
		}
	}
};
function getBtoa() {
	if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
	else if (typeof Buffer === "function") return (str) => Buffer.from(str, "utf-8").toString("base64");
	else return () => {
		throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
	};
}
const btoa$1 = /* @__PURE__ */ getBtoa();
var SourceMap = class {
	constructor(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode(properties.mappings);
		if (typeof properties.x_google_ignoreList !== "undefined") this.x_google_ignoreList = properties.x_google_ignoreList;
		if (typeof properties.debugId !== "undefined") this.debugId = properties.debugId;
	}
	toString() {
		return JSON.stringify(this);
	}
	toUrl() {
		return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
	}
};
function guessIndent(code) {
	const lines = code.split("\n");
	const tabbed = lines.filter((line) => /^\t+/.test(line));
	const spaced = lines.filter((line) => /^ {2,}/.test(line));
	if (tabbed.length === 0 && spaced.length === 0) return null;
	if (tabbed.length >= spaced.length) return "	";
	const min = spaced.reduce((previous, current) => {
		const numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);
	return new Array(min + 1).join(" ");
}
function getRelativePath(from, to) {
	const fromParts = from.split(/[/\\]/);
	const toParts = to.split(/[/\\]/);
	fromParts.pop();
	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}
	if (fromParts.length) {
		let i$1 = fromParts.length;
		while (i$1--) fromParts[i$1] = "..";
	}
	return fromParts.concat(toParts).join("/");
}
const toString = Object.prototype.toString;
function isObject(thing) {
	return toString.call(thing) === "[object Object]";
}
function getLocator(source) {
	const originalLines = source.split("\n");
	const lineOffsets = [];
	for (let i$1 = 0, pos = 0; i$1 < originalLines.length; i$1++) {
		lineOffsets.push(pos);
		pos += originalLines[i$1].length + 1;
	}
	return function locate(index) {
		let i$1 = 0;
		let j = lineOffsets.length;
		while (i$1 < j) {
			const m = i$1 + j >> 1;
			if (index < lineOffsets[m]) j = m;
			else i$1 = m + 1;
		}
		const line = i$1 - 1;
		return {
			line,
			column: index - lineOffsets[line]
		};
	};
}
const wordRegex = /\w/;
var Mappings = class {
	constructor(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	}
	addEdit(sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			const contentLengthMinusOne = content.length - 1;
			let contentLineEnd = content.indexOf("\n", 0);
			let previousContentLineEnd = -1;
			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
				const segment$1 = [
					this.generatedCodeColumn,
					sourceIndex,
					loc.line,
					loc.column
				];
				if (nameIndex >= 0) segment$1.push(nameIndex);
				this.rawSegments.push(segment$1);
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				previousContentLineEnd = contentLineEnd;
				contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
			}
			const segment = [
				this.generatedCodeColumn,
				sourceIndex,
				loc.line,
				loc.column
			];
			if (nameIndex >= 0) segment.push(nameIndex);
			this.rawSegments.push(segment);
			this.advance(content.slice(previousContentLineEnd + 1));
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
			this.advance(content);
		}
		this.pending = null;
	}
	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
		let originalCharIndex = chunk.start;
		let first = true;
		let charInHiresBoundary = false;
		while (originalCharIndex < chunk.end) {
			if (original[originalCharIndex] === "\n") {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first = true;
				charInHiresBoundary = false;
			} else {
				if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
					const segment = [
						this.generatedCodeColumn,
						sourceIndex,
						loc.line,
						loc.column
					];
					if (this.hires === "boundary") if (wordRegex.test(original[originalCharIndex])) {
						if (!charInHiresBoundary) {
							this.rawSegments.push(segment);
							charInHiresBoundary = true;
						}
					} else {
						this.rawSegments.push(segment);
						charInHiresBoundary = false;
					}
					else this.rawSegments.push(segment);
				}
				loc.column += 1;
				this.generatedCodeColumn += 1;
				first = false;
			}
			originalCharIndex += 1;
		}
		this.pending = null;
	}
	advance(str) {
		if (!str) return;
		const lines = str.split("\n");
		if (lines.length > 1) {
			for (let i$1 = 0; i$1 < lines.length - 1; i$1++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}
		this.generatedCodeColumn += lines[lines.length - 1].length;
	}
};
const n = "\n";
const warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false
};
var MagicString = class MagicString {
	constructor(string, options = {}) {
		const chunk = new Chunk(0, string.length, string);
		Object.defineProperties(this, {
			original: {
				writable: true,
				value: string
			},
			outro: {
				writable: true,
				value: ""
			},
			intro: {
				writable: true,
				value: ""
			},
			firstChunk: {
				writable: true,
				value: chunk
			},
			lastChunk: {
				writable: true,
				value: chunk
			},
			lastSearchedChunk: {
				writable: true,
				value: chunk
			},
			byStart: {
				writable: true,
				value: {}
			},
			byEnd: {
				writable: true,
				value: {}
			},
			filename: {
				writable: true,
				value: options.filename
			},
			indentExclusionRanges: {
				writable: true,
				value: options.indentExclusionRanges
			},
			sourcemapLocations: {
				writable: true,
				value: new BitSet()
			},
			storedNames: {
				writable: true,
				value: {}
			},
			indentStr: {
				writable: true,
				value: void 0
			},
			ignoreList: {
				writable: true,
				value: options.ignoreList
			},
			offset: {
				writable: true,
				value: options.offset || 0
			}
		});
		this.byStart[0] = chunk;
		this.byEnd[string.length] = chunk;
	}
	addSourcemapLocation(char) {
		this.sourcemapLocations.add(char);
	}
	append(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.outro += content;
		return this;
	}
	appendLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.appendLeft(content);
		else this.intro += content;
		return this;
	}
	appendRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.appendRight(content);
		else this.outro += content;
		return this;
	}
	clone() {
		const cloned = new MagicString(this.original, {
			filename: this.filename,
			offset: this.offset
		});
		let originalChunk = this.firstChunk;
		let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;
			const nextOriginalChunk = originalChunk.next;
			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;
				clonedChunk = nextClonedChunk;
			}
			originalChunk = nextOriginalChunk;
		}
		cloned.lastChunk = clonedChunk;
		if (this.indentExclusionRanges) cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
		cloned.intro = this.intro;
		cloned.outro = this.outro;
		return cloned;
	}
	generateDecodedMap(options) {
		options = options || {};
		const sourceIndex = 0;
		const names = Object.keys(this.storedNames);
		const mappings = new Mappings(options.hires);
		const locate = getLocator(this.original);
		if (this.intro) mappings.advance(this.intro);
		this.firstChunk.eachNext((chunk) => {
			const loc = locate(chunk.start);
			if (chunk.intro.length) mappings.advance(chunk.intro);
			if (chunk.edited) mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
			else mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
			if (chunk.outro.length) mappings.advance(chunk.outro);
		});
		return {
			file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
			sources: [options.source ? getRelativePath(options.file || "", options.source) : options.file || ""],
			sourcesContent: options.includeContent ? [this.original] : void 0,
			names,
			mappings: mappings.raw,
			x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
		};
	}
	generateMap(options) {
		return new SourceMap(this.generateDecodedMap(options));
	}
	_ensureindentStr() {
		if (this.indentStr === void 0) this.indentStr = guessIndent(this.original);
	}
	_getRawIndentString() {
		this._ensureindentStr();
		return this.indentStr;
	}
	getIndentString() {
		this._ensureindentStr();
		return this.indentStr === null ? "	" : this.indentStr;
	}
	indent(indentStr, options) {
		const pattern = /^[^\r\n]/gm;
		if (isObject(indentStr)) {
			options = indentStr;
			indentStr = void 0;
		}
		if (indentStr === void 0) {
			this._ensureindentStr();
			indentStr = this.indentStr || "	";
		}
		if (indentStr === "") return this;
		options = options || {};
		const isExcluded = {};
		if (options.exclude) (typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude).forEach((exclusion) => {
			for (let i$1 = exclusion[0]; i$1 < exclusion[1]; i$1 += 1) isExcluded[i$1] = true;
		});
		let shouldIndentNextCharacter = options.indentStart !== false;
		const replacer = (match) => {
			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
			shouldIndentNextCharacter = true;
			return match;
		};
		this.intro = this.intro.replace(pattern, replacer);
		let charIndex = 0;
		let chunk = this.firstChunk;
		while (chunk) {
			const end = chunk.end;
			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);
					if (chunk.content.length) shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
				}
			} else {
				charIndex = chunk.start;
				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						const char = this.original[charIndex];
						if (char === "\n") shouldIndentNextCharacter = true;
						else if (char !== "\r" && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;
							if (charIndex === chunk.start) chunk.prependRight(indentStr);
							else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}
					charIndex += 1;
				}
			}
			charIndex = chunk.end;
			chunk = chunk.next;
		}
		this.outro = this.outro.replace(pattern, replacer);
		return this;
	}
	insert() {
		throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
	}
	insertLeft(index, content) {
		if (!warned.insertLeft) {
			console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
			warned.insertLeft = true;
		}
		return this.appendLeft(index, content);
	}
	insertRight(index, content) {
		if (!warned.insertRight) {
			console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
			warned.insertRight = true;
		}
		return this.prependRight(index, content);
	}
	move(start, end, index) {
		start = start + this.offset;
		end = end + this.offset;
		index = index + this.offset;
		if (index >= start && index <= end) throw new Error("Cannot move a selection inside itself");
		this._split(start);
		this._split(end);
		this._split(index);
		const first = this.byStart[start];
		const last = this.byEnd[end];
		const oldLeft = first.previous;
		const oldRight = last.next;
		const newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) return this;
		const newLeft = newRight ? newRight.previous : this.lastChunk;
		if (oldLeft) oldLeft.next = oldRight;
		if (oldRight) oldRight.previous = oldLeft;
		if (newLeft) newLeft.next = first;
		if (newRight) newRight.previous = last;
		if (!first.previous) this.firstChunk = last.next;
		if (!last.next) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}
		first.previous = newLeft;
		last.next = newRight || null;
		if (!newLeft) this.firstChunk = first;
		if (!newRight) this.lastChunk = last;
		return this;
	}
	overwrite(start, end, content, options) {
		options = options || {};
		return this.update(start, end, content, {
			...options,
			overwrite: !options.contentOnly
		});
	}
	update(start, end, content, options) {
		start = start + this.offset;
		end = end + this.offset;
		if (typeof content !== "string") throw new TypeError("replacement content must be a string");
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (end > this.original.length) throw new Error("end is out of bounds");
		if (start === end) throw new Error("Cannot overwrite a zero-length range  use appendLeft or prependRight instead");
		this._split(start);
		this._split(end);
		if (options === true) {
			if (!warned.storeName) {
				console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
				warned.storeName = true;
			}
			options = { storeName: true };
		}
		const storeName = options !== void 0 ? options.storeName : false;
		const overwrite = options !== void 0 ? options.overwrite : false;
		if (storeName) {
			const original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, {
				writable: true,
				value: true,
				enumerable: true
			});
		}
		const first = this.byStart[start];
		const last = this.byEnd[end];
		if (first) {
			let chunk = first;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) throw new Error("Cannot overwrite across a split point");
				chunk = chunk.next;
				chunk.edit("", false);
			}
			first.edit(content, storeName, !overwrite);
		} else {
			const newChunk = new Chunk(start, end, "").edit(content, storeName);
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	}
	prepend(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.intro = content + this.intro;
		return this;
	}
	prependLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.prependLeft(content);
		else this.intro = content + this.intro;
		return this;
	}
	prependRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.prependRight(content);
		else this.outro = content + this.outro;
		return this;
	}
	remove(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.intro = "";
			chunk.outro = "";
			chunk.edit("");
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	reset(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.reset();
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1];
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
		} while (chunk = chunk.previous);
		if (this.intro.length) return this.intro[this.intro.length - 1];
		return "";
	}
	lastLine() {
		let lineIndex = this.outro.lastIndexOf(n);
		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
		let lineStr = this.outro;
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.outro + lineStr;
			}
			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.content + lineStr;
			}
			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.intro + lineStr;
			}
		} while (chunk = chunk.previous);
		lineIndex = this.intro.lastIndexOf(n);
		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
		return this.intro + lineStr;
	}
	slice(start = 0, end = this.original.length - this.offset) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		let result = "";
		let chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			if (chunk.start < end && chunk.end >= end) return result;
			chunk = chunk.next;
		}
		if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
		const startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) result += chunk.intro;
			const containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
			result += chunk.content.slice(sliceStart, sliceEnd);
			if (chunk.outro && (!containsEnd || chunk.end === end)) result += chunk.outro;
			if (containsEnd) break;
			chunk = chunk.next;
		}
		return result;
	}
	snip(start, end) {
		const clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);
		return clone;
	}
	_split(index) {
		if (this.byStart[index] || this.byEnd[index]) return;
		let chunk = this.lastSearchedChunk;
		const searchForward = index > chunk.end;
		while (chunk) {
			if (chunk.contains(index)) return this._splitChunk(chunk, index);
			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
		}
	}
	_splitChunk(chunk, index) {
		if (chunk.edited && chunk.content.length) {
			const loc = getLocator(this.original)(index);
			throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column}  "${chunk.original}")`);
		}
		const newChunk = chunk.split(index);
		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;
		if (chunk === this.lastChunk) this.lastChunk = newChunk;
		this.lastSearchedChunk = chunk;
		return true;
	}
	toString() {
		let str = this.intro;
		let chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}
		return str + this.outro;
	}
	isEmpty() {
		let chunk = this.firstChunk;
		do
			if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
		while (chunk = chunk.next);
		return true;
	}
	length() {
		let chunk = this.firstChunk;
		let length = 0;
		do
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		while (chunk = chunk.next);
		return length;
	}
	trimLines() {
		return this.trim("[\\r\\n]");
	}
	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}
	trimEndAborted(charType) {
		const rx = /* @__PURE__ */ new RegExp((charType || "\\s") + "+$");
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		let chunk = this.lastChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimEnd(rx);
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.previous;
		} while (chunk);
		return false;
	}
	trimEnd(charType) {
		this.trimEndAborted(charType);
		return this;
	}
	trimStartAborted(charType) {
		const rx = /* @__PURE__ */ new RegExp("^" + (charType || "\\s") + "+");
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		let chunk = this.firstChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimStart(rx);
			if (chunk.end !== end) {
				if (chunk === this.lastChunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.next;
		} while (chunk);
		return false;
	}
	trimStart(charType) {
		this.trimStartAborted(charType);
		return this;
	}
	hasChanged() {
		return this.original !== this.toString();
	}
	_replaceRegexp(searchValue, replacement) {
		function getReplacement(match, str) {
			if (typeof replacement === "string") return replacement.replace(/\$(\$|&|\d+)/g, (_, i$1) => {
				if (i$1 === "$") return "$";
				if (i$1 === "&") return match[0];
				if (+i$1 < match.length) return match[+i$1];
				return `$${i$1}`;
			});
			else return replacement(...match, match.index, str, match.groups);
		}
		function matchAll(re$5, str) {
			let match;
			const matches = [];
			while (match = re$5.exec(str)) matches.push(match);
			return matches;
		}
		if (searchValue.global) matchAll(searchValue, this.original).forEach((match) => {
			if (match.index != null) {
				const replacement$1 = getReplacement(match, this.original);
				if (replacement$1 !== match[0]) this.overwrite(match.index, match.index + match[0].length, replacement$1);
			}
		});
		else {
			const match = this.original.match(searchValue);
			if (match && match.index != null) {
				const replacement$1 = getReplacement(match, this.original);
				if (replacement$1 !== match[0]) this.overwrite(match.index, match.index + match[0].length, replacement$1);
			}
		}
		return this;
	}
	_replaceString(string, replacement) {
		const { original } = this;
		const index = original.indexOf(string);
		if (index !== -1) this.overwrite(index, index + string.length, replacement);
		return this;
	}
	replace(searchValue, replacement) {
		if (typeof searchValue === "string") return this._replaceString(searchValue, replacement);
		return this._replaceRegexp(searchValue, replacement);
	}
	_replaceAllString(string, replacement) {
		const { original } = this;
		const stringLength = string.length;
		for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) if (original.slice(index, index + stringLength) !== replacement) this.overwrite(index, index + stringLength, replacement);
		return this;
	}
	replaceAll(searchValue, replacement) {
		if (typeof searchValue === "string") return this._replaceAllString(searchValue, replacement);
		if (!searchValue.global) throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");
		return this._replaceRegexp(searchValue, replacement);
	}
};

//#endregion
//#region src/plugins/additional-modules.ts
/**
* Plugin to support additional module types (`CompiledWasm`, `Data` and `Text`)
*/
const additionalModulesPlugin = createPlugin("additional-modules", (ctx) => {
	const additionalModulePaths = /* @__PURE__ */ new Set();
	return {
		enforce: "pre",
		applyToEnvironment(environment) {
			return ctx.getWorkerConfig(environment.name) !== void 0;
		},
		async resolveId(source, importer, options) {
			const additionalModuleType = matchAdditionalModule(source);
			if (!additionalModuleType) return;
			const resolved = await this.resolve(cleanUrl(source), importer, options);
			if (!resolved) throw new Error(`Import "${source}" not found. Does the file exist?`);
			additionalModulePaths.add(resolved.id);
			return {
				external: true,
				id: createModuleReference(additionalModuleType, resolved.id)
			};
		},
		hotUpdate(options) {
			if (additionalModulePaths.has(options.file)) {
				options.server.restart();
				return [];
			}
		},
		async renderChunk(code, chunk) {
			const matches = code.matchAll(additionalModuleGlobalRE);
			let magicString;
			for (const match of matches) {
				magicString ??= new MagicString(code);
				const [full, _, modulePath] = match;
				assert(modulePath, `Unexpected error: module path not found in reference ${full}.`);
				let source;
				try {
					source = await fsp.readFile(modulePath);
				} catch {
					throw new Error(`Import "${modulePath}" not found. Does the file exist?`);
				}
				const referenceId = this.emitFile({
					type: "asset",
					name: nodePath.basename(modulePath),
					originalFileName: modulePath,
					source
				});
				const emittedFileName = this.getFileName(referenceId);
				const relativePath = vite.normalizePath(nodePath.relative(nodePath.dirname(chunk.fileName), emittedFileName));
				const importPath = relativePath.startsWith(".") ? relativePath : `./${relativePath}`;
				magicString.update(match.index, match.index + full.length, importPath);
			}
			if (magicString) return {
				code: magicString.toString(),
				map: this.environment.config.build.sourcemap ? magicString.generateMap({ hires: "boundary" }) : null
			};
		}
	};
});
const ADDITIONAL_MODULE_PATTERN = `__CLOUDFLARE_MODULE__(${[
	"CompiledWasm",
	"Data",
	"Text"
].join("|")})__(.*?)__CLOUDFLARE_MODULE__`;
const additionalModuleRE = new RegExp(ADDITIONAL_MODULE_PATTERN);
const additionalModuleGlobalRE = new RegExp(ADDITIONAL_MODULE_PATTERN, "g");
const moduleRules = [
	{
		type: "CompiledWasm",
		extensions: [".wasm", ".wasm?module"]
	},
	{
		type: "Data",
		extensions: [".bin"]
	},
	{
		type: "Text",
		extensions: [
			".txt",
			".html",
			".sql"
		]
	}
];
function matchAdditionalModule(source) {
	for (const rule of moduleRules) for (const extension of rule.extensions) if (source.endsWith(extension)) return rule.type;
	return null;
}
function createModuleReference(type, id) {
	return `__CLOUDFLARE_MODULE__${type}__${id}__CLOUDFLARE_MODULE__`;
}

//#endregion
//#region ../workers-shared/utils/configuration/constructConfiguration.ts
function constructRedirects({ redirects, redirectsFile, logger }) {
	if (!redirects) return {};
	const num_valid = redirects.rules.length;
	const num_invalid = redirects.invalid.length;
	const redirectsRelativePath = redirectsFile ? relative(process.cwd(), redirectsFile) : "";
	logger.log(` Parsed ${num_valid} valid redirect rule${num_valid === 1 ? "" : "s"}.`);
	if (num_invalid > 0) {
		let invalidRedirectRulesList = ``;
		for (const { line, lineNumber, message } of redirects.invalid) {
			invalidRedirectRulesList += ` ${message}\n`;
			if (line) invalidRedirectRulesList += `    at ${redirectsRelativePath}${lineNumber ? `:${lineNumber}` : ""} | ${line}\n\n`;
		}
		logger.warn(`Found ${num_invalid} invalid redirect rule${num_invalid === 1 ? "" : "s"}:\n${invalidRedirectRulesList}`);
	}
	if (num_valid === 0) return {};
	const staticRedirects = {};
	const dynamicRedirects = {};
	let canCreateStaticRule = true;
	for (const rule of redirects.rules) {
		if (!rule.from.match(SPLAT_REGEX) && !rule.from.match(PLACEHOLDER_REGEX)) if (canCreateStaticRule) {
			staticRedirects[rule.from] = {
				status: rule.status,
				to: rule.to,
				lineNumber: rule.lineNumber
			};
			continue;
		} else logger.info(`The redirect rule ${rule.from}  ${rule.status} ${rule.to} could be made more performant by bringing it above any lines with splats or placeholders.`);
		dynamicRedirects[rule.from] = {
			status: rule.status,
			to: rule.to
		};
		canCreateStaticRule = false;
	}
	return { redirects: {
		version: REDIRECTS_VERSION,
		staticRules: staticRedirects,
		rules: dynamicRedirects
	} };
}
function constructHeaders({ headers, headersFile, logger }) {
	if (!headers) return {};
	const num_valid = headers.rules.length;
	const num_invalid = headers.invalid.length;
	const headersRelativePath = headersFile ? relative(process.cwd(), headersFile) : "";
	logger.log(` Parsed ${num_valid} valid header rule${num_valid === 1 ? "" : "s"}.`);
	if (num_invalid > 0) {
		let invalidHeaderRulesList = ``;
		for (const { line, lineNumber, message } of headers.invalid) {
			invalidHeaderRulesList += ` ${message}\n`;
			if (line) invalidHeaderRulesList += `    at ${headersRelativePath}${lineNumber ? `:${lineNumber}` : ""} | ${line}\n\n`;
		}
		logger.warn(`Found ${num_invalid} invalid header rule${num_invalid === 1 ? "" : "s"}:\n${invalidHeaderRulesList}`);
	}
	if (num_valid === 0) return {};
	const rules = {};
	for (const rule of headers.rules) {
		const configuredRule = {};
		if (Object.keys(rule.headers).length) configuredRule.set = rule.headers;
		if (rule.unsetHeaders.length) configuredRule.unset = rule.unsetHeaders;
		rules[rule.path] = configuredRule;
	}
	return { headers: {
		version: HEADERS_VERSION,
		rules
	} };
}

//#endregion
//#region ../workers-shared/utils/configuration/validateURL.ts
const extractPathname = (path = "/", includeSearch, includeHash) => {
	if (!path.startsWith("/")) path = `/${path}`;
	const url = new URL(`//${path}`, "relative://");
	return `${url.pathname}${includeSearch ? url.search : ""}${includeHash ? url.hash : ""}`;
};
const URL_REGEX = /^https:\/\/+(?<host>[^/]+)\/?(?<path>.*)/;
const HOST_WITH_PORT_REGEX = /.*:\d+$/;
const PATH_REGEX = /^\//;
const validateUrl = (token, onlyRelative = false, disallowPorts = false, includeSearch = false, includeHash = false) => {
	const host = URL_REGEX.exec(token);
	if (host && host.groups && host.groups.host) {
		if (onlyRelative) return [void 0, `Only relative URLs are allowed. Skipping absolute URL ${token}.`];
		if (disallowPorts && host.groups.host.match(HOST_WITH_PORT_REGEX)) return [void 0, `Specifying ports is not supported. Skipping absolute URL ${token}.`];
		return [`https://${host.groups.host}${extractPathname(host.groups.path, includeSearch, includeHash)}`, void 0];
	} else {
		if (!token.startsWith("/") && onlyRelative) token = `/${token}`;
		if (PATH_REGEX.exec(token)) try {
			return [extractPathname(token, includeSearch, includeHash), void 0];
		} catch {
			return [void 0, `Error parsing URL segment ${token}. Skipping.`];
		}
	}
	return [void 0, onlyRelative ? "URLs should begin with a forward-slash." : "URLs should either be relative (e.g. begin with a forward-slash), or use HTTPS (e.g. begin with \"https://\")."];
};
function urlHasHost(token) {
	const host = URL_REGEX.exec(token);
	return Boolean(host && host.groups && host.groups.host);
}

//#endregion
//#region ../workers-shared/utils/configuration/parseHeaders.ts
const LINE_IS_PROBABLY_A_PATH = /* @__PURE__ */ new RegExp(/^([^\s]+:\/\/|^\/)/);
function parseHeaders(input, { maxRules = MAX_HEADER_RULES, maxLineLength = MAX_LINE_LENGTH } = {}) {
	const lines = input.split("\n");
	const rules = [];
	const invalid = [];
	let rule = void 0;
	for (let i$1 = 0; i$1 < lines.length; i$1++) {
		const line = (lines[i$1] || "").trim();
		if (line.length === 0 || line.startsWith("#")) continue;
		if (line.length > maxLineLength) {
			invalid.push({ message: `Ignoring line ${i$1 + 1} as it exceeds the maximum allowed length of ${maxLineLength}.` });
			continue;
		}
		if (LINE_IS_PROBABLY_A_PATH.test(line)) {
			if (rules.length >= maxRules) {
				invalid.push({ message: `Maximum number of rules supported is ${maxRules}. Skipping remaining ${lines.length - i$1} lines of file.` });
				break;
			}
			if (rule) if (isValidRule(rule)) rules.push({
				path: rule.path,
				headers: rule.headers,
				unsetHeaders: rule.unsetHeaders
			});
			else invalid.push({
				line: rule.line,
				lineNumber: i$1 + 1,
				message: "No headers specified"
			});
			const [path, pathError] = validateUrl(line, false, true);
			if (pathError) {
				invalid.push({
					line,
					lineNumber: i$1 + 1,
					message: pathError
				});
				rule = void 0;
				continue;
			}
			rule = {
				path,
				line,
				headers: {},
				unsetHeaders: []
			};
			continue;
		}
		if (!line.includes(HEADER_SEPARATOR)) {
			if (!rule) invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: "Expected a path beginning with at least one forward-slash"
			});
			else if (line.trim().startsWith(UNSET_OPERATOR)) rule.unsetHeaders.push(line.trim().replace(UNSET_OPERATOR, ""));
			else invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: "Expected a colon-separated header pair (e.g. name: value)"
			});
			continue;
		}
		const [rawName, ...rawValue] = line.split(HEADER_SEPARATOR);
		const name = (rawName || "").trim().toLowerCase();
		if (name.includes(" ")) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: "Header name cannot include spaces"
			});
			continue;
		}
		const value = rawValue.join(HEADER_SEPARATOR).trim();
		if (name === "") {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: "No header name specified"
			});
			continue;
		}
		if (value === "") {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: "No header value specified"
			});
			continue;
		}
		if (!rule) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: `Path should come before header (${name}: ${value})`
			});
			continue;
		}
		const existingValues = rule.headers[name];
		rule.headers[name] = existingValues ? `${existingValues}, ${value}` : value;
	}
	if (rule) if (isValidRule(rule)) rules.push({
		path: rule.path,
		headers: rule.headers,
		unsetHeaders: rule.unsetHeaders
	});
	else invalid.push({
		line: rule.line,
		message: "No headers specified"
	});
	return {
		rules,
		invalid
	};
}
function isValidRule(rule) {
	return Object.keys(rule.headers).length > 0 || rule.unsetHeaders.length > 0;
}

//#endregion
//#region ../workers-shared/utils/configuration/parseRedirects.ts
function parseRedirects(input, { maxStaticRules = MAX_STATIC_REDIRECT_RULES, maxDynamicRules = MAX_DYNAMIC_REDIRECT_RULES, maxLineLength = MAX_LINE_LENGTH } = {}) {
	const lines = input.split("\n");
	const rules = [];
	const seen_paths = /* @__PURE__ */ new Set();
	const invalid = [];
	let staticRules = 0;
	let dynamicRules = 0;
	let canCreateStaticRule = true;
	for (let i$1 = 0; i$1 < lines.length; i$1++) {
		const line = (lines[i$1] || "").trim();
		if (line.length === 0 || line.startsWith("#")) continue;
		if (line.length > maxLineLength) {
			invalid.push({ message: `Ignoring line ${i$1 + 1} as it exceeds the maximum allowed length of ${maxLineLength}.` });
			continue;
		}
		const tokens = line.split(/\s+/);
		if (tokens.length < 2 || tokens.length > 3) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: `Expected exactly 2 or 3 whitespace-separated tokens. Got ${tokens.length}.`
			});
			continue;
		}
		const [str_from, str_to, str_status = "302"] = tokens;
		const fromResult = validateUrl(str_from, true, true, false, false);
		if (fromResult[0] === void 0) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: fromResult[1]
			});
			continue;
		}
		const from = fromResult[0];
		if (canCreateStaticRule && !from.match(SPLAT_REGEX) && !from.match(PLACEHOLDER_REGEX)) {
			staticRules += 1;
			if (staticRules > maxStaticRules) {
				invalid.push({ message: `Maximum number of static rules supported is ${maxStaticRules}. Skipping line.` });
				continue;
			}
		} else {
			dynamicRules += 1;
			canCreateStaticRule = false;
			if (dynamicRules > maxDynamicRules) {
				invalid.push({ message: `Maximum number of dynamic rules supported is ${maxDynamicRules}. Skipping remaining ${lines.length - i$1} lines of file.` });
				break;
			}
		}
		const toResult = validateUrl(str_to, false, false, true, true);
		if (toResult[0] === void 0) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: toResult[1]
			});
			continue;
		}
		const to = toResult[0];
		const status = Number(str_status);
		if (isNaN(status) || !PERMITTED_STATUS_CODES.has(status)) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: `Valid status codes are 200, 301, 302 (default), 303, 307, or 308. Got ${str_status}.`
			});
			continue;
		}
		if (/\/\*?$/.test(from) && /\/index(.html)?$/.test(to) && !urlHasHost(to)) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: "Infinite loop detected in this rule and has been ignored. This will cause a redirect to strip `.html` or `/index` and end up triggering this rule again. Please fix or remove this rule to silence this warning."
			});
			continue;
		}
		if (seen_paths.has(from)) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: `Ignoring duplicate rule for path ${from}.`
			});
			continue;
		}
		seen_paths.add(from);
		if (status === 200) {
			if (urlHasHost(to)) {
				invalid.push({
					line,
					lineNumber: i$1 + 1,
					message: `Proxy (200) redirects can only point to relative paths. Got ${to}`
				});
				continue;
			}
		}
		rules.push({
			from,
			to,
			status,
			lineNumber: i$1 + 1
		});
	}
	return {
		rules,
		invalid
	};
}

//#endregion
//#region ../workers-shared/utils/constants.ts
/** manifest = [HEADER, [ entry = PATH_HASH, CONTENT_HASH, TAIL], [entry], ... , [entry] ] */
const PATH_HASH_SIZE = 16;
/** manifest = [HEADER, [ entry = PATH_HASH, CONTENT_HASH, TAIL], [entry], ... , [entry] ] */
const CONTENT_HASH_SIZE = 16;
/** manifest = [HEADER, [ entry = PATH_HASH, CONTENT_HASH, TAIL], [entry], ... , [entry] ] */
const TAIL_SIZE = 8;
/** manifest = [HEADER, [ entry = PATH_HASH, CONTENT_HASH, TAIL], [entry], ... , [entry] ] */
const ENTRY_SIZE = PATH_HASH_SIZE + CONTENT_HASH_SIZE + TAIL_SIZE;
/** Maximum size per asset that can be deployed with a Worker */
const MAX_ASSET_SIZE = 25 * 1024 * 1024;
const REDIRECTS_FILENAME = "_redirects";
const HEADERS_FILENAME = "_headers";

//#endregion
//#region ../../node_modules/.pnpm/ignore@5.3.1/node_modules/ignore/index.js
var require_ignore = /* @__PURE__ */ __commonJS$1({ "../../node_modules/.pnpm/ignore@5.3.1/node_modules/ignore/index.js": ((exports, module) => {
	function makeArray(subject) {
		return Array.isArray(subject) ? subject : [subject];
	}
	const EMPTY = "";
	const SPACE = " ";
	const ESCAPE = "\\";
	const REGEX_TEST_BLANK_LINE = /^\s+$/;
	const REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
	const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
	const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
	const REGEX_SPLITALL_CRLF = /\r?\n/g;
	const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
	const SLASH = "/";
	let TMP_KEY_IGNORE = "node-ignore";
	/* istanbul ignore else */
	if (typeof Symbol !== "undefined") TMP_KEY_IGNORE = Symbol.for("node-ignore");
	const KEY_IGNORE = TMP_KEY_IGNORE;
	const define = (object, key, value) => Object.defineProperty(object, key, { value });
	const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
	const RETURN_FALSE = () => false;
	const sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
	const cleanRangeBackSlash = (slashes) => {
		const { length } = slashes;
		return slashes.slice(0, length - length % 2);
	};
	const REPLACERS = [
		[/^\uFEFF/, () => EMPTY],
		[/\\?\s+$/, (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY],
		[/\\\s/g, () => SPACE],
		[/[\\$.|*+(){^]/g, (match) => `\\${match}`],
		[/(?!\\)\?/g, () => "[^/]"],
		[/^\//, () => "^"],
		[/\//g, () => "\\/"],
		[/^\^*\\\*\\\*\\\//, () => "^(?:.*\\/)?"],
		[/^(?=[^^])/, function startingReplacer() {
			return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
		}],
		[/\\\/\\\*\\\*(?=\\\/|$)/g, (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"],
		[/(^|[^\\]+)(\\\*)+(?=.+)/g, (_, p1, p2) => {
			return p1 + p2.replace(/\\\*/g, "[^\\/]*");
		}],
		[/\\\\\\(?=[$.|*+(){^])/g, () => ESCAPE],
		[/\\\\/g, () => ESCAPE],
		[/(\\)?\[([^\]/]*?)(\\*)($|\])/g, (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"],
		[/(?:[^*])$/, (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`],
		[/(\^|\\\/)?\\\*$/, (_, p1) => {
			return `${p1 ? `${p1}[^/]+` : "[^/]*"}(?=$|\\/$)`;
		}]
	];
	const regexCache = Object.create(null);
	const makeRegex = (pattern, ignoreCase) => {
		let source = regexCache[pattern];
		if (!source) {
			source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
			regexCache[pattern] = source;
		}
		return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
	};
	const isString$1 = (subject) => typeof subject === "string";
	const checkPattern = (pattern) => pattern && isString$1(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
	const splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
	var IgnoreRule = class {
		constructor(origin, pattern, negative, regex) {
			this.origin = origin;
			this.pattern = pattern;
			this.negative = negative;
			this.regex = regex;
		}
	};
	const createRule = (pattern, ignoreCase) => {
		const origin = pattern;
		let negative = false;
		if (pattern.indexOf("!") === 0) {
			negative = true;
			pattern = pattern.substr(1);
		}
		pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
		const regex = makeRegex(pattern, ignoreCase);
		return new IgnoreRule(origin, pattern, negative, regex);
	};
	const throwError = (message, Ctor) => {
		throw new Ctor(message);
	};
	const checkPath = (path, originalPath, doThrow) => {
		if (!isString$1(path)) return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
		if (!path) return doThrow(`path must not be empty`, TypeError);
		if (checkPath.isNotRelative(path)) return doThrow(`path should be a \`path.relative()\`d string, but got "${originalPath}"`, RangeError);
		return true;
	};
	const isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
	checkPath.isNotRelative = isNotRelative;
	checkPath.convert = (p) => p;
	var Ignore = class {
		constructor({ ignorecase = true, ignoreCase = ignorecase, allowRelativePaths = false } = {}) {
			define(this, KEY_IGNORE, true);
			this._rules = [];
			this._ignoreCase = ignoreCase;
			this._allowRelativePaths = allowRelativePaths;
			this._initCache();
		}
		_initCache() {
			this._ignoreCache = Object.create(null);
			this._testCache = Object.create(null);
		}
		_addPattern(pattern) {
			if (pattern && pattern[KEY_IGNORE]) {
				this._rules = this._rules.concat(pattern._rules);
				this._added = true;
				return;
			}
			if (checkPattern(pattern)) {
				const rule = createRule(pattern, this._ignoreCase);
				this._added = true;
				this._rules.push(rule);
			}
		}
		add(pattern) {
			this._added = false;
			makeArray(isString$1(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
			if (this._added) this._initCache();
			return this;
		}
		addPattern(pattern) {
			return this.add(pattern);
		}
		_testOne(path, checkUnignored) {
			let ignored = false;
			let unignored = false;
			this._rules.forEach((rule) => {
				const { negative } = rule;
				if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) return;
				if (rule.regex.test(path)) {
					ignored = !negative;
					unignored = negative;
				}
			});
			return {
				ignored,
				unignored
			};
		}
		_test(originalPath, cache$2, checkUnignored, slices) {
			const path = originalPath && checkPath.convert(originalPath);
			checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);
			return this._t(path, cache$2, checkUnignored, slices);
		}
		_t(path, cache$2, checkUnignored, slices) {
			if (path in cache$2) return cache$2[path];
			if (!slices) slices = path.split(SLASH);
			slices.pop();
			if (!slices.length) return cache$2[path] = this._testOne(path, checkUnignored);
			const parent = this._t(slices.join(SLASH) + SLASH, cache$2, checkUnignored, slices);
			return cache$2[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
		}
		ignores(path) {
			return this._test(path, this._ignoreCache, false).ignored;
		}
		createFilter() {
			return (path) => !this.ignores(path);
		}
		filter(paths) {
			return makeArray(paths).filter(this.createFilter());
		}
		test(path) {
			return this._test(path, this._testCache, true);
		}
	};
	const factory = (options) => new Ignore(options);
	const isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
	factory.isPathValid = isPathValid;
	factory.default = factory;
	module.exports = factory;
	/* istanbul ignore if */
	if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
		const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
		checkPath.convert = makePosix;
		const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
		checkPath.isNotRelative = (path) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/mime@4.0.7/node_modules/mime/dist/types/other.js
var import_ignore = /* @__PURE__ */ __toESM$1(require_ignore());
const types$1 = {
	"application/prs.cww": ["cww"],
	"application/prs.xsf+xml": ["xsf"],
	"application/vnd.1000minds.decision-model+xml": ["1km"],
	"application/vnd.3gpp.pic-bw-large": ["plb"],
	"application/vnd.3gpp.pic-bw-small": ["psb"],
	"application/vnd.3gpp.pic-bw-var": ["pvb"],
	"application/vnd.3gpp2.tcap": ["tcap"],
	"application/vnd.3m.post-it-notes": ["pwn"],
	"application/vnd.accpac.simply.aso": ["aso"],
	"application/vnd.accpac.simply.imp": ["imp"],
	"application/vnd.acucobol": ["acu"],
	"application/vnd.acucorp": ["atc", "acutc"],
	"application/vnd.adobe.air-application-installer-package+zip": ["air"],
	"application/vnd.adobe.formscentral.fcdt": ["fcdt"],
	"application/vnd.adobe.fxp": ["fxp", "fxpl"],
	"application/vnd.adobe.xdp+xml": ["xdp"],
	"application/vnd.adobe.xfdf": ["*xfdf"],
	"application/vnd.age": ["age"],
	"application/vnd.ahead.space": ["ahead"],
	"application/vnd.airzip.filesecure.azf": ["azf"],
	"application/vnd.airzip.filesecure.azs": ["azs"],
	"application/vnd.amazon.ebook": ["azw"],
	"application/vnd.americandynamics.acc": ["acc"],
	"application/vnd.amiga.ami": ["ami"],
	"application/vnd.android.package-archive": ["apk"],
	"application/vnd.anser-web-certificate-issue-initiation": ["cii"],
	"application/vnd.anser-web-funds-transfer-initiation": ["fti"],
	"application/vnd.antix.game-component": ["atx"],
	"application/vnd.apple.installer+xml": ["mpkg"],
	"application/vnd.apple.keynote": ["key"],
	"application/vnd.apple.mpegurl": ["m3u8"],
	"application/vnd.apple.numbers": ["numbers"],
	"application/vnd.apple.pages": ["pages"],
	"application/vnd.apple.pkpass": ["pkpass"],
	"application/vnd.aristanetworks.swi": ["swi"],
	"application/vnd.astraea-software.iota": ["iota"],
	"application/vnd.audiograph": ["aep"],
	"application/vnd.autodesk.fbx": ["fbx"],
	"application/vnd.balsamiq.bmml+xml": ["bmml"],
	"application/vnd.blueice.multipass": ["mpm"],
	"application/vnd.bmi": ["bmi"],
	"application/vnd.businessobjects": ["rep"],
	"application/vnd.chemdraw+xml": ["cdxml"],
	"application/vnd.chipnuts.karaoke-mmd": ["mmd"],
	"application/vnd.cinderella": ["cdy"],
	"application/vnd.citationstyles.style+xml": ["csl"],
	"application/vnd.claymore": ["cla"],
	"application/vnd.cloanto.rp9": ["rp9"],
	"application/vnd.clonk.c4group": [
		"c4g",
		"c4d",
		"c4f",
		"c4p",
		"c4u"
	],
	"application/vnd.cluetrust.cartomobile-config": ["c11amc"],
	"application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"],
	"application/vnd.commonspace": ["csp"],
	"application/vnd.contact.cmsg": ["cdbcmsg"],
	"application/vnd.cosmocaller": ["cmc"],
	"application/vnd.crick.clicker": ["clkx"],
	"application/vnd.crick.clicker.keyboard": ["clkk"],
	"application/vnd.crick.clicker.palette": ["clkp"],
	"application/vnd.crick.clicker.template": ["clkt"],
	"application/vnd.crick.clicker.wordbank": ["clkw"],
	"application/vnd.criticaltools.wbs+xml": ["wbs"],
	"application/vnd.ctc-posml": ["pml"],
	"application/vnd.cups-ppd": ["ppd"],
	"application/vnd.curl.car": ["car"],
	"application/vnd.curl.pcurl": ["pcurl"],
	"application/vnd.dart": ["dart"],
	"application/vnd.data-vision.rdz": ["rdz"],
	"application/vnd.dbf": ["dbf"],
	"application/vnd.dcmp+xml": ["dcmp"],
	"application/vnd.dece.data": [
		"uvf",
		"uvvf",
		"uvd",
		"uvvd"
	],
	"application/vnd.dece.ttml+xml": ["uvt", "uvvt"],
	"application/vnd.dece.unspecified": ["uvx", "uvvx"],
	"application/vnd.dece.zip": ["uvz", "uvvz"],
	"application/vnd.denovo.fcselayout-link": ["fe_launch"],
	"application/vnd.dna": ["dna"],
	"application/vnd.dolby.mlp": ["mlp"],
	"application/vnd.dpgraph": ["dpg"],
	"application/vnd.dreamfactory": ["dfac"],
	"application/vnd.ds-keypoint": ["kpxx"],
	"application/vnd.dvb.ait": ["ait"],
	"application/vnd.dvb.service": ["svc"],
	"application/vnd.dynageo": ["geo"],
	"application/vnd.ecowin.chart": ["mag"],
	"application/vnd.enliven": ["nml"],
	"application/vnd.epson.esf": ["esf"],
	"application/vnd.epson.msf": ["msf"],
	"application/vnd.epson.quickanime": ["qam"],
	"application/vnd.epson.salt": ["slt"],
	"application/vnd.epson.ssf": ["ssf"],
	"application/vnd.eszigno3+xml": ["es3", "et3"],
	"application/vnd.ezpix-album": ["ez2"],
	"application/vnd.ezpix-package": ["ez3"],
	"application/vnd.fdf": ["*fdf"],
	"application/vnd.fdsn.mseed": ["mseed"],
	"application/vnd.fdsn.seed": ["seed", "dataless"],
	"application/vnd.flographit": ["gph"],
	"application/vnd.fluxtime.clip": ["ftc"],
	"application/vnd.framemaker": [
		"fm",
		"frame",
		"maker",
		"book"
	],
	"application/vnd.frogans.fnc": ["fnc"],
	"application/vnd.frogans.ltf": ["ltf"],
	"application/vnd.fsc.weblaunch": ["fsc"],
	"application/vnd.fujitsu.oasys": ["oas"],
	"application/vnd.fujitsu.oasys2": ["oa2"],
	"application/vnd.fujitsu.oasys3": ["oa3"],
	"application/vnd.fujitsu.oasysgp": ["fg5"],
	"application/vnd.fujitsu.oasysprs": ["bh2"],
	"application/vnd.fujixerox.ddd": ["ddd"],
	"application/vnd.fujixerox.docuworks": ["xdw"],
	"application/vnd.fujixerox.docuworks.binder": ["xbd"],
	"application/vnd.fuzzysheet": ["fzs"],
	"application/vnd.genomatix.tuxedo": ["txd"],
	"application/vnd.geogebra.file": ["ggb"],
	"application/vnd.geogebra.slides": ["ggs"],
	"application/vnd.geogebra.tool": ["ggt"],
	"application/vnd.geometry-explorer": ["gex", "gre"],
	"application/vnd.geonext": ["gxt"],
	"application/vnd.geoplan": ["g2w"],
	"application/vnd.geospace": ["g3w"],
	"application/vnd.gmx": ["gmx"],
	"application/vnd.google-apps.document": ["gdoc"],
	"application/vnd.google-apps.drawing": ["gdraw"],
	"application/vnd.google-apps.form": ["gform"],
	"application/vnd.google-apps.jam": ["gjam"],
	"application/vnd.google-apps.map": ["gmap"],
	"application/vnd.google-apps.presentation": ["gslides"],
	"application/vnd.google-apps.script": ["gscript"],
	"application/vnd.google-apps.site": ["gsite"],
	"application/vnd.google-apps.spreadsheet": ["gsheet"],
	"application/vnd.google-earth.kml+xml": ["kml"],
	"application/vnd.google-earth.kmz": ["kmz"],
	"application/vnd.gov.sk.xmldatacontainer+xml": ["xdcf"],
	"application/vnd.grafeq": ["gqf", "gqs"],
	"application/vnd.groove-account": ["gac"],
	"application/vnd.groove-help": ["ghf"],
	"application/vnd.groove-identity-message": ["gim"],
	"application/vnd.groove-injector": ["grv"],
	"application/vnd.groove-tool-message": ["gtm"],
	"application/vnd.groove-tool-template": ["tpl"],
	"application/vnd.groove-vcard": ["vcg"],
	"application/vnd.hal+xml": ["hal"],
	"application/vnd.handheld-entertainment+xml": ["zmm"],
	"application/vnd.hbci": ["hbci"],
	"application/vnd.hhe.lesson-player": ["les"],
	"application/vnd.hp-hpgl": ["hpgl"],
	"application/vnd.hp-hpid": ["hpid"],
	"application/vnd.hp-hps": ["hps"],
	"application/vnd.hp-jlyt": ["jlt"],
	"application/vnd.hp-pcl": ["pcl"],
	"application/vnd.hp-pclxl": ["pclxl"],
	"application/vnd.hydrostatix.sof-data": ["sfd-hdstx"],
	"application/vnd.ibm.minipay": ["mpy"],
	"application/vnd.ibm.modcap": [
		"afp",
		"listafp",
		"list3820"
	],
	"application/vnd.ibm.rights-management": ["irm"],
	"application/vnd.ibm.secure-container": ["sc"],
	"application/vnd.iccprofile": ["icc", "icm"],
	"application/vnd.igloader": ["igl"],
	"application/vnd.immervision-ivp": ["ivp"],
	"application/vnd.immervision-ivu": ["ivu"],
	"application/vnd.insors.igm": ["igm"],
	"application/vnd.intercon.formnet": ["xpw", "xpx"],
	"application/vnd.intergeo": ["i2g"],
	"application/vnd.intu.qbo": ["qbo"],
	"application/vnd.intu.qfx": ["qfx"],
	"application/vnd.ipunplugged.rcprofile": ["rcprofile"],
	"application/vnd.irepository.package+xml": ["irp"],
	"application/vnd.is-xpr": ["xpr"],
	"application/vnd.isac.fcs": ["fcs"],
	"application/vnd.jam": ["jam"],
	"application/vnd.jcp.javame.midlet-rms": ["rms"],
	"application/vnd.jisp": ["jisp"],
	"application/vnd.joost.joda-archive": ["joda"],
	"application/vnd.kahootz": ["ktz", "ktr"],
	"application/vnd.kde.karbon": ["karbon"],
	"application/vnd.kde.kchart": ["chrt"],
	"application/vnd.kde.kformula": ["kfo"],
	"application/vnd.kde.kivio": ["flw"],
	"application/vnd.kde.kontour": ["kon"],
	"application/vnd.kde.kpresenter": ["kpr", "kpt"],
	"application/vnd.kde.kspread": ["ksp"],
	"application/vnd.kde.kword": ["kwd", "kwt"],
	"application/vnd.kenameaapp": ["htke"],
	"application/vnd.kidspiration": ["kia"],
	"application/vnd.kinar": ["kne", "knp"],
	"application/vnd.koan": [
		"skp",
		"skd",
		"skt",
		"skm"
	],
	"application/vnd.kodak-descriptor": ["sse"],
	"application/vnd.las.las+xml": ["lasxml"],
	"application/vnd.llamagraphics.life-balance.desktop": ["lbd"],
	"application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"],
	"application/vnd.lotus-1-2-3": ["123"],
	"application/vnd.lotus-approach": ["apr"],
	"application/vnd.lotus-freelance": ["pre"],
	"application/vnd.lotus-notes": ["nsf"],
	"application/vnd.lotus-organizer": ["org"],
	"application/vnd.lotus-screencam": ["scm"],
	"application/vnd.lotus-wordpro": ["lwp"],
	"application/vnd.macports.portpkg": ["portpkg"],
	"application/vnd.mapbox-vector-tile": ["mvt"],
	"application/vnd.mcd": ["mcd"],
	"application/vnd.medcalcdata": ["mc1"],
	"application/vnd.mediastation.cdkey": ["cdkey"],
	"application/vnd.mfer": ["mwf"],
	"application/vnd.mfmp": ["mfm"],
	"application/vnd.micrografx.flo": ["flo"],
	"application/vnd.micrografx.igx": ["igx"],
	"application/vnd.mif": ["mif"],
	"application/vnd.mobius.daf": ["daf"],
	"application/vnd.mobius.dis": ["dis"],
	"application/vnd.mobius.mbk": ["mbk"],
	"application/vnd.mobius.mqy": ["mqy"],
	"application/vnd.mobius.msl": ["msl"],
	"application/vnd.mobius.plc": ["plc"],
	"application/vnd.mobius.txf": ["txf"],
	"application/vnd.mophun.application": ["mpn"],
	"application/vnd.mophun.certificate": ["mpc"],
	"application/vnd.mozilla.xul+xml": ["xul"],
	"application/vnd.ms-artgalry": ["cil"],
	"application/vnd.ms-cab-compressed": ["cab"],
	"application/vnd.ms-excel": [
		"xls",
		"xlm",
		"xla",
		"xlc",
		"xlt",
		"xlw"
	],
	"application/vnd.ms-excel.addin.macroenabled.12": ["xlam"],
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"],
	"application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"],
	"application/vnd.ms-excel.template.macroenabled.12": ["xltm"],
	"application/vnd.ms-fontobject": ["eot"],
	"application/vnd.ms-htmlhelp": ["chm"],
	"application/vnd.ms-ims": ["ims"],
	"application/vnd.ms-lrm": ["lrm"],
	"application/vnd.ms-officetheme": ["thmx"],
	"application/vnd.ms-outlook": ["msg"],
	"application/vnd.ms-pki.seccat": ["cat"],
	"application/vnd.ms-pki.stl": ["*stl"],
	"application/vnd.ms-powerpoint": [
		"ppt",
		"pps",
		"pot"
	],
	"application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"],
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"],
	"application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"],
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"],
	"application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"],
	"application/vnd.ms-project": ["*mpp", "mpt"],
	"application/vnd.ms-visio.viewer": ["vdx"],
	"application/vnd.ms-word.document.macroenabled.12": ["docm"],
	"application/vnd.ms-word.template.macroenabled.12": ["dotm"],
	"application/vnd.ms-works": [
		"wps",
		"wks",
		"wcm",
		"wdb"
	],
	"application/vnd.ms-wpl": ["wpl"],
	"application/vnd.ms-xpsdocument": ["xps"],
	"application/vnd.mseq": ["mseq"],
	"application/vnd.musician": ["mus"],
	"application/vnd.muvee.style": ["msty"],
	"application/vnd.mynfc": ["taglet"],
	"application/vnd.nato.bindingdataobject+xml": ["bdo"],
	"application/vnd.neurolanguage.nlu": ["nlu"],
	"application/vnd.nitf": ["ntf", "nitf"],
	"application/vnd.noblenet-directory": ["nnd"],
	"application/vnd.noblenet-sealer": ["nns"],
	"application/vnd.noblenet-web": ["nnw"],
	"application/vnd.nokia.n-gage.ac+xml": ["*ac"],
	"application/vnd.nokia.n-gage.data": ["ngdat"],
	"application/vnd.nokia.n-gage.symbian.install": ["n-gage"],
	"application/vnd.nokia.radio-preset": ["rpst"],
	"application/vnd.nokia.radio-presets": ["rpss"],
	"application/vnd.novadigm.edm": ["edm"],
	"application/vnd.novadigm.edx": ["edx"],
	"application/vnd.novadigm.ext": ["ext"],
	"application/vnd.oasis.opendocument.chart": ["odc"],
	"application/vnd.oasis.opendocument.chart-template": ["otc"],
	"application/vnd.oasis.opendocument.database": ["odb"],
	"application/vnd.oasis.opendocument.formula": ["odf"],
	"application/vnd.oasis.opendocument.formula-template": ["odft"],
	"application/vnd.oasis.opendocument.graphics": ["odg"],
	"application/vnd.oasis.opendocument.graphics-template": ["otg"],
	"application/vnd.oasis.opendocument.image": ["odi"],
	"application/vnd.oasis.opendocument.image-template": ["oti"],
	"application/vnd.oasis.opendocument.presentation": ["odp"],
	"application/vnd.oasis.opendocument.presentation-template": ["otp"],
	"application/vnd.oasis.opendocument.spreadsheet": ["ods"],
	"application/vnd.oasis.opendocument.spreadsheet-template": ["ots"],
	"application/vnd.oasis.opendocument.text": ["odt"],
	"application/vnd.oasis.opendocument.text-master": ["odm"],
	"application/vnd.oasis.opendocument.text-template": ["ott"],
	"application/vnd.oasis.opendocument.text-web": ["oth"],
	"application/vnd.olpc-sugar": ["xo"],
	"application/vnd.oma.dd2+xml": ["dd2"],
	"application/vnd.openblox.game+xml": ["obgx"],
	"application/vnd.openofficeorg.extension": ["oxt"],
	"application/vnd.openstreetmap.data+xml": ["osm"],
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"],
	"application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"],
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"],
	"application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"],
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"],
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"],
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"],
	"application/vnd.osgeo.mapguide.package": ["mgp"],
	"application/vnd.osgi.dp": ["dp"],
	"application/vnd.osgi.subsystem": ["esa"],
	"application/vnd.palm": [
		"pdb",
		"pqa",
		"oprc"
	],
	"application/vnd.pawaafile": ["paw"],
	"application/vnd.pg.format": ["str"],
	"application/vnd.pg.osasli": ["ei6"],
	"application/vnd.picsel": ["efif"],
	"application/vnd.pmi.widget": ["wg"],
	"application/vnd.pocketlearn": ["plf"],
	"application/vnd.powerbuilder6": ["pbd"],
	"application/vnd.previewsystems.box": ["box"],
	"application/vnd.procrate.brushset": ["brushset"],
	"application/vnd.procreate.brush": ["brush"],
	"application/vnd.procreate.dream": ["drm"],
	"application/vnd.proteus.magazine": ["mgz"],
	"application/vnd.publishare-delta-tree": ["qps"],
	"application/vnd.pvi.ptid1": ["ptid"],
	"application/vnd.pwg-xhtml-print+xml": ["xhtm"],
	"application/vnd.quark.quarkxpress": [
		"qxd",
		"qxt",
		"qwd",
		"qwt",
		"qxl",
		"qxb"
	],
	"application/vnd.rar": ["rar"],
	"application/vnd.realvnc.bed": ["bed"],
	"application/vnd.recordare.musicxml": ["mxl"],
	"application/vnd.recordare.musicxml+xml": ["musicxml"],
	"application/vnd.rig.cryptonote": ["cryptonote"],
	"application/vnd.rim.cod": ["cod"],
	"application/vnd.rn-realmedia": ["rm"],
	"application/vnd.rn-realmedia-vbr": ["rmvb"],
	"application/vnd.route66.link66+xml": ["link66"],
	"application/vnd.sailingtracker.track": ["st"],
	"application/vnd.seemail": ["see"],
	"application/vnd.sema": ["sema"],
	"application/vnd.semd": ["semd"],
	"application/vnd.semf": ["semf"],
	"application/vnd.shana.informed.formdata": ["ifm"],
	"application/vnd.shana.informed.formtemplate": ["itp"],
	"application/vnd.shana.informed.interchange": ["iif"],
	"application/vnd.shana.informed.package": ["ipk"],
	"application/vnd.simtech-mindmapper": ["twd", "twds"],
	"application/vnd.smaf": ["mmf"],
	"application/vnd.smart.teacher": ["teacher"],
	"application/vnd.software602.filler.form+xml": ["fo"],
	"application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
	"application/vnd.spotfire.dxp": ["dxp"],
	"application/vnd.spotfire.sfs": ["sfs"],
	"application/vnd.stardivision.calc": ["sdc"],
	"application/vnd.stardivision.draw": ["sda"],
	"application/vnd.stardivision.impress": ["sdd"],
	"application/vnd.stardivision.math": ["smf"],
	"application/vnd.stardivision.writer": ["sdw", "vor"],
	"application/vnd.stardivision.writer-global": ["sgl"],
	"application/vnd.stepmania.package": ["smzip"],
	"application/vnd.stepmania.stepchart": ["sm"],
	"application/vnd.sun.wadl+xml": ["wadl"],
	"application/vnd.sun.xml.calc": ["sxc"],
	"application/vnd.sun.xml.calc.template": ["stc"],
	"application/vnd.sun.xml.draw": ["sxd"],
	"application/vnd.sun.xml.draw.template": ["std"],
	"application/vnd.sun.xml.impress": ["sxi"],
	"application/vnd.sun.xml.impress.template": ["sti"],
	"application/vnd.sun.xml.math": ["sxm"],
	"application/vnd.sun.xml.writer": ["sxw"],
	"application/vnd.sun.xml.writer.global": ["sxg"],
	"application/vnd.sun.xml.writer.template": ["stw"],
	"application/vnd.sus-calendar": ["sus", "susp"],
	"application/vnd.svd": ["svd"],
	"application/vnd.symbian.install": ["sis", "sisx"],
	"application/vnd.syncml+xml": ["xsm"],
	"application/vnd.syncml.dm+wbxml": ["bdm"],
	"application/vnd.syncml.dm+xml": ["xdm"],
	"application/vnd.syncml.dmddf+xml": ["ddf"],
	"application/vnd.tao.intent-module-archive": ["tao"],
	"application/vnd.tcpdump.pcap": [
		"pcap",
		"cap",
		"dmp"
	],
	"application/vnd.tmobile-livetv": ["tmo"],
	"application/vnd.trid.tpt": ["tpt"],
	"application/vnd.triscape.mxs": ["mxs"],
	"application/vnd.trueapp": ["tra"],
	"application/vnd.ufdl": ["ufd", "ufdl"],
	"application/vnd.uiq.theme": ["utz"],
	"application/vnd.umajin": ["umj"],
	"application/vnd.unity": ["unityweb"],
	"application/vnd.uoml+xml": ["uoml", "uo"],
	"application/vnd.vcx": ["vcx"],
	"application/vnd.visio": [
		"vsd",
		"vst",
		"vss",
		"vsw",
		"vsdx",
		"vtx"
	],
	"application/vnd.visionary": ["vis"],
	"application/vnd.vsf": ["vsf"],
	"application/vnd.wap.wbxml": ["wbxml"],
	"application/vnd.wap.wmlc": ["wmlc"],
	"application/vnd.wap.wmlscriptc": ["wmlsc"],
	"application/vnd.webturbo": ["wtb"],
	"application/vnd.wolfram.player": ["nbp"],
	"application/vnd.wordperfect": ["wpd"],
	"application/vnd.wqd": ["wqd"],
	"application/vnd.wt.stf": ["stf"],
	"application/vnd.xara": ["xar"],
	"application/vnd.xfdl": ["xfdl"],
	"application/vnd.yamaha.hv-dic": ["hvd"],
	"application/vnd.yamaha.hv-script": ["hvs"],
	"application/vnd.yamaha.hv-voice": ["hvp"],
	"application/vnd.yamaha.openscoreformat": ["osf"],
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"],
	"application/vnd.yamaha.smaf-audio": ["saf"],
	"application/vnd.yamaha.smaf-phrase": ["spf"],
	"application/vnd.yellowriver-custom-menu": ["cmp"],
	"application/vnd.zul": ["zir", "zirz"],
	"application/vnd.zzazz.deck+xml": ["zaz"],
	"application/x-7z-compressed": ["7z"],
	"application/x-abiword": ["abw"],
	"application/x-ace-compressed": ["ace"],
	"application/x-apple-diskimage": ["*dmg"],
	"application/x-arj": ["arj"],
	"application/x-authorware-bin": [
		"aab",
		"x32",
		"u32",
		"vox"
	],
	"application/x-authorware-map": ["aam"],
	"application/x-authorware-seg": ["aas"],
	"application/x-bcpio": ["bcpio"],
	"application/x-bdoc": ["*bdoc"],
	"application/x-bittorrent": ["torrent"],
	"application/x-blender": ["blend"],
	"application/x-blorb": ["blb", "blorb"],
	"application/x-bzip": ["bz"],
	"application/x-bzip2": ["bz2", "boz"],
	"application/x-cbr": [
		"cbr",
		"cba",
		"cbt",
		"cbz",
		"cb7"
	],
	"application/x-cdlink": ["vcd"],
	"application/x-cfs-compressed": ["cfs"],
	"application/x-chat": ["chat"],
	"application/x-chess-pgn": ["pgn"],
	"application/x-chrome-extension": ["crx"],
	"application/x-cocoa": ["cco"],
	"application/x-compressed": ["*rar"],
	"application/x-conference": ["nsc"],
	"application/x-cpio": ["cpio"],
	"application/x-csh": ["csh"],
	"application/x-debian-package": ["*deb", "udeb"],
	"application/x-dgc-compressed": ["dgc"],
	"application/x-director": [
		"dir",
		"dcr",
		"dxr",
		"cst",
		"cct",
		"cxt",
		"w3d",
		"fgd",
		"swa"
	],
	"application/x-doom": ["wad"],
	"application/x-dtbncx+xml": ["ncx"],
	"application/x-dtbook+xml": ["dtb"],
	"application/x-dtbresource+xml": ["res"],
	"application/x-dvi": ["dvi"],
	"application/x-envoy": ["evy"],
	"application/x-eva": ["eva"],
	"application/x-font-bdf": ["bdf"],
	"application/x-font-ghostscript": ["gsf"],
	"application/x-font-linux-psf": ["psf"],
	"application/x-font-pcf": ["pcf"],
	"application/x-font-snf": ["snf"],
	"application/x-font-type1": [
		"pfa",
		"pfb",
		"pfm",
		"afm"
	],
	"application/x-freearc": ["arc"],
	"application/x-futuresplash": ["spl"],
	"application/x-gca-compressed": ["gca"],
	"application/x-glulx": ["ulx"],
	"application/x-gnumeric": ["gnumeric"],
	"application/x-gramps-xml": ["gramps"],
	"application/x-gtar": ["gtar"],
	"application/x-hdf": ["hdf"],
	"application/x-httpd-php": ["php"],
	"application/x-install-instructions": ["install"],
	"application/x-ipynb+json": ["ipynb"],
	"application/x-iso9660-image": ["*iso"],
	"application/x-iwork-keynote-sffkey": ["*key"],
	"application/x-iwork-numbers-sffnumbers": ["*numbers"],
	"application/x-iwork-pages-sffpages": ["*pages"],
	"application/x-java-archive-diff": ["jardiff"],
	"application/x-java-jnlp-file": ["jnlp"],
	"application/x-keepass2": ["kdbx"],
	"application/x-latex": ["latex"],
	"application/x-lua-bytecode": ["luac"],
	"application/x-lzh-compressed": ["lzh", "lha"],
	"application/x-makeself": ["run"],
	"application/x-mie": ["mie"],
	"application/x-mobipocket-ebook": ["*prc", "mobi"],
	"application/x-ms-application": ["application"],
	"application/x-ms-shortcut": ["lnk"],
	"application/x-ms-wmd": ["wmd"],
	"application/x-ms-wmz": ["wmz"],
	"application/x-ms-xbap": ["xbap"],
	"application/x-msaccess": ["mdb"],
	"application/x-msbinder": ["obd"],
	"application/x-mscardfile": ["crd"],
	"application/x-msclip": ["clp"],
	"application/x-msdos-program": ["*exe"],
	"application/x-msdownload": [
		"*exe",
		"*dll",
		"com",
		"bat",
		"*msi"
	],
	"application/x-msmediaview": [
		"mvb",
		"m13",
		"m14"
	],
	"application/x-msmetafile": [
		"*wmf",
		"*wmz",
		"*emf",
		"emz"
	],
	"application/x-msmoney": ["mny"],
	"application/x-mspublisher": ["pub"],
	"application/x-msschedule": ["scd"],
	"application/x-msterminal": ["trm"],
	"application/x-mswrite": ["wri"],
	"application/x-netcdf": ["nc", "cdf"],
	"application/x-ns-proxy-autoconfig": ["pac"],
	"application/x-nzb": ["nzb"],
	"application/x-perl": ["pl", "pm"],
	"application/x-pilot": ["*prc", "*pdb"],
	"application/x-pkcs12": ["p12", "pfx"],
	"application/x-pkcs7-certificates": ["p7b", "spc"],
	"application/x-pkcs7-certreqresp": ["p7r"],
	"application/x-rar-compressed": ["*rar"],
	"application/x-redhat-package-manager": ["rpm"],
	"application/x-research-info-systems": ["ris"],
	"application/x-sea": ["sea"],
	"application/x-sh": ["sh"],
	"application/x-shar": ["shar"],
	"application/x-shockwave-flash": ["swf"],
	"application/x-silverlight-app": ["xap"],
	"application/x-sql": ["*sql"],
	"application/x-stuffit": ["sit"],
	"application/x-stuffitx": ["sitx"],
	"application/x-subrip": ["srt"],
	"application/x-sv4cpio": ["sv4cpio"],
	"application/x-sv4crc": ["sv4crc"],
	"application/x-t3vm-image": ["t3"],
	"application/x-tads": ["gam"],
	"application/x-tar": ["tar"],
	"application/x-tcl": ["tcl", "tk"],
	"application/x-tex": ["tex"],
	"application/x-tex-tfm": ["tfm"],
	"application/x-texinfo": ["texinfo", "texi"],
	"application/x-tgif": ["*obj"],
	"application/x-ustar": ["ustar"],
	"application/x-virtualbox-hdd": ["hdd"],
	"application/x-virtualbox-ova": ["ova"],
	"application/x-virtualbox-ovf": ["ovf"],
	"application/x-virtualbox-vbox": ["vbox"],
	"application/x-virtualbox-vbox-extpack": ["vbox-extpack"],
	"application/x-virtualbox-vdi": ["vdi"],
	"application/x-virtualbox-vhd": ["vhd"],
	"application/x-virtualbox-vmdk": ["vmdk"],
	"application/x-wais-source": ["src"],
	"application/x-web-app-manifest+json": ["webapp"],
	"application/x-x509-ca-cert": [
		"der",
		"crt",
		"pem"
	],
	"application/x-xfig": ["fig"],
	"application/x-xliff+xml": ["*xlf"],
	"application/x-xpinstall": ["xpi"],
	"application/x-xz": ["xz"],
	"application/x-zip-compressed": ["*zip"],
	"application/x-zmachine": [
		"z1",
		"z2",
		"z3",
		"z4",
		"z5",
		"z6",
		"z7",
		"z8"
	],
	"audio/vnd.dece.audio": ["uva", "uvva"],
	"audio/vnd.digital-winds": ["eol"],
	"audio/vnd.dra": ["dra"],
	"audio/vnd.dts": ["dts"],
	"audio/vnd.dts.hd": ["dtshd"],
	"audio/vnd.lucent.voice": ["lvp"],
	"audio/vnd.ms-playready.media.pya": ["pya"],
	"audio/vnd.nuera.ecelp4800": ["ecelp4800"],
	"audio/vnd.nuera.ecelp7470": ["ecelp7470"],
	"audio/vnd.nuera.ecelp9600": ["ecelp9600"],
	"audio/vnd.rip": ["rip"],
	"audio/x-aac": ["*aac"],
	"audio/x-aiff": [
		"aif",
		"aiff",
		"aifc"
	],
	"audio/x-caf": ["caf"],
	"audio/x-flac": ["flac"],
	"audio/x-m4a": ["*m4a"],
	"audio/x-matroska": ["mka"],
	"audio/x-mpegurl": ["m3u"],
	"audio/x-ms-wax": ["wax"],
	"audio/x-ms-wma": ["wma"],
	"audio/x-pn-realaudio": ["ram", "ra"],
	"audio/x-pn-realaudio-plugin": ["rmp"],
	"audio/x-realaudio": ["*ra"],
	"audio/x-wav": ["*wav"],
	"chemical/x-cdx": ["cdx"],
	"chemical/x-cif": ["cif"],
	"chemical/x-cmdf": ["cmdf"],
	"chemical/x-cml": ["cml"],
	"chemical/x-csml": ["csml"],
	"chemical/x-xyz": ["xyz"],
	"image/prs.btif": ["btif", "btf"],
	"image/prs.pti": ["pti"],
	"image/vnd.adobe.photoshop": ["psd"],
	"image/vnd.airzip.accelerator.azv": ["azv"],
	"image/vnd.dece.graphic": [
		"uvi",
		"uvvi",
		"uvg",
		"uvvg"
	],
	"image/vnd.djvu": ["djvu", "djv"],
	"image/vnd.dvb.subtitle": ["*sub"],
	"image/vnd.dwg": ["dwg"],
	"image/vnd.dxf": ["dxf"],
	"image/vnd.fastbidsheet": ["fbs"],
	"image/vnd.fpx": ["fpx"],
	"image/vnd.fst": ["fst"],
	"image/vnd.fujixerox.edmics-mmr": ["mmr"],
	"image/vnd.fujixerox.edmics-rlc": ["rlc"],
	"image/vnd.microsoft.icon": ["ico"],
	"image/vnd.ms-dds": ["dds"],
	"image/vnd.ms-modi": ["mdi"],
	"image/vnd.ms-photo": ["wdp"],
	"image/vnd.net-fpx": ["npx"],
	"image/vnd.pco.b16": ["b16"],
	"image/vnd.tencent.tap": ["tap"],
	"image/vnd.valve.source.texture": ["vtf"],
	"image/vnd.wap.wbmp": ["wbmp"],
	"image/vnd.xiff": ["xif"],
	"image/vnd.zbrush.pcx": ["pcx"],
	"image/x-3ds": ["3ds"],
	"image/x-adobe-dng": ["dng"],
	"image/x-cmu-raster": ["ras"],
	"image/x-cmx": ["cmx"],
	"image/x-freehand": [
		"fh",
		"fhc",
		"fh4",
		"fh5",
		"fh7"
	],
	"image/x-icon": ["*ico"],
	"image/x-jng": ["jng"],
	"image/x-mrsid-image": ["sid"],
	"image/x-ms-bmp": ["*bmp"],
	"image/x-pcx": ["*pcx"],
	"image/x-pict": ["pic", "pct"],
	"image/x-portable-anymap": ["pnm"],
	"image/x-portable-bitmap": ["pbm"],
	"image/x-portable-graymap": ["pgm"],
	"image/x-portable-pixmap": ["ppm"],
	"image/x-rgb": ["rgb"],
	"image/x-tga": ["tga"],
	"image/x-xbitmap": ["xbm"],
	"image/x-xpixmap": ["xpm"],
	"image/x-xwindowdump": ["xwd"],
	"message/vnd.wfa.wsc": ["wsc"],
	"model/vnd.bary": ["bary"],
	"model/vnd.cld": ["cld"],
	"model/vnd.collada+xml": ["dae"],
	"model/vnd.dwf": ["dwf"],
	"model/vnd.gdl": ["gdl"],
	"model/vnd.gtw": ["gtw"],
	"model/vnd.mts": ["*mts"],
	"model/vnd.opengex": ["ogex"],
	"model/vnd.parasolid.transmit.binary": ["x_b"],
	"model/vnd.parasolid.transmit.text": ["x_t"],
	"model/vnd.pytha.pyox": ["pyo", "pyox"],
	"model/vnd.sap.vds": ["vds"],
	"model/vnd.usda": ["usda"],
	"model/vnd.usdz+zip": ["usdz"],
	"model/vnd.valve.source.compiled-map": ["bsp"],
	"model/vnd.vtu": ["vtu"],
	"text/prs.lines.tag": ["dsc"],
	"text/vnd.curl": ["curl"],
	"text/vnd.curl.dcurl": ["dcurl"],
	"text/vnd.curl.mcurl": ["mcurl"],
	"text/vnd.curl.scurl": ["scurl"],
	"text/vnd.dvb.subtitle": ["sub"],
	"text/vnd.familysearch.gedcom": ["ged"],
	"text/vnd.fly": ["fly"],
	"text/vnd.fmi.flexstor": ["flx"],
	"text/vnd.graphviz": ["gv"],
	"text/vnd.in3d.3dml": ["3dml"],
	"text/vnd.in3d.spot": ["spot"],
	"text/vnd.sun.j2me.app-descriptor": ["jad"],
	"text/vnd.wap.wml": ["wml"],
	"text/vnd.wap.wmlscript": ["wmls"],
	"text/x-asm": ["s", "asm"],
	"text/x-c": [
		"c",
		"cc",
		"cxx",
		"cpp",
		"h",
		"hh",
		"dic"
	],
	"text/x-component": ["htc"],
	"text/x-fortran": [
		"f",
		"for",
		"f77",
		"f90"
	],
	"text/x-handlebars-template": ["hbs"],
	"text/x-java-source": ["java"],
	"text/x-lua": ["lua"],
	"text/x-markdown": ["mkd"],
	"text/x-nfo": ["nfo"],
	"text/x-opml": ["opml"],
	"text/x-org": ["*org"],
	"text/x-pascal": ["p", "pas"],
	"text/x-processing": ["pde"],
	"text/x-sass": ["sass"],
	"text/x-scss": ["scss"],
	"text/x-setext": ["etx"],
	"text/x-sfv": ["sfv"],
	"text/x-suse-ymp": ["ymp"],
	"text/x-uuencode": ["uu"],
	"text/x-vcalendar": ["vcs"],
	"text/x-vcard": ["vcf"],
	"video/vnd.dece.hd": ["uvh", "uvvh"],
	"video/vnd.dece.mobile": ["uvm", "uvvm"],
	"video/vnd.dece.pd": ["uvp", "uvvp"],
	"video/vnd.dece.sd": ["uvs", "uvvs"],
	"video/vnd.dece.video": ["uvv", "uvvv"],
	"video/vnd.dvb.file": ["dvb"],
	"video/vnd.fvt": ["fvt"],
	"video/vnd.mpegurl": ["mxu", "m4u"],
	"video/vnd.ms-playready.media.pyv": ["pyv"],
	"video/vnd.uvvu.mp4": ["uvu", "uvvu"],
	"video/vnd.vivo": ["viv"],
	"video/x-f4v": ["f4v"],
	"video/x-fli": ["fli"],
	"video/x-flv": ["flv"],
	"video/x-m4v": ["m4v"],
	"video/x-matroska": [
		"mkv",
		"mk3d",
		"mks"
	],
	"video/x-mng": ["mng"],
	"video/x-ms-asf": ["asf", "asx"],
	"video/x-ms-vob": ["vob"],
	"video/x-ms-wm": ["wm"],
	"video/x-ms-wmv": ["wmv"],
	"video/x-ms-wmx": ["wmx"],
	"video/x-ms-wvx": ["wvx"],
	"video/x-msvideo": ["avi"],
	"video/x-sgi-movie": ["movie"],
	"video/x-smv": ["smv"],
	"x-conference/x-cooltalk": ["ice"]
};
Object.freeze(types$1);
var other_default = types$1;

//#endregion
//#region ../../node_modules/.pnpm/mime@4.0.7/node_modules/mime/dist/types/standard.js
const types = {
	"application/andrew-inset": ["ez"],
	"application/appinstaller": ["appinstaller"],
	"application/applixware": ["aw"],
	"application/appx": ["appx"],
	"application/appxbundle": ["appxbundle"],
	"application/atom+xml": ["atom"],
	"application/atomcat+xml": ["atomcat"],
	"application/atomdeleted+xml": ["atomdeleted"],
	"application/atomsvc+xml": ["atomsvc"],
	"application/atsc-dwd+xml": ["dwd"],
	"application/atsc-held+xml": ["held"],
	"application/atsc-rsat+xml": ["rsat"],
	"application/automationml-aml+xml": ["aml"],
	"application/automationml-amlx+zip": ["amlx"],
	"application/bdoc": ["bdoc"],
	"application/calendar+xml": ["xcs"],
	"application/ccxml+xml": ["ccxml"],
	"application/cdfx+xml": ["cdfx"],
	"application/cdmi-capability": ["cdmia"],
	"application/cdmi-container": ["cdmic"],
	"application/cdmi-domain": ["cdmid"],
	"application/cdmi-object": ["cdmio"],
	"application/cdmi-queue": ["cdmiq"],
	"application/cpl+xml": ["cpl"],
	"application/cu-seeme": ["cu"],
	"application/cwl": ["cwl"],
	"application/dash+xml": ["mpd"],
	"application/dash-patch+xml": ["mpp"],
	"application/davmount+xml": ["davmount"],
	"application/dicom": ["dcm"],
	"application/docbook+xml": ["dbk"],
	"application/dssc+der": ["dssc"],
	"application/dssc+xml": ["xdssc"],
	"application/ecmascript": ["ecma"],
	"application/emma+xml": ["emma"],
	"application/emotionml+xml": ["emotionml"],
	"application/epub+zip": ["epub"],
	"application/exi": ["exi"],
	"application/express": ["exp"],
	"application/fdf": ["fdf"],
	"application/fdt+xml": ["fdt"],
	"application/font-tdpfr": ["pfr"],
	"application/geo+json": ["geojson"],
	"application/gml+xml": ["gml"],
	"application/gpx+xml": ["gpx"],
	"application/gxf": ["gxf"],
	"application/gzip": ["gz"],
	"application/hjson": ["hjson"],
	"application/hyperstudio": ["stk"],
	"application/inkml+xml": ["ink", "inkml"],
	"application/ipfix": ["ipfix"],
	"application/its+xml": ["its"],
	"application/java-archive": [
		"jar",
		"war",
		"ear"
	],
	"application/java-serialized-object": ["ser"],
	"application/java-vm": ["class"],
	"application/javascript": ["*js"],
	"application/json": ["json", "map"],
	"application/json5": ["json5"],
	"application/jsonml+json": ["jsonml"],
	"application/ld+json": ["jsonld"],
	"application/lgr+xml": ["lgr"],
	"application/lost+xml": ["lostxml"],
	"application/mac-binhex40": ["hqx"],
	"application/mac-compactpro": ["cpt"],
	"application/mads+xml": ["mads"],
	"application/manifest+json": ["webmanifest"],
	"application/marc": ["mrc"],
	"application/marcxml+xml": ["mrcx"],
	"application/mathematica": [
		"ma",
		"nb",
		"mb"
	],
	"application/mathml+xml": ["mathml"],
	"application/mbox": ["mbox"],
	"application/media-policy-dataset+xml": ["mpf"],
	"application/mediaservercontrol+xml": ["mscml"],
	"application/metalink+xml": ["metalink"],
	"application/metalink4+xml": ["meta4"],
	"application/mets+xml": ["mets"],
	"application/mmt-aei+xml": ["maei"],
	"application/mmt-usd+xml": ["musd"],
	"application/mods+xml": ["mods"],
	"application/mp21": ["m21", "mp21"],
	"application/mp4": [
		"*mp4",
		"*mpg4",
		"mp4s",
		"m4p"
	],
	"application/msix": ["msix"],
	"application/msixbundle": ["msixbundle"],
	"application/msword": ["doc", "dot"],
	"application/mxf": ["mxf"],
	"application/n-quads": ["nq"],
	"application/n-triples": ["nt"],
	"application/node": ["cjs"],
	"application/octet-stream": [
		"bin",
		"dms",
		"lrf",
		"mar",
		"so",
		"dist",
		"distz",
		"pkg",
		"bpk",
		"dump",
		"elc",
		"deploy",
		"exe",
		"dll",
		"deb",
		"dmg",
		"iso",
		"img",
		"msi",
		"msp",
		"msm",
		"buffer"
	],
	"application/oda": ["oda"],
	"application/oebps-package+xml": ["opf"],
	"application/ogg": ["ogx"],
	"application/omdoc+xml": ["omdoc"],
	"application/onenote": [
		"onetoc",
		"onetoc2",
		"onetmp",
		"onepkg",
		"one",
		"onea"
	],
	"application/oxps": ["oxps"],
	"application/p2p-overlay+xml": ["relo"],
	"application/patch-ops-error+xml": ["xer"],
	"application/pdf": ["pdf"],
	"application/pgp-encrypted": ["pgp"],
	"application/pgp-keys": ["asc"],
	"application/pgp-signature": ["sig", "*asc"],
	"application/pics-rules": ["prf"],
	"application/pkcs10": ["p10"],
	"application/pkcs7-mime": ["p7m", "p7c"],
	"application/pkcs7-signature": ["p7s"],
	"application/pkcs8": ["p8"],
	"application/pkix-attr-cert": ["ac"],
	"application/pkix-cert": ["cer"],
	"application/pkix-crl": ["crl"],
	"application/pkix-pkipath": ["pkipath"],
	"application/pkixcmp": ["pki"],
	"application/pls+xml": ["pls"],
	"application/postscript": [
		"ai",
		"eps",
		"ps"
	],
	"application/provenance+xml": ["provx"],
	"application/pskc+xml": ["pskcxml"],
	"application/raml+yaml": ["raml"],
	"application/rdf+xml": ["rdf", "owl"],
	"application/reginfo+xml": ["rif"],
	"application/relax-ng-compact-syntax": ["rnc"],
	"application/resource-lists+xml": ["rl"],
	"application/resource-lists-diff+xml": ["rld"],
	"application/rls-services+xml": ["rs"],
	"application/route-apd+xml": ["rapd"],
	"application/route-s-tsid+xml": ["sls"],
	"application/route-usd+xml": ["rusd"],
	"application/rpki-ghostbusters": ["gbr"],
	"application/rpki-manifest": ["mft"],
	"application/rpki-roa": ["roa"],
	"application/rsd+xml": ["rsd"],
	"application/rss+xml": ["rss"],
	"application/rtf": ["rtf"],
	"application/sbml+xml": ["sbml"],
	"application/scvp-cv-request": ["scq"],
	"application/scvp-cv-response": ["scs"],
	"application/scvp-vp-request": ["spq"],
	"application/scvp-vp-response": ["spp"],
	"application/sdp": ["sdp"],
	"application/senml+xml": ["senmlx"],
	"application/sensml+xml": ["sensmlx"],
	"application/set-payment-initiation": ["setpay"],
	"application/set-registration-initiation": ["setreg"],
	"application/shf+xml": ["shf"],
	"application/sieve": ["siv", "sieve"],
	"application/smil+xml": ["smi", "smil"],
	"application/sparql-query": ["rq"],
	"application/sparql-results+xml": ["srx"],
	"application/sql": ["sql"],
	"application/srgs": ["gram"],
	"application/srgs+xml": ["grxml"],
	"application/sru+xml": ["sru"],
	"application/ssdl+xml": ["ssdl"],
	"application/ssml+xml": ["ssml"],
	"application/swid+xml": ["swidtag"],
	"application/tei+xml": ["tei", "teicorpus"],
	"application/thraud+xml": ["tfi"],
	"application/timestamped-data": ["tsd"],
	"application/toml": ["toml"],
	"application/trig": ["trig"],
	"application/ttml+xml": ["ttml"],
	"application/ubjson": ["ubj"],
	"application/urc-ressheet+xml": ["rsheet"],
	"application/urc-targetdesc+xml": ["td"],
	"application/voicexml+xml": ["vxml"],
	"application/wasm": ["wasm"],
	"application/watcherinfo+xml": ["wif"],
	"application/widget": ["wgt"],
	"application/winhlp": ["hlp"],
	"application/wsdl+xml": ["wsdl"],
	"application/wspolicy+xml": ["wspolicy"],
	"application/xaml+xml": ["xaml"],
	"application/xcap-att+xml": ["xav"],
	"application/xcap-caps+xml": ["xca"],
	"application/xcap-diff+xml": ["xdf"],
	"application/xcap-el+xml": ["xel"],
	"application/xcap-ns+xml": ["xns"],
	"application/xenc+xml": ["xenc"],
	"application/xfdf": ["xfdf"],
	"application/xhtml+xml": ["xhtml", "xht"],
	"application/xliff+xml": ["xlf"],
	"application/xml": [
		"xml",
		"xsl",
		"xsd",
		"rng"
	],
	"application/xml-dtd": ["dtd"],
	"application/xop+xml": ["xop"],
	"application/xproc+xml": ["xpl"],
	"application/xslt+xml": ["*xsl", "xslt"],
	"application/xspf+xml": ["xspf"],
	"application/xv+xml": [
		"mxml",
		"xhvml",
		"xvml",
		"xvm"
	],
	"application/yang": ["yang"],
	"application/yin+xml": ["yin"],
	"application/zip": ["zip"],
	"application/zip+dotlottie": ["lottie"],
	"audio/3gpp": ["*3gpp"],
	"audio/aac": ["adts", "aac"],
	"audio/adpcm": ["adp"],
	"audio/amr": ["amr"],
	"audio/basic": ["au", "snd"],
	"audio/midi": [
		"mid",
		"midi",
		"kar",
		"rmi"
	],
	"audio/mobile-xmf": ["mxmf"],
	"audio/mp3": ["*mp3"],
	"audio/mp4": [
		"m4a",
		"mp4a",
		"m4b"
	],
	"audio/mpeg": [
		"mpga",
		"mp2",
		"mp2a",
		"mp3",
		"m2a",
		"m3a"
	],
	"audio/ogg": [
		"oga",
		"ogg",
		"spx",
		"opus"
	],
	"audio/s3m": ["s3m"],
	"audio/silk": ["sil"],
	"audio/wav": ["wav"],
	"audio/wave": ["*wav"],
	"audio/webm": ["weba"],
	"audio/xm": ["xm"],
	"font/collection": ["ttc"],
	"font/otf": ["otf"],
	"font/ttf": ["ttf"],
	"font/woff": ["woff"],
	"font/woff2": ["woff2"],
	"image/aces": ["exr"],
	"image/apng": ["apng"],
	"image/avci": ["avci"],
	"image/avcs": ["avcs"],
	"image/avif": ["avif"],
	"image/bmp": ["bmp", "dib"],
	"image/cgm": ["cgm"],
	"image/dicom-rle": ["drle"],
	"image/dpx": ["dpx"],
	"image/emf": ["emf"],
	"image/fits": ["fits"],
	"image/g3fax": ["g3"],
	"image/gif": ["gif"],
	"image/heic": ["heic"],
	"image/heic-sequence": ["heics"],
	"image/heif": ["heif"],
	"image/heif-sequence": ["heifs"],
	"image/hej2k": ["hej2"],
	"image/ief": ["ief"],
	"image/jaii": ["jaii"],
	"image/jais": ["jais"],
	"image/jls": ["jls"],
	"image/jp2": ["jp2", "jpg2"],
	"image/jpeg": [
		"jpg",
		"jpeg",
		"jpe"
	],
	"image/jph": ["jph"],
	"image/jphc": ["jhc"],
	"image/jpm": ["jpm", "jpgm"],
	"image/jpx": ["jpx", "jpf"],
	"image/jxl": ["jxl"],
	"image/jxr": ["jxr"],
	"image/jxra": ["jxra"],
	"image/jxrs": ["jxrs"],
	"image/jxs": ["jxs"],
	"image/jxsc": ["jxsc"],
	"image/jxsi": ["jxsi"],
	"image/jxss": ["jxss"],
	"image/ktx": ["ktx"],
	"image/ktx2": ["ktx2"],
	"image/pjpeg": ["jfif"],
	"image/png": ["png"],
	"image/sgi": ["sgi"],
	"image/svg+xml": ["svg", "svgz"],
	"image/t38": ["t38"],
	"image/tiff": ["tif", "tiff"],
	"image/tiff-fx": ["tfx"],
	"image/webp": ["webp"],
	"image/wmf": ["wmf"],
	"message/disposition-notification": ["disposition-notification"],
	"message/global": ["u8msg"],
	"message/global-delivery-status": ["u8dsn"],
	"message/global-disposition-notification": ["u8mdn"],
	"message/global-headers": ["u8hdr"],
	"message/rfc822": [
		"eml",
		"mime",
		"mht",
		"mhtml"
	],
	"model/3mf": ["3mf"],
	"model/gltf+json": ["gltf"],
	"model/gltf-binary": ["glb"],
	"model/iges": ["igs", "iges"],
	"model/jt": ["jt"],
	"model/mesh": [
		"msh",
		"mesh",
		"silo"
	],
	"model/mtl": ["mtl"],
	"model/obj": ["obj"],
	"model/prc": ["prc"],
	"model/step": [
		"step",
		"stp",
		"stpnc",
		"p21",
		"210"
	],
	"model/step+xml": ["stpx"],
	"model/step+zip": ["stpz"],
	"model/step-xml+zip": ["stpxz"],
	"model/stl": ["stl"],
	"model/u3d": ["u3d"],
	"model/vrml": ["wrl", "vrml"],
	"model/x3d+binary": ["*x3db", "x3dbz"],
	"model/x3d+fastinfoset": ["x3db"],
	"model/x3d+vrml": ["*x3dv", "x3dvz"],
	"model/x3d+xml": ["x3d", "x3dz"],
	"model/x3d-vrml": ["x3dv"],
	"text/cache-manifest": ["appcache", "manifest"],
	"text/calendar": ["ics", "ifb"],
	"text/coffeescript": ["coffee", "litcoffee"],
	"text/css": ["css"],
	"text/csv": ["csv"],
	"text/html": [
		"html",
		"htm",
		"shtml"
	],
	"text/jade": ["jade"],
	"text/javascript": ["js", "mjs"],
	"text/jsx": ["jsx"],
	"text/less": ["less"],
	"text/markdown": ["md", "markdown"],
	"text/mathml": ["mml"],
	"text/mdx": ["mdx"],
	"text/n3": ["n3"],
	"text/plain": [
		"txt",
		"text",
		"conf",
		"def",
		"list",
		"log",
		"in",
		"ini"
	],
	"text/richtext": ["rtx"],
	"text/rtf": ["*rtf"],
	"text/sgml": ["sgml", "sgm"],
	"text/shex": ["shex"],
	"text/slim": ["slim", "slm"],
	"text/spdx": ["spdx"],
	"text/stylus": ["stylus", "styl"],
	"text/tab-separated-values": ["tsv"],
	"text/troff": [
		"t",
		"tr",
		"roff",
		"man",
		"me",
		"ms"
	],
	"text/turtle": ["ttl"],
	"text/uri-list": [
		"uri",
		"uris",
		"urls"
	],
	"text/vcard": ["vcard"],
	"text/vtt": ["vtt"],
	"text/wgsl": ["wgsl"],
	"text/xml": ["*xml"],
	"text/yaml": ["yaml", "yml"],
	"video/3gpp": ["3gp", "3gpp"],
	"video/3gpp2": ["3g2"],
	"video/h261": ["h261"],
	"video/h263": ["h263"],
	"video/h264": ["h264"],
	"video/iso.segment": ["m4s"],
	"video/jpeg": ["jpgv"],
	"video/jpm": ["*jpm", "*jpgm"],
	"video/mj2": ["mj2", "mjp2"],
	"video/mp2t": [
		"ts",
		"m2t",
		"m2ts",
		"mts"
	],
	"video/mp4": [
		"mp4",
		"mp4v",
		"mpg4"
	],
	"video/mpeg": [
		"mpeg",
		"mpg",
		"mpe",
		"m1v",
		"m2v"
	],
	"video/ogg": ["ogv"],
	"video/quicktime": ["qt", "mov"],
	"video/webm": ["webm"]
};
Object.freeze(types);
var standard_default = types;

//#endregion
//#region ../../node_modules/.pnpm/mime@4.0.7/node_modules/mime/dist/src/Mime.js
var __classPrivateFieldGet = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Mime_extensionToType, _Mime_typeToExtension, _Mime_typeToExtensions;
var Mime = class {
	constructor(...args) {
		_Mime_extensionToType.set(this, /* @__PURE__ */ new Map());
		_Mime_typeToExtension.set(this, /* @__PURE__ */ new Map());
		_Mime_typeToExtensions.set(this, /* @__PURE__ */ new Map());
		for (const arg of args) this.define(arg);
	}
	define(typeMap, force = false) {
		for (let [type, extensions] of Object.entries(typeMap)) {
			type = type.toLowerCase();
			extensions = extensions.map((ext) => ext.toLowerCase());
			if (!__classPrivateFieldGet(this, _Mime_typeToExtensions, "f").has(type)) __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").set(type, /* @__PURE__ */ new Set());
			const allExtensions = __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type);
			let first = true;
			for (let extension of extensions) {
				const starred = extension.startsWith("*");
				extension = starred ? extension.slice(1) : extension;
				allExtensions?.add(extension);
				if (first) __classPrivateFieldGet(this, _Mime_typeToExtension, "f").set(type, extension);
				first = false;
				if (starred) continue;
				const currentType = __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(extension);
				if (currentType && currentType != type && !force) throw new Error(`"${type} -> ${extension}" conflicts with "${currentType} -> ${extension}". Pass \`force=true\` to override this definition.`);
				__classPrivateFieldGet(this, _Mime_extensionToType, "f").set(extension, type);
			}
		}
		return this;
	}
	getType(path) {
		if (typeof path !== "string") return null;
		const last = path.replace(/^.*[/\\]/s, "").toLowerCase();
		const ext = last.replace(/^.*\./s, "").toLowerCase();
		const hasPath = last.length < path.length;
		if (!(ext.length < last.length - 1) && hasPath) return null;
		return __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(ext) ?? null;
	}
	getExtension(type) {
		if (typeof type !== "string") return null;
		type = type?.split?.(";")[0];
		return (type && __classPrivateFieldGet(this, _Mime_typeToExtension, "f").get(type.trim().toLowerCase())) ?? null;
	}
	getAllExtensions(type) {
		if (typeof type !== "string") return null;
		return __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type.toLowerCase()) ?? null;
	}
	_freeze() {
		this.define = () => {
			throw new Error("define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances");
		};
		Object.freeze(this);
		for (const extensions of __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").values()) Object.freeze(extensions);
		return this;
	}
	_getTestState() {
		return {
			types: __classPrivateFieldGet(this, _Mime_extensionToType, "f"),
			extensions: __classPrivateFieldGet(this, _Mime_typeToExtension, "f")
		};
	}
};
_Mime_extensionToType = /* @__PURE__ */ new WeakMap(), _Mime_typeToExtension = /* @__PURE__ */ new WeakMap(), _Mime_typeToExtensions = /* @__PURE__ */ new WeakMap();
var Mime_default = Mime;

//#endregion
//#region ../../node_modules/.pnpm/mime@4.0.7/node_modules/mime/dist/src/index.js
var src_default = new Mime_default(standard_default, other_default)._freeze();

//#endregion
//#region ../workers-shared/utils/helpers.ts
function thrownIsDoesNotExistError(thrown) {
	return thrown instanceof Error && "code" in thrown && thrown.code === "ENOENT";
}
function maybeGetFile(filePath) {
	try {
		return readFileSync(filePath, "utf8");
	} catch (e) {
		if (!thrownIsDoesNotExistError(e)) throw e;
	}
}

//#endregion
//#region ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.js
var util;
(function(util$2) {
	util$2.assertEqual = (_) => {};
	function assertIs(_arg) {}
	util$2.assertIs = assertIs;
	function assertNever$1(_x) {
		throw new Error();
	}
	util$2.assertNever = assertNever$1;
	util$2.arrayToEnum = (items) => {
		const obj = {};
		for (const item of items) obj[item] = item;
		return obj;
	};
	util$2.getValidEnumValues = (obj) => {
		const validKeys = util$2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
		const filtered = {};
		for (const k of validKeys) filtered[k] = obj[k];
		return util$2.objectValues(filtered);
	};
	util$2.objectValues = (obj) => {
		return util$2.objectKeys(obj).map(function(e) {
			return obj[e];
		});
	};
	util$2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
		const keys = [];
		for (const key in object) if (Object.prototype.hasOwnProperty.call(object, key)) keys.push(key);
		return keys;
	};
	util$2.find = (arr, checker) => {
		for (const item of arr) if (checker(item)) return item;
	};
	util$2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
	function joinValues(array, separator = " | ") {
		return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
	}
	util$2.joinValues = joinValues;
	util$2.jsonStringifyReplacer = (_, value) => {
		if (typeof value === "bigint") return value.toString();
		return value;
	};
})(util || (util = {}));
var objectUtil;
(function(objectUtil$1) {
	objectUtil$1.mergeShapes = (first, second) => {
		return {
			...first,
			...second
		};
	};
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
	"string",
	"nan",
	"number",
	"integer",
	"float",
	"boolean",
	"date",
	"bigint",
	"symbol",
	"function",
	"undefined",
	"null",
	"array",
	"object",
	"unknown",
	"promise",
	"void",
	"never",
	"map",
	"set"
]);
const getParsedType = (data$1) => {
	switch (typeof data$1) {
		case "undefined": return ZodParsedType.undefined;
		case "string": return ZodParsedType.string;
		case "number": return Number.isNaN(data$1) ? ZodParsedType.nan : ZodParsedType.number;
		case "boolean": return ZodParsedType.boolean;
		case "function": return ZodParsedType.function;
		case "bigint": return ZodParsedType.bigint;
		case "symbol": return ZodParsedType.symbol;
		case "object":
			if (Array.isArray(data$1)) return ZodParsedType.array;
			if (data$1 === null) return ZodParsedType.null;
			if (data$1.then && typeof data$1.then === "function" && data$1.catch && typeof data$1.catch === "function") return ZodParsedType.promise;
			if (typeof Map !== "undefined" && data$1 instanceof Map) return ZodParsedType.map;
			if (typeof Set !== "undefined" && data$1 instanceof Set) return ZodParsedType.set;
			if (typeof Date !== "undefined" && data$1 instanceof Date) return ZodParsedType.date;
			return ZodParsedType.object;
		default: return ZodParsedType.unknown;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.js
const ZodIssueCode = util.arrayToEnum([
	"invalid_type",
	"invalid_literal",
	"custom",
	"invalid_union",
	"invalid_union_discriminator",
	"invalid_enum_value",
	"unrecognized_keys",
	"invalid_arguments",
	"invalid_return_type",
	"invalid_date",
	"invalid_string",
	"too_small",
	"too_big",
	"invalid_intersection_types",
	"not_multiple_of",
	"not_finite"
]);
var ZodError = class ZodError extends Error {
	get errors() {
		return this.issues;
	}
	constructor(issues) {
		super();
		this.issues = [];
		this.addIssue = (sub) => {
			this.issues = [...this.issues, sub];
		};
		this.addIssues = (subs = []) => {
			this.issues = [...this.issues, ...subs];
		};
		const actualProto = new.target.prototype;
		if (Object.setPrototypeOf) Object.setPrototypeOf(this, actualProto);
		else this.__proto__ = actualProto;
		this.name = "ZodError";
		this.issues = issues;
	}
	format(_mapper) {
		const mapper = _mapper || function(issue) {
			return issue.message;
		};
		const fieldErrors = { _errors: [] };
		const processError = (error) => {
			for (const issue of error.issues) if (issue.code === "invalid_union") issue.unionErrors.map(processError);
			else if (issue.code === "invalid_return_type") processError(issue.returnTypeError);
			else if (issue.code === "invalid_arguments") processError(issue.argumentsError);
			else if (issue.path.length === 0) fieldErrors._errors.push(mapper(issue));
			else {
				let curr = fieldErrors;
				let i$1 = 0;
				while (i$1 < issue.path.length) {
					const el = issue.path[i$1];
					if (!(i$1 === issue.path.length - 1)) curr[el] = curr[el] || { _errors: [] };
					else {
						curr[el] = curr[el] || { _errors: [] };
						curr[el]._errors.push(mapper(issue));
					}
					curr = curr[el];
					i$1++;
				}
			}
		};
		processError(this);
		return fieldErrors;
	}
	static assert(value) {
		if (!(value instanceof ZodError)) throw new Error(`Not a ZodError: ${value}`);
	}
	toString() {
		return this.message;
	}
	get message() {
		return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
	}
	get isEmpty() {
		return this.issues.length === 0;
	}
	flatten(mapper = (issue) => issue.message) {
		const fieldErrors = {};
		const formErrors = [];
		for (const sub of this.issues) if (sub.path.length > 0) {
			const firstEl = sub.path[0];
			fieldErrors[firstEl] = fieldErrors[firstEl] || [];
			fieldErrors[firstEl].push(mapper(sub));
		} else formErrors.push(mapper(sub));
		return {
			formErrors,
			fieldErrors
		};
	}
	get formErrors() {
		return this.flatten();
	}
};
ZodError.create = (issues) => {
	return new ZodError(issues);
};

//#endregion
//#region ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.js
const errorMap = (issue, _ctx) => {
	let message;
	switch (issue.code) {
		case ZodIssueCode.invalid_type:
			if (issue.received === ZodParsedType.undefined) message = "Required";
			else message = `Expected ${issue.expected}, received ${issue.received}`;
			break;
		case ZodIssueCode.invalid_literal:
			message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
			break;
		case ZodIssueCode.unrecognized_keys:
			message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
			break;
		case ZodIssueCode.invalid_union:
			message = `Invalid input`;
			break;
		case ZodIssueCode.invalid_union_discriminator:
			message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
			break;
		case ZodIssueCode.invalid_enum_value:
			message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
			break;
		case ZodIssueCode.invalid_arguments:
			message = `Invalid function arguments`;
			break;
		case ZodIssueCode.invalid_return_type:
			message = `Invalid function return type`;
			break;
		case ZodIssueCode.invalid_date:
			message = `Invalid date`;
			break;
		case ZodIssueCode.invalid_string:
			if (typeof issue.validation === "object") if ("includes" in issue.validation) {
				message = `Invalid input: must include "${issue.validation.includes}"`;
				if (typeof issue.validation.position === "number") message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
			} else if ("startsWith" in issue.validation) message = `Invalid input: must start with "${issue.validation.startsWith}"`;
			else if ("endsWith" in issue.validation) message = `Invalid input: must end with "${issue.validation.endsWith}"`;
			else util.assertNever(issue.validation);
			else if (issue.validation !== "regex") message = `Invalid ${issue.validation}`;
			else message = "Invalid";
			break;
		case ZodIssueCode.too_small:
			if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
			else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
			else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
			else if (issue.type === "bigint") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
			else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.too_big:
			if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
			else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
			else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
			else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
			else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.custom:
			message = `Invalid input`;
			break;
		case ZodIssueCode.invalid_intersection_types:
			message = `Intersection results could not be merged`;
			break;
		case ZodIssueCode.not_multiple_of:
			message = `Number must be a multiple of ${issue.multipleOf}`;
			break;
		case ZodIssueCode.not_finite:
			message = "Number must be finite";
			break;
		default:
			message = _ctx.defaultError;
			util.assertNever(issue);
	}
	return { message };
};
var en_default = errorMap;

//#endregion
//#region ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/errors.js
let overrideErrorMap = en_default;
function getErrorMap() {
	return overrideErrorMap;
}

//#endregion
//#region ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/parseUtil.js
const makeIssue = (params) => {
	const { data: data$1, path, errorMaps, issueData } = params;
	const fullPath = [...path, ...issueData.path || []];
	const fullIssue = {
		...issueData,
		path: fullPath
	};
	if (issueData.message !== void 0) return {
		...issueData,
		path: fullPath,
		message: issueData.message
	};
	let errorMessage = "";
	const maps = errorMaps.filter((m) => !!m).slice().reverse();
	for (const map of maps) errorMessage = map(fullIssue, {
		data: data$1,
		defaultError: errorMessage
	}).message;
	return {
		...issueData,
		path: fullPath,
		message: errorMessage
	};
};
function addIssueToContext(ctx, issueData) {
	const overrideMap = getErrorMap();
	const issue = makeIssue({
		issueData,
		data: ctx.data,
		path: ctx.path,
		errorMaps: [
			ctx.common.contextualErrorMap,
			ctx.schemaErrorMap,
			overrideMap,
			overrideMap === en_default ? void 0 : en_default
		].filter((x) => !!x)
	});
	ctx.common.issues.push(issue);
}
var ParseStatus = class ParseStatus {
	constructor() {
		this.value = "valid";
	}
	dirty() {
		if (this.value === "valid") this.value = "dirty";
	}
	abort() {
		if (this.value !== "aborted") this.value = "aborted";
	}
	static mergeArray(status, results) {
		const arrayValue = [];
		for (const s of results) {
			if (s.status === "aborted") return INVALID;
			if (s.status === "dirty") status.dirty();
			arrayValue.push(s.value);
		}
		return {
			status: status.value,
			value: arrayValue
		};
	}
	static async mergeObjectAsync(status, pairs) {
		const syncPairs = [];
		for (const pair of pairs) {
			const key = await pair.key;
			const value = await pair.value;
			syncPairs.push({
				key,
				value
			});
		}
		return ParseStatus.mergeObjectSync(status, syncPairs);
	}
	static mergeObjectSync(status, pairs) {
		const finalObject = {};
		for (const pair of pairs) {
			const { key, value } = pair;
			if (key.status === "aborted") return INVALID;
			if (value.status === "aborted") return INVALID;
			if (key.status === "dirty") status.dirty();
			if (value.status === "dirty") status.dirty();
			if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) finalObject[key.value] = value.value;
		}
		return {
			status: status.value,
			value: finalObject
		};
	}
};
const INVALID = Object.freeze({ status: "aborted" });
const DIRTY = (value) => ({
	status: "dirty",
	value
});
const OK = (value) => ({
	status: "valid",
	value
});
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

//#endregion
//#region ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil$1) {
	errorUtil$1.errToObj = (message) => typeof message === "string" ? { message } : message || {};
	errorUtil$1.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

//#endregion
//#region ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
	constructor(parent, value, path, key) {
		this._cachedPath = [];
		this.parent = parent;
		this.data = value;
		this._path = path;
		this._key = key;
	}
	get path() {
		if (!this._cachedPath.length) if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
		else this._cachedPath.push(...this._path, this._key);
		return this._cachedPath;
	}
};
const handleResult = (ctx, result) => {
	if (isValid(result)) return {
		success: true,
		data: result.value
	};
	else {
		if (!ctx.common.issues.length) throw new Error("Validation failed but no issues detected.");
		return {
			success: false,
			get error() {
				if (this._error) return this._error;
				this._error = new ZodError(ctx.common.issues);
				return this._error;
			}
		};
	}
};
function processCreateParams(params) {
	if (!params) return {};
	const { errorMap: errorMap$1, invalid_type_error, required_error, description } = params;
	if (errorMap$1 && (invalid_type_error || required_error)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
	if (errorMap$1) return {
		errorMap: errorMap$1,
		description
	};
	const customMap = (iss, ctx) => {
		const { message } = params;
		if (iss.code === "invalid_enum_value") return { message: message ?? ctx.defaultError };
		if (typeof ctx.data === "undefined") return { message: message ?? required_error ?? ctx.defaultError };
		if (iss.code !== "invalid_type") return { message: ctx.defaultError };
		return { message: message ?? invalid_type_error ?? ctx.defaultError };
	};
	return {
		errorMap: customMap,
		description
	};
}
var ZodType = class {
	get description() {
		return this._def.description;
	}
	_getType(input) {
		return getParsedType(input.data);
	}
	_getOrReturnCtx(input, ctx) {
		return ctx || {
			common: input.parent.common,
			data: input.data,
			parsedType: getParsedType(input.data),
			schemaErrorMap: this._def.errorMap,
			path: input.path,
			parent: input.parent
		};
	}
	_processInputParams(input) {
		return {
			status: new ParseStatus(),
			ctx: {
				common: input.parent.common,
				data: input.data,
				parsedType: getParsedType(input.data),
				schemaErrorMap: this._def.errorMap,
				path: input.path,
				parent: input.parent
			}
		};
	}
	_parseSync(input) {
		const result = this._parse(input);
		if (isAsync(result)) throw new Error("Synchronous parse encountered promise.");
		return result;
	}
	_parseAsync(input) {
		const result = this._parse(input);
		return Promise.resolve(result);
	}
	parse(data$1, params) {
		const result = this.safeParse(data$1, params);
		if (result.success) return result.data;
		throw result.error;
	}
	safeParse(data$1, params) {
		const ctx = {
			common: {
				issues: [],
				async: params?.async ?? false,
				contextualErrorMap: params?.errorMap
			},
			path: params?.path || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data: data$1,
			parsedType: getParsedType(data$1)
		};
		return handleResult(ctx, this._parseSync({
			data: data$1,
			path: ctx.path,
			parent: ctx
		}));
	}
	"~validate"(data$1) {
		const ctx = {
			common: {
				issues: [],
				async: !!this["~standard"].async
			},
			path: [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data: data$1,
			parsedType: getParsedType(data$1)
		};
		if (!this["~standard"].async) try {
			const result = this._parseSync({
				data: data$1,
				path: [],
				parent: ctx
			});
			return isValid(result) ? { value: result.value } : { issues: ctx.common.issues };
		} catch (err) {
			if (err?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = true;
			ctx.common = {
				issues: [],
				async: true
			};
		}
		return this._parseAsync({
			data: data$1,
			path: [],
			parent: ctx
		}).then((result) => isValid(result) ? { value: result.value } : { issues: ctx.common.issues });
	}
	async parseAsync(data$1, params) {
		const result = await this.safeParseAsync(data$1, params);
		if (result.success) return result.data;
		throw result.error;
	}
	async safeParseAsync(data$1, params) {
		const ctx = {
			common: {
				issues: [],
				contextualErrorMap: params?.errorMap,
				async: true
			},
			path: params?.path || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data: data$1,
			parsedType: getParsedType(data$1)
		};
		const maybeAsyncResult = this._parse({
			data: data$1,
			path: ctx.path,
			parent: ctx
		});
		return handleResult(ctx, await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult)));
	}
	refine(check, message) {
		const getIssueProperties = (val) => {
			if (typeof message === "string" || typeof message === "undefined") return { message };
			else if (typeof message === "function") return message(val);
			else return message;
		};
		return this._refinement((val, ctx) => {
			const result = check(val);
			const setError = () => ctx.addIssue({
				code: ZodIssueCode.custom,
				...getIssueProperties(val)
			});
			if (typeof Promise !== "undefined" && result instanceof Promise) return result.then((data$1) => {
				if (!data$1) {
					setError();
					return false;
				} else return true;
			});
			if (!result) {
				setError();
				return false;
			} else return true;
		});
	}
	refinement(check, refinementData) {
		return this._refinement((val, ctx) => {
			if (!check(val)) {
				ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
				return false;
			} else return true;
		});
	}
	_refinement(refinement) {
		return new ZodEffects({
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: {
				type: "refinement",
				refinement
			}
		});
	}
	superRefine(refinement) {
		return this._refinement(refinement);
	}
	constructor(def) {
		/** Alias of safeParseAsync */
		this.spa = this.safeParseAsync;
		this._def = def;
		this.parse = this.parse.bind(this);
		this.safeParse = this.safeParse.bind(this);
		this.parseAsync = this.parseAsync.bind(this);
		this.safeParseAsync = this.safeParseAsync.bind(this);
		this.spa = this.spa.bind(this);
		this.refine = this.refine.bind(this);
		this.refinement = this.refinement.bind(this);
		this.superRefine = this.superRefine.bind(this);
		this.optional = this.optional.bind(this);
		this.nullable = this.nullable.bind(this);
		this.nullish = this.nullish.bind(this);
		this.array = this.array.bind(this);
		this.promise = this.promise.bind(this);
		this.or = this.or.bind(this);
		this.and = this.and.bind(this);
		this.transform = this.transform.bind(this);
		this.brand = this.brand.bind(this);
		this.default = this.default.bind(this);
		this.catch = this.catch.bind(this);
		this.describe = this.describe.bind(this);
		this.pipe = this.pipe.bind(this);
		this.readonly = this.readonly.bind(this);
		this.isNullable = this.isNullable.bind(this);
		this.isOptional = this.isOptional.bind(this);
		this["~standard"] = {
			version: 1,
			vendor: "zod",
			validate: (data$1) => this["~validate"](data$1)
		};
	}
	optional() {
		return ZodOptional.create(this, this._def);
	}
	nullable() {
		return ZodNullable.create(this, this._def);
	}
	nullish() {
		return this.nullable().optional();
	}
	array() {
		return ZodArray.create(this);
	}
	promise() {
		return ZodPromise.create(this, this._def);
	}
	or(option) {
		return ZodUnion.create([this, option], this._def);
	}
	and(incoming) {
		return ZodIntersection.create(this, incoming, this._def);
	}
	transform(transform) {
		return new ZodEffects({
			...processCreateParams(this._def),
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: {
				type: "transform",
				transform
			}
		});
	}
	default(def) {
		const defaultValueFunc = typeof def === "function" ? def : () => def;
		return new ZodDefault({
			...processCreateParams(this._def),
			innerType: this,
			defaultValue: defaultValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodDefault
		});
	}
	brand() {
		return new ZodBranded({
			typeName: ZodFirstPartyTypeKind.ZodBranded,
			type: this,
			...processCreateParams(this._def)
		});
	}
	catch(def) {
		const catchValueFunc = typeof def === "function" ? def : () => def;
		return new ZodCatch({
			...processCreateParams(this._def),
			innerType: this,
			catchValue: catchValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodCatch
		});
	}
	describe(description) {
		const This = this.constructor;
		return new This({
			...this._def,
			description
		});
	}
	pipe(target$1) {
		return ZodPipeline.create(this, target$1);
	}
	readonly() {
		return ZodReadonly.create(this);
	}
	isOptional() {
		return this.safeParse(void 0).success;
	}
	isNullable() {
		return this.safeParse(null).success;
	}
};
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = /* @__PURE__ */ new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
	let secondsRegexSource = `[0-5]\\d`;
	if (args.precision) secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
	else if (args.precision == null) secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
	const secondsQuantifier = args.precision ? "+" : "?";
	return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
	return /* @__PURE__ */ new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
	let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
	const opts = [];
	opts.push(args.local ? `Z?` : `Z`);
	if (args.offset) opts.push(`([+-]\\d{2}:?\\d{2})`);
	regex = `${regex}(${opts.join("|")})`;
	return /* @__PURE__ */ new RegExp(`^${regex}$`);
}
function isValidIP(ip, version$2) {
	if ((version$2 === "v4" || !version$2) && ipv4Regex.test(ip)) return true;
	if ((version$2 === "v6" || !version$2) && ipv6Regex.test(ip)) return true;
	return false;
}
function isValidJWT(jwt, alg) {
	if (!jwtRegex.test(jwt)) return false;
	try {
		const [header] = jwt.split(".");
		if (!header) return false;
		const base64$1 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
		const decoded = JSON.parse(atob(base64$1));
		if (typeof decoded !== "object" || decoded === null) return false;
		if ("typ" in decoded && decoded?.typ !== "JWT") return false;
		if (!decoded.alg) return false;
		if (alg && decoded.alg !== alg) return false;
		return true;
	} catch {
		return false;
	}
}
function isValidCidr(ip, version$2) {
	if ((version$2 === "v4" || !version$2) && ipv4CidrRegex.test(ip)) return true;
	if ((version$2 === "v6" || !version$2) && ipv6CidrRegex.test(ip)) return true;
	return false;
}
var ZodString = class ZodString extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = String(input.data);
		if (this._getType(input) !== ZodParsedType.string) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.string,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		const status = new ParseStatus();
		let ctx = void 0;
		for (const check of this._def.checks) if (check.kind === "min") {
			if (input.data.length < check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "string",
					inclusive: true,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (input.data.length > check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "string",
					inclusive: true,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "length") {
			const tooBig = input.data.length > check.value;
			const tooSmall = input.data.length < check.value;
			if (tooBig || tooSmall) {
				ctx = this._getOrReturnCtx(input, ctx);
				if (tooBig) addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "string",
					inclusive: true,
					exact: true,
					message: check.message
				});
				else if (tooSmall) addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "string",
					inclusive: true,
					exact: true,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "email") {
			if (!emailRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "email",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "emoji") {
			if (!emojiRegex) emojiRegex = new RegExp(_emojiRegex, "u");
			if (!emojiRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "emoji",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "uuid") {
			if (!uuidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "uuid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "nanoid") {
			if (!nanoidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "nanoid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "cuid") {
			if (!cuidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "cuid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "cuid2") {
			if (!cuid2Regex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "cuid2",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "ulid") {
			if (!ulidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "ulid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "url") try {
			new URL(input.data);
		} catch {
			ctx = this._getOrReturnCtx(input, ctx);
			addIssueToContext(ctx, {
				validation: "url",
				code: ZodIssueCode.invalid_string,
				message: check.message
			});
			status.dirty();
		}
		else if (check.kind === "regex") {
			check.regex.lastIndex = 0;
			if (!check.regex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "regex",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "trim") input.data = input.data.trim();
		else if (check.kind === "includes") {
			if (!input.data.includes(check.value, check.position)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: {
						includes: check.value,
						position: check.position
					},
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "toLowerCase") input.data = input.data.toLowerCase();
		else if (check.kind === "toUpperCase") input.data = input.data.toUpperCase();
		else if (check.kind === "startsWith") {
			if (!input.data.startsWith(check.value)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: { startsWith: check.value },
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "endsWith") {
			if (!input.data.endsWith(check.value)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: { endsWith: check.value },
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "datetime") {
			if (!datetimeRegex(check).test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: "datetime",
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "date") {
			if (!dateRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: "date",
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "time") {
			if (!timeRegex(check).test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: "time",
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "duration") {
			if (!durationRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "duration",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "ip") {
			if (!isValidIP(input.data, check.version)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "ip",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "jwt") {
			if (!isValidJWT(input.data, check.alg)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "jwt",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "cidr") {
			if (!isValidCidr(input.data, check.version)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "cidr",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "base64") {
			if (!base64Regex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "base64",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "base64url") {
			if (!base64urlRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "base64url",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: input.data
		};
	}
	_regex(regex, validation, message) {
		return this.refinement((data$1) => regex.test(data$1), {
			validation,
			code: ZodIssueCode.invalid_string,
			...errorUtil.errToObj(message)
		});
	}
	_addCheck(check) {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	email(message) {
		return this._addCheck({
			kind: "email",
			...errorUtil.errToObj(message)
		});
	}
	url(message) {
		return this._addCheck({
			kind: "url",
			...errorUtil.errToObj(message)
		});
	}
	emoji(message) {
		return this._addCheck({
			kind: "emoji",
			...errorUtil.errToObj(message)
		});
	}
	uuid(message) {
		return this._addCheck({
			kind: "uuid",
			...errorUtil.errToObj(message)
		});
	}
	nanoid(message) {
		return this._addCheck({
			kind: "nanoid",
			...errorUtil.errToObj(message)
		});
	}
	cuid(message) {
		return this._addCheck({
			kind: "cuid",
			...errorUtil.errToObj(message)
		});
	}
	cuid2(message) {
		return this._addCheck({
			kind: "cuid2",
			...errorUtil.errToObj(message)
		});
	}
	ulid(message) {
		return this._addCheck({
			kind: "ulid",
			...errorUtil.errToObj(message)
		});
	}
	base64(message) {
		return this._addCheck({
			kind: "base64",
			...errorUtil.errToObj(message)
		});
	}
	base64url(message) {
		return this._addCheck({
			kind: "base64url",
			...errorUtil.errToObj(message)
		});
	}
	jwt(options) {
		return this._addCheck({
			kind: "jwt",
			...errorUtil.errToObj(options)
		});
	}
	ip(options) {
		return this._addCheck({
			kind: "ip",
			...errorUtil.errToObj(options)
		});
	}
	cidr(options) {
		return this._addCheck({
			kind: "cidr",
			...errorUtil.errToObj(options)
		});
	}
	datetime(options) {
		if (typeof options === "string") return this._addCheck({
			kind: "datetime",
			precision: null,
			offset: false,
			local: false,
			message: options
		});
		return this._addCheck({
			kind: "datetime",
			precision: typeof options?.precision === "undefined" ? null : options?.precision,
			offset: options?.offset ?? false,
			local: options?.local ?? false,
			...errorUtil.errToObj(options?.message)
		});
	}
	date(message) {
		return this._addCheck({
			kind: "date",
			message
		});
	}
	time(options) {
		if (typeof options === "string") return this._addCheck({
			kind: "time",
			precision: null,
			message: options
		});
		return this._addCheck({
			kind: "time",
			precision: typeof options?.precision === "undefined" ? null : options?.precision,
			...errorUtil.errToObj(options?.message)
		});
	}
	duration(message) {
		return this._addCheck({
			kind: "duration",
			...errorUtil.errToObj(message)
		});
	}
	regex(regex, message) {
		return this._addCheck({
			kind: "regex",
			regex,
			...errorUtil.errToObj(message)
		});
	}
	includes(value, options) {
		return this._addCheck({
			kind: "includes",
			value,
			position: options?.position,
			...errorUtil.errToObj(options?.message)
		});
	}
	startsWith(value, message) {
		return this._addCheck({
			kind: "startsWith",
			value,
			...errorUtil.errToObj(message)
		});
	}
	endsWith(value, message) {
		return this._addCheck({
			kind: "endsWith",
			value,
			...errorUtil.errToObj(message)
		});
	}
	min(minLength, message) {
		return this._addCheck({
			kind: "min",
			value: minLength,
			...errorUtil.errToObj(message)
		});
	}
	max(maxLength, message) {
		return this._addCheck({
			kind: "max",
			value: maxLength,
			...errorUtil.errToObj(message)
		});
	}
	length(len, message) {
		return this._addCheck({
			kind: "length",
			value: len,
			...errorUtil.errToObj(message)
		});
	}
	/**
	* Equivalent to `.min(1)`
	*/
	nonempty(message) {
		return this.min(1, errorUtil.errToObj(message));
	}
	trim() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "trim" }]
		});
	}
	toLowerCase() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toLowerCase" }]
		});
	}
	toUpperCase() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toUpperCase" }]
		});
	}
	get isDatetime() {
		return !!this._def.checks.find((ch) => ch.kind === "datetime");
	}
	get isDate() {
		return !!this._def.checks.find((ch) => ch.kind === "date");
	}
	get isTime() {
		return !!this._def.checks.find((ch) => ch.kind === "time");
	}
	get isDuration() {
		return !!this._def.checks.find((ch) => ch.kind === "duration");
	}
	get isEmail() {
		return !!this._def.checks.find((ch) => ch.kind === "email");
	}
	get isURL() {
		return !!this._def.checks.find((ch) => ch.kind === "url");
	}
	get isEmoji() {
		return !!this._def.checks.find((ch) => ch.kind === "emoji");
	}
	get isUUID() {
		return !!this._def.checks.find((ch) => ch.kind === "uuid");
	}
	get isNANOID() {
		return !!this._def.checks.find((ch) => ch.kind === "nanoid");
	}
	get isCUID() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid");
	}
	get isCUID2() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid2");
	}
	get isULID() {
		return !!this._def.checks.find((ch) => ch.kind === "ulid");
	}
	get isIP() {
		return !!this._def.checks.find((ch) => ch.kind === "ip");
	}
	get isCIDR() {
		return !!this._def.checks.find((ch) => ch.kind === "cidr");
	}
	get isBase64() {
		return !!this._def.checks.find((ch) => ch.kind === "base64");
	}
	get isBase64url() {
		return !!this._def.checks.find((ch) => ch.kind === "base64url");
	}
	get minLength() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min;
	}
	get maxLength() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max;
	}
};
ZodString.create = (params) => {
	return new ZodString({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodString,
		coerce: params?.coerce ?? false,
		...processCreateParams(params)
	});
};
function floatSafeRemainder(val, step) {
	const valDecCount = (val.toString().split(".")[1] || "").length;
	const stepDecCount = (step.toString().split(".")[1] || "").length;
	const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	return Number.parseInt(val.toFixed(decCount).replace(".", "")) % Number.parseInt(step.toFixed(decCount).replace(".", "")) / 10 ** decCount;
}
var ZodNumber = class ZodNumber extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
		this.step = this.multipleOf;
	}
	_parse(input) {
		if (this._def.coerce) input.data = Number(input.data);
		if (this._getType(input) !== ZodParsedType.number) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.number,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		let ctx = void 0;
		const status = new ParseStatus();
		for (const check of this._def.checks) if (check.kind === "int") {
			if (!util.isInteger(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: "integer",
					received: "float",
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "min") {
			if (check.inclusive ? input.data < check.value : input.data <= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "number",
					inclusive: check.inclusive,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (check.inclusive ? input.data > check.value : input.data >= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "number",
					inclusive: check.inclusive,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "multipleOf") {
			if (floatSafeRemainder(input.data, check.value) !== 0) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_multiple_of,
					multipleOf: check.value,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "finite") {
			if (!Number.isFinite(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_finite,
					message: check.message
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: input.data
		};
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, {
				kind,
				value,
				inclusive,
				message: errorUtil.toString(message)
			}]
		});
	}
	_addCheck(check) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	int(message) {
		return this._addCheck({
			kind: "int",
			message: errorUtil.toString(message)
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message)
		});
	}
	finite(message) {
		return this._addCheck({
			kind: "finite",
			message: errorUtil.toString(message)
		});
	}
	safe(message) {
		return this._addCheck({
			kind: "min",
			inclusive: true,
			value: Number.MIN_SAFE_INTEGER,
			message: errorUtil.toString(message)
		})._addCheck({
			kind: "max",
			inclusive: true,
			value: Number.MAX_SAFE_INTEGER,
			message: errorUtil.toString(message)
		});
	}
	get minValue() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min;
	}
	get maxValue() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max;
	}
	get isInt() {
		return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
	}
	get isFinite() {
		let max = null;
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") return true;
		else if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		} else if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return Number.isFinite(min) && Number.isFinite(max);
	}
};
ZodNumber.create = (params) => {
	return new ZodNumber({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodNumber,
		coerce: params?.coerce || false,
		...processCreateParams(params)
	});
};
var ZodBigInt = class ZodBigInt extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
	}
	_parse(input) {
		if (this._def.coerce) try {
			input.data = BigInt(input.data);
		} catch {
			return this._getInvalidInput(input);
		}
		if (this._getType(input) !== ZodParsedType.bigint) return this._getInvalidInput(input);
		let ctx = void 0;
		const status = new ParseStatus();
		for (const check of this._def.checks) if (check.kind === "min") {
			if (check.inclusive ? input.data < check.value : input.data <= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					type: "bigint",
					minimum: check.value,
					inclusive: check.inclusive,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (check.inclusive ? input.data > check.value : input.data >= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					type: "bigint",
					maximum: check.value,
					inclusive: check.inclusive,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "multipleOf") {
			if (input.data % check.value !== BigInt(0)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_multiple_of,
					multipleOf: check.value,
					message: check.message
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: input.data
		};
	}
	_getInvalidInput(input) {
		const ctx = this._getOrReturnCtx(input);
		addIssueToContext(ctx, {
			code: ZodIssueCode.invalid_type,
			expected: ZodParsedType.bigint,
			received: ctx.parsedType
		});
		return INVALID;
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, {
				kind,
				value,
				inclusive,
				message: errorUtil.toString(message)
			}]
		});
	}
	_addCheck(check) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message)
		});
	}
	get minValue() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min;
	}
	get maxValue() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max;
	}
};
ZodBigInt.create = (params) => {
	return new ZodBigInt({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodBigInt,
		coerce: params?.coerce ?? false,
		...processCreateParams(params)
	});
};
var ZodBoolean = class extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = Boolean(input.data);
		if (this._getType(input) !== ZodParsedType.boolean) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.boolean,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodBoolean.create = (params) => {
	return new ZodBoolean({
		typeName: ZodFirstPartyTypeKind.ZodBoolean,
		coerce: params?.coerce || false,
		...processCreateParams(params)
	});
};
var ZodDate = class ZodDate extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = new Date(input.data);
		if (this._getType(input) !== ZodParsedType.date) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.date,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		if (Number.isNaN(input.data.getTime())) {
			addIssueToContext(this._getOrReturnCtx(input), { code: ZodIssueCode.invalid_date });
			return INVALID;
		}
		const status = new ParseStatus();
		let ctx = void 0;
		for (const check of this._def.checks) if (check.kind === "min") {
			if (input.data.getTime() < check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					message: check.message,
					inclusive: true,
					exact: false,
					minimum: check.value,
					type: "date"
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (input.data.getTime() > check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					message: check.message,
					inclusive: true,
					exact: false,
					maximum: check.value,
					type: "date"
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: new Date(input.data.getTime())
		};
	}
	_addCheck(check) {
		return new ZodDate({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	min(minDate, message) {
		return this._addCheck({
			kind: "min",
			value: minDate.getTime(),
			message: errorUtil.toString(message)
		});
	}
	max(maxDate, message) {
		return this._addCheck({
			kind: "max",
			value: maxDate.getTime(),
			message: errorUtil.toString(message)
		});
	}
	get minDate() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min != null ? new Date(min) : null;
	}
	get maxDate() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max != null ? new Date(max) : null;
	}
};
ZodDate.create = (params) => {
	return new ZodDate({
		checks: [],
		coerce: params?.coerce || false,
		typeName: ZodFirstPartyTypeKind.ZodDate,
		...processCreateParams(params)
	});
};
var ZodSymbol = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.symbol) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.symbol,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodSymbol.create = (params) => {
	return new ZodSymbol({
		typeName: ZodFirstPartyTypeKind.ZodSymbol,
		...processCreateParams(params)
	});
};
var ZodUndefined = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.undefined,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodUndefined.create = (params) => {
	return new ZodUndefined({
		typeName: ZodFirstPartyTypeKind.ZodUndefined,
		...processCreateParams(params)
	});
};
var ZodNull = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.null) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.null,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodNull.create = (params) => {
	return new ZodNull({
		typeName: ZodFirstPartyTypeKind.ZodNull,
		...processCreateParams(params)
	});
};
var ZodAny = class extends ZodType {
	constructor() {
		super(...arguments);
		this._any = true;
	}
	_parse(input) {
		return OK(input.data);
	}
};
ZodAny.create = (params) => {
	return new ZodAny({
		typeName: ZodFirstPartyTypeKind.ZodAny,
		...processCreateParams(params)
	});
};
var ZodUnknown = class extends ZodType {
	constructor() {
		super(...arguments);
		this._unknown = true;
	}
	_parse(input) {
		return OK(input.data);
	}
};
ZodUnknown.create = (params) => {
	return new ZodUnknown({
		typeName: ZodFirstPartyTypeKind.ZodUnknown,
		...processCreateParams(params)
	});
};
var ZodNever = class extends ZodType {
	_parse(input) {
		const ctx = this._getOrReturnCtx(input);
		addIssueToContext(ctx, {
			code: ZodIssueCode.invalid_type,
			expected: ZodParsedType.never,
			received: ctx.parsedType
		});
		return INVALID;
	}
};
ZodNever.create = (params) => {
	return new ZodNever({
		typeName: ZodFirstPartyTypeKind.ZodNever,
		...processCreateParams(params)
	});
};
var ZodVoid = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.void,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodVoid.create = (params) => {
	return new ZodVoid({
		typeName: ZodFirstPartyTypeKind.ZodVoid,
		...processCreateParams(params)
	});
};
var ZodArray = class ZodArray extends ZodType {
	_parse(input) {
		const { ctx, status } = this._processInputParams(input);
		const def = this._def;
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType
			});
			return INVALID;
		}
		if (def.exactLength !== null) {
			const tooBig = ctx.data.length > def.exactLength.value;
			const tooSmall = ctx.data.length < def.exactLength.value;
			if (tooBig || tooSmall) {
				addIssueToContext(ctx, {
					code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
					minimum: tooSmall ? def.exactLength.value : void 0,
					maximum: tooBig ? def.exactLength.value : void 0,
					type: "array",
					inclusive: true,
					exact: true,
					message: def.exactLength.message
				});
				status.dirty();
			}
		}
		if (def.minLength !== null) {
			if (ctx.data.length < def.minLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.minLength.message
				});
				status.dirty();
			}
		}
		if (def.maxLength !== null) {
			if (ctx.data.length > def.maxLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.maxLength.message
				});
				status.dirty();
			}
		}
		if (ctx.common.async) return Promise.all([...ctx.data].map((item, i$1) => {
			return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i$1));
		})).then((result$1) => {
			return ParseStatus.mergeArray(status, result$1);
		});
		const result = [...ctx.data].map((item, i$1) => {
			return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i$1));
		});
		return ParseStatus.mergeArray(status, result);
	}
	get element() {
		return this._def.type;
	}
	min(minLength, message) {
		return new ZodArray({
			...this._def,
			minLength: {
				value: minLength,
				message: errorUtil.toString(message)
			}
		});
	}
	max(maxLength, message) {
		return new ZodArray({
			...this._def,
			maxLength: {
				value: maxLength,
				message: errorUtil.toString(message)
			}
		});
	}
	length(len, message) {
		return new ZodArray({
			...this._def,
			exactLength: {
				value: len,
				message: errorUtil.toString(message)
			}
		});
	}
	nonempty(message) {
		return this.min(1, message);
	}
};
ZodArray.create = (schema, params) => {
	return new ZodArray({
		type: schema,
		minLength: null,
		maxLength: null,
		exactLength: null,
		typeName: ZodFirstPartyTypeKind.ZodArray,
		...processCreateParams(params)
	});
};
function deepPartialify(schema) {
	if (schema instanceof ZodObject) {
		const newShape = {};
		for (const key in schema.shape) {
			const fieldSchema = schema.shape[key];
			newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
		}
		return new ZodObject({
			...schema._def,
			shape: () => newShape
		});
	} else if (schema instanceof ZodArray) return new ZodArray({
		...schema._def,
		type: deepPartialify(schema.element)
	});
	else if (schema instanceof ZodOptional) return ZodOptional.create(deepPartialify(schema.unwrap()));
	else if (schema instanceof ZodNullable) return ZodNullable.create(deepPartialify(schema.unwrap()));
	else if (schema instanceof ZodTuple) return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
	else return schema;
}
var ZodObject = class ZodObject extends ZodType {
	constructor() {
		super(...arguments);
		this._cached = null;
		/**
		* @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
		* If you want to pass through unknown properties, use `.passthrough()` instead.
		*/
		this.nonstrict = this.passthrough;
		/**
		* @deprecated Use `.extend` instead
		*  */
		this.augment = this.extend;
	}
	_getCached() {
		if (this._cached !== null) return this._cached;
		const shape = this._def.shape();
		this._cached = {
			shape,
			keys: util.objectKeys(shape)
		};
		return this._cached;
	}
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.object) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		const { status, ctx } = this._processInputParams(input);
		const { shape, keys: shapeKeys } = this._getCached();
		const extraKeys = [];
		if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
			for (const key in ctx.data) if (!shapeKeys.includes(key)) extraKeys.push(key);
		}
		const pairs = [];
		for (const key of shapeKeys) {
			const keyValidator = shape[key];
			const value = ctx.data[key];
			pairs.push({
				key: {
					status: "valid",
					value: key
				},
				value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
				alwaysSet: key in ctx.data
			});
		}
		if (this._def.catchall instanceof ZodNever) {
			const unknownKeys = this._def.unknownKeys;
			if (unknownKeys === "passthrough") for (const key of extraKeys) pairs.push({
				key: {
					status: "valid",
					value: key
				},
				value: {
					status: "valid",
					value: ctx.data[key]
				}
			});
			else if (unknownKeys === "strict") {
				if (extraKeys.length > 0) {
					addIssueToContext(ctx, {
						code: ZodIssueCode.unrecognized_keys,
						keys: extraKeys
					});
					status.dirty();
				}
			} else if (unknownKeys === "strip") {} else throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
		} else {
			const catchall = this._def.catchall;
			for (const key of extraKeys) {
				const value = ctx.data[key];
				pairs.push({
					key: {
						status: "valid",
						value: key
					},
					value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
					alwaysSet: key in ctx.data
				});
			}
		}
		if (ctx.common.async) return Promise.resolve().then(async () => {
			const syncPairs = [];
			for (const pair of pairs) {
				const key = await pair.key;
				const value = await pair.value;
				syncPairs.push({
					key,
					value,
					alwaysSet: pair.alwaysSet
				});
			}
			return syncPairs;
		}).then((syncPairs) => {
			return ParseStatus.mergeObjectSync(status, syncPairs);
		});
		else return ParseStatus.mergeObjectSync(status, pairs);
	}
	get shape() {
		return this._def.shape();
	}
	strict(message) {
		errorUtil.errToObj;
		return new ZodObject({
			...this._def,
			unknownKeys: "strict",
			...message !== void 0 ? { errorMap: (issue, ctx) => {
				const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
				if (issue.code === "unrecognized_keys") return { message: errorUtil.errToObj(message).message ?? defaultError };
				return { message: defaultError };
			} } : {}
		});
	}
	strip() {
		return new ZodObject({
			...this._def,
			unknownKeys: "strip"
		});
	}
	passthrough() {
		return new ZodObject({
			...this._def,
			unknownKeys: "passthrough"
		});
	}
	extend(augmentation) {
		return new ZodObject({
			...this._def,
			shape: () => ({
				...this._def.shape(),
				...augmentation
			})
		});
	}
	/**
	* Prior to zod@1.0.12 there was a bug in the
	* inferred type of merged objects. Please
	* upgrade if you are experiencing issues.
	*/
	merge(merging) {
		return new ZodObject({
			unknownKeys: merging._def.unknownKeys,
			catchall: merging._def.catchall,
			shape: () => ({
				...this._def.shape(),
				...merging._def.shape()
			}),
			typeName: ZodFirstPartyTypeKind.ZodObject
		});
	}
	setKey(key, schema) {
		return this.augment({ [key]: schema });
	}
	catchall(index) {
		return new ZodObject({
			...this._def,
			catchall: index
		});
	}
	pick(mask) {
		const shape = {};
		for (const key of util.objectKeys(mask)) if (mask[key] && this.shape[key]) shape[key] = this.shape[key];
		return new ZodObject({
			...this._def,
			shape: () => shape
		});
	}
	omit(mask) {
		const shape = {};
		for (const key of util.objectKeys(this.shape)) if (!mask[key]) shape[key] = this.shape[key];
		return new ZodObject({
			...this._def,
			shape: () => shape
		});
	}
	/**
	* @deprecated
	*/
	deepPartial() {
		return deepPartialify(this);
	}
	partial(mask) {
		const newShape = {};
		for (const key of util.objectKeys(this.shape)) {
			const fieldSchema = this.shape[key];
			if (mask && !mask[key]) newShape[key] = fieldSchema;
			else newShape[key] = fieldSchema.optional();
		}
		return new ZodObject({
			...this._def,
			shape: () => newShape
		});
	}
	required(mask) {
		const newShape = {};
		for (const key of util.objectKeys(this.shape)) if (mask && !mask[key]) newShape[key] = this.shape[key];
		else {
			let newField = this.shape[key];
			while (newField instanceof ZodOptional) newField = newField._def.innerType;
			newShape[key] = newField;
		}
		return new ZodObject({
			...this._def,
			shape: () => newShape
		});
	}
	keyof() {
		return createZodEnum(util.objectKeys(this.shape));
	}
};
ZodObject.create = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
ZodObject.strictCreate = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strict",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
ZodObject.lazycreate = (shape, params) => {
	return new ZodObject({
		shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
var ZodUnion = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const options = this._def.options;
		function handleResults(results) {
			for (const result of results) if (result.result.status === "valid") return result.result;
			for (const result of results) if (result.result.status === "dirty") {
				ctx.common.issues.push(...result.ctx.common.issues);
				return result.result;
			}
			const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors
			});
			return INVALID;
		}
		if (ctx.common.async) return Promise.all(options.map(async (option) => {
			const childCtx = {
				...ctx,
				common: {
					...ctx.common,
					issues: []
				},
				parent: null
			};
			return {
				result: await option._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: childCtx
				}),
				ctx: childCtx
			};
		})).then(handleResults);
		else {
			let dirty = void 0;
			const issues = [];
			for (const option of options) {
				const childCtx = {
					...ctx,
					common: {
						...ctx.common,
						issues: []
					},
					parent: null
				};
				const result = option._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: childCtx
				});
				if (result.status === "valid") return result;
				else if (result.status === "dirty" && !dirty) dirty = {
					result,
					ctx: childCtx
				};
				if (childCtx.common.issues.length) issues.push(childCtx.common.issues);
			}
			if (dirty) {
				ctx.common.issues.push(...dirty.ctx.common.issues);
				return dirty.result;
			}
			const unionErrors = issues.map((issues$1) => new ZodError(issues$1));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors
			});
			return INVALID;
		}
	}
	get options() {
		return this._def.options;
	}
};
ZodUnion.create = (types$3, params) => {
	return new ZodUnion({
		options: types$3,
		typeName: ZodFirstPartyTypeKind.ZodUnion,
		...processCreateParams(params)
	});
};
const getDiscriminator = (type) => {
	if (type instanceof ZodLazy) return getDiscriminator(type.schema);
	else if (type instanceof ZodEffects) return getDiscriminator(type.innerType());
	else if (type instanceof ZodLiteral) return [type.value];
	else if (type instanceof ZodEnum) return type.options;
	else if (type instanceof ZodNativeEnum) return util.objectValues(type.enum);
	else if (type instanceof ZodDefault) return getDiscriminator(type._def.innerType);
	else if (type instanceof ZodUndefined) return [void 0];
	else if (type instanceof ZodNull) return [null];
	else if (type instanceof ZodOptional) return [void 0, ...getDiscriminator(type.unwrap())];
	else if (type instanceof ZodNullable) return [null, ...getDiscriminator(type.unwrap())];
	else if (type instanceof ZodBranded) return getDiscriminator(type.unwrap());
	else if (type instanceof ZodReadonly) return getDiscriminator(type.unwrap());
	else if (type instanceof ZodCatch) return getDiscriminator(type._def.innerType);
	else return [];
};
var ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const discriminator = this.discriminator;
		const discriminatorValue = ctx.data[discriminator];
		const option = this.optionsMap.get(discriminatorValue);
		if (!option) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union_discriminator,
				options: Array.from(this.optionsMap.keys()),
				path: [discriminator]
			});
			return INVALID;
		}
		if (ctx.common.async) return option._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
		else return option._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
	}
	get discriminator() {
		return this._def.discriminator;
	}
	get options() {
		return this._def.options;
	}
	get optionsMap() {
		return this._def.optionsMap;
	}
	/**
	* The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
	* However, it only allows a union of objects, all of which need to share a discriminator property. This property must
	* have a different value for each object in the union.
	* @param discriminator the name of the discriminator property
	* @param types an array of object schemas
	* @param params
	*/
	static create(discriminator, options, params) {
		const optionsMap = /* @__PURE__ */ new Map();
		for (const type of options) {
			const discriminatorValues = getDiscriminator(type.shape[discriminator]);
			if (!discriminatorValues.length) throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
			for (const value of discriminatorValues) {
				if (optionsMap.has(value)) throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
				optionsMap.set(value, type);
			}
		}
		return new ZodDiscriminatedUnion({
			typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
			discriminator,
			options,
			optionsMap,
			...processCreateParams(params)
		});
	}
};
function mergeValues(a, b) {
	const aType = getParsedType(a);
	const bType = getParsedType(b);
	if (a === b) return {
		valid: true,
		data: a
	};
	else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
		const bKeys = util.objectKeys(b);
		const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
		const newObj = {
			...a,
			...b
		};
		for (const key of sharedKeys) {
			const sharedValue = mergeValues(a[key], b[key]);
			if (!sharedValue.valid) return { valid: false };
			newObj[key] = sharedValue.data;
		}
		return {
			valid: true,
			data: newObj
		};
	} else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
		if (a.length !== b.length) return { valid: false };
		const newArray = [];
		for (let index = 0; index < a.length; index++) {
			const itemA = a[index];
			const itemB = b[index];
			const sharedValue = mergeValues(itemA, itemB);
			if (!sharedValue.valid) return { valid: false };
			newArray.push(sharedValue.data);
		}
		return {
			valid: true,
			data: newArray
		};
	} else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) return {
		valid: true,
		data: a
	};
	else return { valid: false };
}
var ZodIntersection = class extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		const handleParsed = (parsedLeft, parsedRight) => {
			if (isAborted(parsedLeft) || isAborted(parsedRight)) return INVALID;
			const merged = mergeValues(parsedLeft.value, parsedRight.value);
			if (!merged.valid) {
				addIssueToContext(ctx, { code: ZodIssueCode.invalid_intersection_types });
				return INVALID;
			}
			if (isDirty(parsedLeft) || isDirty(parsedRight)) status.dirty();
			return {
				status: status.value,
				value: merged.data
			};
		};
		if (ctx.common.async) return Promise.all([this._def.left._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}), this._def.right._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		})]).then(([left, right]) => handleParsed(left, right));
		else return handleParsed(this._def.left._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}), this._def.right._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}));
	}
};
ZodIntersection.create = (left, right, params) => {
	return new ZodIntersection({
		left,
		right,
		typeName: ZodFirstPartyTypeKind.ZodIntersection,
		...processCreateParams(params)
	});
};
var ZodTuple = class ZodTuple extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType
			});
			return INVALID;
		}
		if (ctx.data.length < this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_small,
				minimum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array"
			});
			return INVALID;
		}
		if (!this._def.rest && ctx.data.length > this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_big,
				maximum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array"
			});
			status.dirty();
		}
		const items = [...ctx.data].map((item, itemIndex) => {
			const schema = this._def.items[itemIndex] || this._def.rest;
			if (!schema) return null;
			return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
		}).filter((x) => !!x);
		if (ctx.common.async) return Promise.all(items).then((results) => {
			return ParseStatus.mergeArray(status, results);
		});
		else return ParseStatus.mergeArray(status, items);
	}
	get items() {
		return this._def.items;
	}
	rest(rest) {
		return new ZodTuple({
			...this._def,
			rest
		});
	}
};
ZodTuple.create = (schemas, params) => {
	if (!Array.isArray(schemas)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
	return new ZodTuple({
		items: schemas,
		typeName: ZodFirstPartyTypeKind.ZodTuple,
		rest: null,
		...processCreateParams(params)
	});
};
var ZodRecord = class ZodRecord extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const pairs = [];
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		for (const key in ctx.data) pairs.push({
			key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
			value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
			alwaysSet: key in ctx.data
		});
		if (ctx.common.async) return ParseStatus.mergeObjectAsync(status, pairs);
		else return ParseStatus.mergeObjectSync(status, pairs);
	}
	get element() {
		return this._def.valueType;
	}
	static create(first, second, third) {
		if (second instanceof ZodType) return new ZodRecord({
			keyType: first,
			valueType: second,
			typeName: ZodFirstPartyTypeKind.ZodRecord,
			...processCreateParams(third)
		});
		return new ZodRecord({
			keyType: ZodString.create(),
			valueType: first,
			typeName: ZodFirstPartyTypeKind.ZodRecord,
			...processCreateParams(second)
		});
	}
};
var ZodMap = class extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.map) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.map,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		const pairs = [...ctx.data.entries()].map(([key, value], index) => {
			return {
				key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
				value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
			};
		});
		if (ctx.common.async) {
			const finalMap = /* @__PURE__ */ new Map();
			return Promise.resolve().then(async () => {
				for (const pair of pairs) {
					const key = await pair.key;
					const value = await pair.value;
					if (key.status === "aborted" || value.status === "aborted") return INVALID;
					if (key.status === "dirty" || value.status === "dirty") status.dirty();
					finalMap.set(key.value, value.value);
				}
				return {
					status: status.value,
					value: finalMap
				};
			});
		} else {
			const finalMap = /* @__PURE__ */ new Map();
			for (const pair of pairs) {
				const key = pair.key;
				const value = pair.value;
				if (key.status === "aborted" || value.status === "aborted") return INVALID;
				if (key.status === "dirty" || value.status === "dirty") status.dirty();
				finalMap.set(key.value, value.value);
			}
			return {
				status: status.value,
				value: finalMap
			};
		}
	}
};
ZodMap.create = (keyType, valueType, params) => {
	return new ZodMap({
		valueType,
		keyType,
		typeName: ZodFirstPartyTypeKind.ZodMap,
		...processCreateParams(params)
	});
};
var ZodSet = class ZodSet extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.set) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.set,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const def = this._def;
		if (def.minSize !== null) {
			if (ctx.data.size < def.minSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.minSize.message
				});
				status.dirty();
			}
		}
		if (def.maxSize !== null) {
			if (ctx.data.size > def.maxSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.maxSize.message
				});
				status.dirty();
			}
		}
		const valueType = this._def.valueType;
		function finalizeSet(elements$1) {
			const parsedSet = /* @__PURE__ */ new Set();
			for (const element of elements$1) {
				if (element.status === "aborted") return INVALID;
				if (element.status === "dirty") status.dirty();
				parsedSet.add(element.value);
			}
			return {
				status: status.value,
				value: parsedSet
			};
		}
		const elements = [...ctx.data.values()].map((item, i$1) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i$1)));
		if (ctx.common.async) return Promise.all(elements).then((elements$1) => finalizeSet(elements$1));
		else return finalizeSet(elements);
	}
	min(minSize, message) {
		return new ZodSet({
			...this._def,
			minSize: {
				value: minSize,
				message: errorUtil.toString(message)
			}
		});
	}
	max(maxSize, message) {
		return new ZodSet({
			...this._def,
			maxSize: {
				value: maxSize,
				message: errorUtil.toString(message)
			}
		});
	}
	size(size, message) {
		return this.min(size, message).max(size, message);
	}
	nonempty(message) {
		return this.min(1, message);
	}
};
ZodSet.create = (valueType, params) => {
	return new ZodSet({
		valueType,
		minSize: null,
		maxSize: null,
		typeName: ZodFirstPartyTypeKind.ZodSet,
		...processCreateParams(params)
	});
};
var ZodFunction = class ZodFunction extends ZodType {
	constructor() {
		super(...arguments);
		this.validate = this.implement;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.function) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.function,
				received: ctx.parsedType
			});
			return INVALID;
		}
		function makeArgsIssue(args, error) {
			return makeIssue({
				data: args,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					en_default
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_arguments,
					argumentsError: error
				}
			});
		}
		function makeReturnsIssue(returns, error) {
			return makeIssue({
				data: returns,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					en_default
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_return_type,
					returnTypeError: error
				}
			});
		}
		const params = { errorMap: ctx.common.contextualErrorMap };
		const fn = ctx.data;
		if (this._def.returns instanceof ZodPromise) {
			const me = this;
			return OK(async function(...args) {
				const error = new ZodError([]);
				const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
					error.addIssue(makeArgsIssue(args, e));
					throw error;
				});
				const result = await Reflect.apply(fn, this, parsedArgs);
				return await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
					error.addIssue(makeReturnsIssue(result, e));
					throw error;
				});
			});
		} else {
			const me = this;
			return OK(function(...args) {
				const parsedArgs = me._def.args.safeParse(args, params);
				if (!parsedArgs.success) throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
				const result = Reflect.apply(fn, this, parsedArgs.data);
				const parsedReturns = me._def.returns.safeParse(result, params);
				if (!parsedReturns.success) throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
				return parsedReturns.data;
			});
		}
	}
	parameters() {
		return this._def.args;
	}
	returnType() {
		return this._def.returns;
	}
	args(...items) {
		return new ZodFunction({
			...this._def,
			args: ZodTuple.create(items).rest(ZodUnknown.create())
		});
	}
	returns(returnType) {
		return new ZodFunction({
			...this._def,
			returns: returnType
		});
	}
	implement(func) {
		return this.parse(func);
	}
	strictImplement(func) {
		return this.parse(func);
	}
	static create(args, returns, params) {
		return new ZodFunction({
			args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
			returns: returns || ZodUnknown.create(),
			typeName: ZodFirstPartyTypeKind.ZodFunction,
			...processCreateParams(params)
		});
	}
};
var ZodLazy = class extends ZodType {
	get schema() {
		return this._def.getter();
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		return this._def.getter()._parse({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
	}
};
ZodLazy.create = (getter, params) => {
	return new ZodLazy({
		getter,
		typeName: ZodFirstPartyTypeKind.ZodLazy,
		...processCreateParams(params)
	});
};
var ZodLiteral = class extends ZodType {
	_parse(input) {
		if (input.data !== this._def.value) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_literal,
				expected: this._def.value
			});
			return INVALID;
		}
		return {
			status: "valid",
			value: input.data
		};
	}
	get value() {
		return this._def.value;
	}
};
ZodLiteral.create = (value, params) => {
	return new ZodLiteral({
		value,
		typeName: ZodFirstPartyTypeKind.ZodLiteral,
		...processCreateParams(params)
	});
};
function createZodEnum(values, params) {
	return new ZodEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodEnum,
		...processCreateParams(params)
	});
}
var ZodEnum = class ZodEnum extends ZodType {
	_parse(input) {
		if (typeof input.data !== "string") {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				expected: util.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type
			});
			return INVALID;
		}
		if (!this._cache) this._cache = new Set(this._def.values);
		if (!this._cache.has(input.data)) {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get options() {
		return this._def.values;
	}
	get enum() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	get Values() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	get Enum() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	extract(values, newDef = this._def) {
		return ZodEnum.create(values, {
			...this._def,
			...newDef
		});
	}
	exclude(values, newDef = this._def) {
		return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
			...this._def,
			...newDef
		});
	}
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
	_parse(input) {
		const nativeEnumValues = util.getValidEnumValues(this._def.values);
		const ctx = this._getOrReturnCtx(input);
		if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
			const expectedValues = util.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				expected: util.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type
			});
			return INVALID;
		}
		if (!this._cache) this._cache = new Set(util.getValidEnumValues(this._def.values));
		if (!this._cache.has(input.data)) {
			const expectedValues = util.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get enum() {
		return this._def.values;
	}
};
ZodNativeEnum.create = (values, params) => {
	return new ZodNativeEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
		...processCreateParams(params)
	});
};
var ZodPromise = class extends ZodType {
	unwrap() {
		return this._def.type;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.promise,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK((ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data)).then((data$1) => {
			return this._def.type.parseAsync(data$1, {
				path: ctx.path,
				errorMap: ctx.common.contextualErrorMap
			});
		}));
	}
};
ZodPromise.create = (schema, params) => {
	return new ZodPromise({
		type: schema,
		typeName: ZodFirstPartyTypeKind.ZodPromise,
		...processCreateParams(params)
	});
};
var ZodEffects = class extends ZodType {
	innerType() {
		return this._def.schema;
	}
	sourceType() {
		return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		const effect = this._def.effect || null;
		const checkCtx = {
			addIssue: (arg) => {
				addIssueToContext(ctx, arg);
				if (arg.fatal) status.abort();
				else status.dirty();
			},
			get path() {
				return ctx.path;
			}
		};
		checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
		if (effect.type === "preprocess") {
			const processed = effect.transform(ctx.data, checkCtx);
			if (ctx.common.async) return Promise.resolve(processed).then(async (processed$1) => {
				if (status.value === "aborted") return INVALID;
				const result = await this._def.schema._parseAsync({
					data: processed$1,
					path: ctx.path,
					parent: ctx
				});
				if (result.status === "aborted") return INVALID;
				if (result.status === "dirty") return DIRTY(result.value);
				if (status.value === "dirty") return DIRTY(result.value);
				return result;
			});
			else {
				if (status.value === "aborted") return INVALID;
				const result = this._def.schema._parseSync({
					data: processed,
					path: ctx.path,
					parent: ctx
				});
				if (result.status === "aborted") return INVALID;
				if (result.status === "dirty") return DIRTY(result.value);
				if (status.value === "dirty") return DIRTY(result.value);
				return result;
			}
		}
		if (effect.type === "refinement") {
			const executeRefinement = (acc) => {
				const result = effect.refinement(acc, checkCtx);
				if (ctx.common.async) return Promise.resolve(result);
				if (result instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
				return acc;
			};
			if (ctx.common.async === false) {
				const inner = this._def.schema._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				});
				if (inner.status === "aborted") return INVALID;
				if (inner.status === "dirty") status.dirty();
				executeRefinement(inner.value);
				return {
					status: status.value,
					value: inner.value
				};
			} else return this._def.schema._parseAsync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			}).then((inner) => {
				if (inner.status === "aborted") return INVALID;
				if (inner.status === "dirty") status.dirty();
				return executeRefinement(inner.value).then(() => {
					return {
						status: status.value,
						value: inner.value
					};
				});
			});
		}
		if (effect.type === "transform") if (ctx.common.async === false) {
			const base = this._def.schema._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			});
			if (!isValid(base)) return INVALID;
			const result = effect.transform(base.value, checkCtx);
			if (result instanceof Promise) throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
			return {
				status: status.value,
				value: result
			};
		} else return this._def.schema._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}).then((base) => {
			if (!isValid(base)) return INVALID;
			return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
				status: status.value,
				value: result
			}));
		});
		util.assertNever(effect);
	}
};
ZodEffects.create = (schema, effect, params) => {
	return new ZodEffects({
		schema,
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		effect,
		...processCreateParams(params)
	});
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
	return new ZodEffects({
		schema,
		effect: {
			type: "preprocess",
			transform: preprocess
		},
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		...processCreateParams(params)
	});
};
var ZodOptional = class extends ZodType {
	_parse(input) {
		if (this._getType(input) === ZodParsedType.undefined) return OK(void 0);
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodOptional.create = (type, params) => {
	return new ZodOptional({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodOptional,
		...processCreateParams(params)
	});
};
var ZodNullable = class extends ZodType {
	_parse(input) {
		if (this._getType(input) === ZodParsedType.null) return OK(null);
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodNullable.create = (type, params) => {
	return new ZodNullable({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodNullable,
		...processCreateParams(params)
	});
};
var ZodDefault = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		let data$1 = ctx.data;
		if (ctx.parsedType === ZodParsedType.undefined) data$1 = this._def.defaultValue();
		return this._def.innerType._parse({
			data: data$1,
			path: ctx.path,
			parent: ctx
		});
	}
	removeDefault() {
		return this._def.innerType;
	}
};
ZodDefault.create = (type, params) => {
	return new ZodDefault({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodDefault,
		defaultValue: typeof params.default === "function" ? params.default : () => params.default,
		...processCreateParams(params)
	});
};
var ZodCatch = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const newCtx = {
			...ctx,
			common: {
				...ctx.common,
				issues: []
			}
		};
		const result = this._def.innerType._parse({
			data: newCtx.data,
			path: newCtx.path,
			parent: { ...newCtx }
		});
		if (isAsync(result)) return result.then((result$1) => {
			return {
				status: "valid",
				value: result$1.status === "valid" ? result$1.value : this._def.catchValue({
					get error() {
						return new ZodError(newCtx.common.issues);
					},
					input: newCtx.data
				})
			};
		});
		else return {
			status: "valid",
			value: result.status === "valid" ? result.value : this._def.catchValue({
				get error() {
					return new ZodError(newCtx.common.issues);
				},
				input: newCtx.data
			})
		};
	}
	removeCatch() {
		return this._def.innerType;
	}
};
ZodCatch.create = (type, params) => {
	return new ZodCatch({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodCatch,
		catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
		...processCreateParams(params)
	});
};
var ZodNaN = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.nan) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.nan,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return {
			status: "valid",
			value: input.data
		};
	}
};
ZodNaN.create = (params) => {
	return new ZodNaN({
		typeName: ZodFirstPartyTypeKind.ZodNaN,
		...processCreateParams(params)
	});
};
var ZodBranded = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const data$1 = ctx.data;
		return this._def.type._parse({
			data: data$1,
			path: ctx.path,
			parent: ctx
		});
	}
	unwrap() {
		return this._def.type;
	}
};
var ZodPipeline = class ZodPipeline extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.common.async) {
			const handleAsync = async () => {
				const inResult = await this._def.in._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				});
				if (inResult.status === "aborted") return INVALID;
				if (inResult.status === "dirty") {
					status.dirty();
					return DIRTY(inResult.value);
				} else return this._def.out._parseAsync({
					data: inResult.value,
					path: ctx.path,
					parent: ctx
				});
			};
			return handleAsync();
		} else {
			const inResult = this._def.in._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			});
			if (inResult.status === "aborted") return INVALID;
			if (inResult.status === "dirty") {
				status.dirty();
				return {
					status: "dirty",
					value: inResult.value
				};
			} else return this._def.out._parseSync({
				data: inResult.value,
				path: ctx.path,
				parent: ctx
			});
		}
	}
	static create(a, b) {
		return new ZodPipeline({
			in: a,
			out: b,
			typeName: ZodFirstPartyTypeKind.ZodPipeline
		});
	}
};
var ZodReadonly = class extends ZodType {
	_parse(input) {
		const result = this._def.innerType._parse(input);
		const freeze = (data$1) => {
			if (isValid(data$1)) data$1.value = Object.freeze(data$1.value);
			return data$1;
		};
		return isAsync(result) ? result.then((data$1) => freeze(data$1)) : freeze(result);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodReadonly.create = (type, params) => {
	return new ZodReadonly({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodReadonly,
		...processCreateParams(params)
	});
};
const late = { object: ZodObject.lazycreate };
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind$1) {
	ZodFirstPartyTypeKind$1["ZodString"] = "ZodString";
	ZodFirstPartyTypeKind$1["ZodNumber"] = "ZodNumber";
	ZodFirstPartyTypeKind$1["ZodNaN"] = "ZodNaN";
	ZodFirstPartyTypeKind$1["ZodBigInt"] = "ZodBigInt";
	ZodFirstPartyTypeKind$1["ZodBoolean"] = "ZodBoolean";
	ZodFirstPartyTypeKind$1["ZodDate"] = "ZodDate";
	ZodFirstPartyTypeKind$1["ZodSymbol"] = "ZodSymbol";
	ZodFirstPartyTypeKind$1["ZodUndefined"] = "ZodUndefined";
	ZodFirstPartyTypeKind$1["ZodNull"] = "ZodNull";
	ZodFirstPartyTypeKind$1["ZodAny"] = "ZodAny";
	ZodFirstPartyTypeKind$1["ZodUnknown"] = "ZodUnknown";
	ZodFirstPartyTypeKind$1["ZodNever"] = "ZodNever";
	ZodFirstPartyTypeKind$1["ZodVoid"] = "ZodVoid";
	ZodFirstPartyTypeKind$1["ZodArray"] = "ZodArray";
	ZodFirstPartyTypeKind$1["ZodObject"] = "ZodObject";
	ZodFirstPartyTypeKind$1["ZodUnion"] = "ZodUnion";
	ZodFirstPartyTypeKind$1["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
	ZodFirstPartyTypeKind$1["ZodIntersection"] = "ZodIntersection";
	ZodFirstPartyTypeKind$1["ZodTuple"] = "ZodTuple";
	ZodFirstPartyTypeKind$1["ZodRecord"] = "ZodRecord";
	ZodFirstPartyTypeKind$1["ZodMap"] = "ZodMap";
	ZodFirstPartyTypeKind$1["ZodSet"] = "ZodSet";
	ZodFirstPartyTypeKind$1["ZodFunction"] = "ZodFunction";
	ZodFirstPartyTypeKind$1["ZodLazy"] = "ZodLazy";
	ZodFirstPartyTypeKind$1["ZodLiteral"] = "ZodLiteral";
	ZodFirstPartyTypeKind$1["ZodEnum"] = "ZodEnum";
	ZodFirstPartyTypeKind$1["ZodEffects"] = "ZodEffects";
	ZodFirstPartyTypeKind$1["ZodNativeEnum"] = "ZodNativeEnum";
	ZodFirstPartyTypeKind$1["ZodOptional"] = "ZodOptional";
	ZodFirstPartyTypeKind$1["ZodNullable"] = "ZodNullable";
	ZodFirstPartyTypeKind$1["ZodDefault"] = "ZodDefault";
	ZodFirstPartyTypeKind$1["ZodCatch"] = "ZodCatch";
	ZodFirstPartyTypeKind$1["ZodPromise"] = "ZodPromise";
	ZodFirstPartyTypeKind$1["ZodBranded"] = "ZodBranded";
	ZodFirstPartyTypeKind$1["ZodPipeline"] = "ZodPipeline";
	ZodFirstPartyTypeKind$1["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;

//#endregion
//#region ../workers-shared/utils/types.ts
const InternalConfigSchema = objectType({
	account_id: numberType().optional(),
	script_id: numberType().optional(),
	debug: booleanType().optional()
});
const StaticRoutingSchema = objectType({
	user_worker: arrayType(stringType()),
	asset_worker: arrayType(stringType()).optional()
});
const RouterConfigSchema = objectType({
	invoke_user_worker_ahead_of_assets: booleanType().optional(),
	static_routing: StaticRoutingSchema.optional(),
	has_user_worker: booleanType().optional(),
	...InternalConfigSchema.shape
});
const EyeballRouterConfigSchema = unionType([objectType({ limitedAssetsOnly: booleanType().optional() }), nullType()]);
const MetadataStaticRedirectEntry = objectType({
	status: numberType(),
	to: stringType(),
	lineNumber: numberType()
});
const MetadataRedirectEntry = objectType({
	status: numberType(),
	to: stringType()
});
const MetadataStaticRedirects = recordType(MetadataStaticRedirectEntry);
const MetadataRedirects = recordType(MetadataRedirectEntry);
const MetadataHeaderEntry = objectType({
	set: recordType(stringType()).optional(),
	unset: arrayType(stringType()).optional()
});
const MetadataHeaders = recordType(MetadataHeaderEntry);
const RedirectsSchema = objectType({
	version: literalType(1),
	staticRules: MetadataStaticRedirects,
	rules: MetadataRedirects
}).optional();
const HeadersSchema = objectType({
	version: literalType(2),
	rules: MetadataHeaders
}).optional();
const AssetConfigSchema = objectType({
	compatibility_date: stringType().optional(),
	compatibility_flags: arrayType(stringType()).optional(),
	html_handling: enumType([
		"auto-trailing-slash",
		"force-trailing-slash",
		"drop-trailing-slash",
		"none"
	]).optional(),
	not_found_handling: enumType([
		"single-page-application",
		"404-page",
		"none"
	]).optional(),
	redirects: RedirectsSchema,
	headers: HeadersSchema,
	has_static_routing: booleanType().optional(),
	...InternalConfigSchema.shape
});

//#endregion
//#region src/asset-config.ts
/**
* Returns true if the `changedFile` matches one of the _headers or _redirects files,
* and the experimental support for these files is turned on.
*/
function hasAssetsConfigChanged(resolvedPluginConfig, resolvedViteConfig, changedFilePath) {
	if (!resolvedPluginConfig.experimental?.headersAndRedirectsDevModeSupport) return false;
	return [getRedirectsConfigPath(resolvedViteConfig), getHeadersConfigPath(resolvedViteConfig)].includes(changedFilePath);
}
/**
* Computes the assets config that will be passed to Miniflare,
* taking into account whether experimental _headers and _redirects support is on.
*/
function getAssetsConfig(resolvedPluginConfig, entryWorkerConfig, resolvedConfig) {
	const assetsConfig = resolvedPluginConfig.type === "assets-only" ? resolvedPluginConfig.config.assets : entryWorkerConfig?.assets;
	const config = {
		...resolvedPluginConfig.type === "assets-only" ? {
			compatibility_date: resolvedPluginConfig.config.compatibility_date,
			compatibility_flags: resolvedPluginConfig.config.compatibility_flags
		} : {
			...entryWorkerConfig?.compatibility_date ? { compatibility_date: entryWorkerConfig.compatibility_date } : {},
			...entryWorkerConfig?.compatibility_flags ? { compatibility_flags: entryWorkerConfig.compatibility_flags } : {}
		},
		...assetsConfig,
		has_static_routing: resolvedPluginConfig.type === "workers" && resolvedPluginConfig.staticRouting ? true : false
	};
	if (!resolvedPluginConfig.experimental?.headersAndRedirectsDevModeSupport) return config;
	const logger = {
		debug() {},
		log(message) {
			resolvedConfig.logger.info(message);
		},
		info(message) {
			resolvedConfig.logger.info(message);
		},
		warn(message) {
			resolvedConfig.logger.warn(message);
		},
		error(error) {
			resolvedConfig.logger.error(error.message, { error });
		}
	};
	const redirectsFile = getRedirectsConfigPath(resolvedConfig);
	const redirectsContents = maybeGetFile(redirectsFile);
	const redirects = redirectsContents && RedirectsSchema.parse(constructRedirects({
		redirects: parseRedirects(redirectsContents),
		redirectsFile,
		logger
	}).redirects);
	const headersFile = getHeadersConfigPath(resolvedConfig);
	const headersContents = maybeGetFile(headersFile);
	const headers = headersContents && HeadersSchema.parse(constructHeaders({
		headers: parseHeaders(headersContents),
		headersFile,
		logger
	}).headers);
	return {
		...config,
		...redirects ? { redirects } : {},
		...headers ? { headers } : {}
	};
}
function getRedirectsConfigPath(config) {
	return nodePath.join(config.publicDir, REDIRECTS_FILENAME);
}
function getHeadersConfigPath(config) {
	return nodePath.join(config.publicDir, HEADERS_FILENAME);
}

//#endregion
//#region src/shared.ts
const UNKNOWN_HOST = "http://localhost";
const INIT_PATH = "/__vite_plugin_cloudflare_init__";
const GET_EXPORT_TYPES_PATH = "/__vite_plugin_cloudflare_get_export_types__";
const WORKER_ENTRY_PATH_HEADER = "__VITE_WORKER_ENTRY_PATH__";
const IS_ENTRY_WORKER_HEADER = "__VITE_IS_ENTRY_WORKER__";
const virtualPrefix = "virtual:cloudflare/";
const VIRTUAL_WORKER_ENTRY = `${virtualPrefix}worker-entry`;
const VIRTUAL_EXPORT_TYPES = `${virtualPrefix}export-types`;

//#endregion
//#region src/plugins/virtual-modules.ts
const VIRTUAL_USER_ENTRY = `${virtualPrefix}user-entry`;
const VIRTUAL_CLIENT_FALLBACK_ENTRY = `${virtualPrefix}client-fallback-entry`;
/**
* Plugin to provide virtual modules
*/
const virtualModulesPlugin = createPlugin("virtual-modules", (ctx) => {
	return {
		applyToEnvironment(environment) {
			return ctx.getWorkerConfig(environment.name) !== void 0;
		},
		async resolveId(source) {
			if (source === VIRTUAL_WORKER_ENTRY || source === VIRTUAL_EXPORT_TYPES) return `\0${source}`;
			if (source === VIRTUAL_USER_ENTRY) {
				const workerConfig = ctx.getWorkerConfig(this.environment.name);
				assert(workerConfig, "Expected `workerConfig` to be defined");
				const main = await this.resolve(workerConfig.main);
				if (!main) throw new Error(`Failed to resolve main entry file "${workerConfig.main}" for environment "${this.environment.name}"`);
				return main;
			}
		},
		load(id) {
			if (id === `\0${VIRTUAL_WORKER_ENTRY}`) {
				const nodeJsCompat = ctx.getNodeJsCompat(this.environment.name);
				return `
${nodeJsCompat ? nodeJsCompat.injectGlobalCode() : ""}
import { getExportTypes } from "${VIRTUAL_EXPORT_TYPES}";
import * as mod from "${VIRTUAL_USER_ENTRY}";
export * from "${VIRTUAL_USER_ENTRY}";
export default mod.default ?? {};
if (import.meta.hot) {
	import.meta.hot.accept((module) => {
		const exportTypes = getExportTypes(module);
		import.meta.hot.send("vite-plugin-cloudflare:worker-export-types", exportTypes);
	});
}
				`;
			}
			if (id === `\0${VIRTUAL_EXPORT_TYPES}`) return `
import {
	WorkerEntrypoint,
	DurableObject,
	WorkflowEntrypoint,
} from "cloudflare:workers";

const baseClasses = new Map([
	["WorkerEntrypoint", WorkerEntrypoint],
	["DurableObject", DurableObject],
	["WorkflowEntrypoint", WorkflowEntrypoint],
]);

export function getExportTypes(module) {
	const exportTypes = {};

	for (const [key, value] of Object.entries(module)) {
		if (key === "default") {
			continue;
		}

		let exportType;

		if (typeof value === "function") {
			for (const [type, baseClass] of baseClasses) {
				if (baseClass.prototype.isPrototypeOf(value.prototype)) {
					exportType = type;
					break;
				}
			}

			if (!exportType) {
				exportType = "DurableObject";
			}
		} else if (typeof value === "object" && value !== null) {
			exportType = "WorkerEntrypoint";
		}

		exportTypes[key] = exportType;
	}

	return exportTypes;
}
				`;
		}
	};
});
/**
* Plugin to provide a virtual fallback entry file for the `client` environment.
* This is used as the entry file for the client build when only the `public` directory is present.
*/
const virtualClientFallbackPlugin = createPlugin("virtual-client-fallback", () => {
	return {
		applyToEnvironment(environment) {
			return environment.name === "client";
		},
		resolveId(source) {
			if (source === VIRTUAL_CLIENT_FALLBACK_ENTRY) return `\0${VIRTUAL_CLIENT_FALLBACK_ENTRY}`;
		},
		load(id) {
			if (id === `\0${VIRTUAL_CLIENT_FALLBACK_ENTRY}`) return ``;
		}
	};
});

//#endregion
//#region src/build.ts
const CLIENT_FALLBACK_ENTRY_NAME = "__cloudflare_fallback_entry__";
function createBuildApp(resolvedPluginConfig) {
	return async (builder) => {
		const clientEnvironment = builder.environments.client;
		assert(clientEnvironment, `No "client" environment`);
		const defaultHtmlPath = nodePath.resolve(builder.config.root, "index.html");
		const hasClientEntry = clientEnvironment.config.build.rollupOptions.input || fs$1.existsSync(defaultHtmlPath);
		if (resolvedPluginConfig.type === "assets-only") {
			if (hasClientEntry) await builder.build(clientEnvironment);
			else if (getHasPublicAssets(builder.config)) await fallbackBuild(builder, clientEnvironment);
			return;
		}
		const workerEnvironments = [...resolvedPluginConfig.environmentNameToWorkerMap.keys()].map((environmentName) => {
			const environment = builder.environments[environmentName];
			assert(environment, `"${environmentName}" environment not found`);
			return environment;
		});
		await Promise.all(workerEnvironments.map((environment) => builder.build(environment)));
		const { entryWorkerEnvironmentName } = resolvedPluginConfig;
		const entryWorkerEnvironment = builder.environments[entryWorkerEnvironmentName];
		assert(entryWorkerEnvironment, `No "${entryWorkerEnvironmentName}" environment`);
		const entryWorkerBuildDirectory = nodePath.resolve(builder.config.root, entryWorkerEnvironment.config.build.outDir);
		const importedAssetPaths = getImportedAssetPaths(loadViteManifest(entryWorkerBuildDirectory));
		if (hasClientEntry) await builder.build(clientEnvironment);
		else if (importedAssetPaths.size || getHasPublicAssets(builder.config)) await fallbackBuild(builder, clientEnvironment);
		else {
			if (!satisfiesViteVersion("7.0.0")) removeAssetsField(entryWorkerBuildDirectory);
			return;
		}
		const clientBuildDirectory = nodePath.resolve(builder.config.root, clientEnvironment.config.build.outDir);
		const movedAssetPaths = [];
		for (const assetPath of importedAssetPaths) {
			const src$1 = nodePath.join(entryWorkerBuildDirectory, assetPath);
			const dest = nodePath.join(clientBuildDirectory, assetPath);
			if (!fs$1.existsSync(src$1)) continue;
			if (fs$1.existsSync(dest)) fs$1.unlinkSync(src$1);
			else {
				const destDir = nodePath.dirname(dest);
				fs$1.mkdirSync(destDir, { recursive: true });
				fs$1.renameSync(src$1, dest);
				movedAssetPaths.push(dest);
			}
		}
		if (movedAssetPaths.length) builder.config.logger.info([`${colors.green("")} ${movedAssetPaths.length} asset${movedAssetPaths.length > 1 ? "s" : ""} moved from "${entryWorkerEnvironmentName}" to "client" build output.`, ...movedAssetPaths.map((assetPath) => colors.dim(nodePath.relative(builder.config.root, assetPath)))].join("\n"));
	};
}
function getHasPublicAssets({ publicDir }) {
	let hasPublicAssets = false;
	if (publicDir) try {
		if (fs$1.readdirSync(publicDir).length) hasPublicAssets = true;
	} catch {}
	return hasPublicAssets;
}
async function fallbackBuild(builder, environment) {
	environment.config.build.rollupOptions = {
		input: VIRTUAL_CLIENT_FALLBACK_ENTRY,
		logLevel: "silent",
		output: { entryFileNames: CLIENT_FALLBACK_ENTRY_NAME }
	};
	await builder.build(environment);
	const fallbackEntryPath = nodePath.resolve(builder.config.root, environment.config.build.outDir, CLIENT_FALLBACK_ENTRY_NAME);
	fs$1.unlinkSync(fallbackEntryPath);
}
function loadViteManifest(directory) {
	const contents = fs$1.readFileSync(nodePath.resolve(directory, ".vite", "manifest.json"), "utf-8");
	return JSON.parse(contents);
}
function getImportedAssetPaths(viteManifest) {
	const assetPaths = Object.values(viteManifest).flatMap((chunk) => chunk.assets ?? []);
	return new Set(assetPaths);
}
/**
* Used to remove the `assets` field from the entry Worker config if there are no assets
*/
function removeAssetsField(entryWorkerBuildDirectory) {
	const entryWorkerConfigPath = nodePath.join(entryWorkerBuildDirectory, "wrangler.json");
	const workerConfig = JSON.parse(fs$1.readFileSync(entryWorkerConfigPath, "utf-8"));
	workerConfig.assets = void 0;
	fs$1.writeFileSync(entryWorkerConfigPath, JSON.stringify(workerConfig));
}

//#endregion
//#region src/cloudflare-environment.ts
const MAIN_ENTRY_NAME = "index";
const webSocketUndefinedError = "The WebSocket is undefined";
function createHotChannel(webSocketContainer) {
	const listenersMap = /* @__PURE__ */ new Map();
	const client = { send(payload) {
		const webSocket = webSocketContainer.webSocket;
		assert(webSocket, webSocketUndefinedError);
		webSocket.send(JSON.stringify(payload));
	} };
	function onMessage(event) {
		const payload = JSON.parse(event.data.toString());
		const listeners = listenersMap.get(payload.event) ?? /* @__PURE__ */ new Set();
		for (const listener of listeners) listener(payload.data, client);
	}
	return {
		send(payload) {
			const webSocket = webSocketContainer.webSocket;
			assert(webSocket, webSocketUndefinedError);
			webSocket.send(JSON.stringify(payload));
		},
		on(event, listener) {
			const listeners = listenersMap.get(event) ?? /* @__PURE__ */ new Set();
			listeners.add(listener);
			listenersMap.set(event, listeners);
		},
		off(event, listener) {
			listenersMap.get(event)?.delete(listener);
		},
		listen() {
			const webSocket = webSocketContainer.webSocket;
			assert(webSocket, webSocketUndefinedError);
			webSocket.addEventListener("message", onMessage);
		},
		close() {
			const webSocket = webSocketContainer.webSocket;
			assert(webSocket, webSocketUndefinedError);
			webSocket.removeEventListener("message", onMessage);
		}
	};
}
var CloudflareDevEnvironment = class extends vite.DevEnvironment {
	#webSocketContainer;
	constructor(name, config) {
		const webSocketContainer = {};
		super(name, config, {
			hot: true,
			transport: createHotChannel(webSocketContainer)
		});
		this.#webSocketContainer = webSocketContainer;
	}
	async initRunner(miniflare, workerConfig, isEntryWorker) {
		const response = await miniflare.dispatchFetch(new URL(INIT_PATH, UNKNOWN_HOST), { headers: {
			[CoreHeaders.ROUTE_OVERRIDE]: workerConfig.name,
			[WORKER_ENTRY_PATH_HEADER]: encodeURIComponent(workerConfig.main),
			[IS_ENTRY_WORKER_HEADER]: String(isEntryWorker),
			upgrade: "websocket"
		} });
		assert(response.ok, `Failed to initialize module runner, error: ${await response.text()}`);
		const webSocket = response.webSocket;
		assert(webSocket, "Failed to establish WebSocket");
		webSocket.accept();
		this.#webSocketContainer.webSocket = webSocket;
	}
	async fetchWorkerExportTypes(miniflare, workerConfig) {
		await this.depsOptimizer?.init();
		return await (await miniflare.dispatchFetch(new URL(GET_EXPORT_TYPES_PATH, UNKNOWN_HOST), { headers: { [CoreHeaders.ROUTE_OVERRIDE]: workerConfig.name } })).json();
	}
	async fetchModule(id, importer, options) {
		if (additionalModuleRE.test(id)) return {
			externalize: id,
			type: "module"
		};
		return super.fetchModule(id, importer, options);
	}
};
const cloudflareBuiltInModules = [
	"cloudflare:email",
	"cloudflare:node",
	"cloudflare:sockets",
	"cloudflare:workers",
	"cloudflare:workflows"
];
const defaultConditions = [
	"workerd",
	"worker",
	"module",
	"browser"
];
const target = "es2024";
function createCloudflareEnvironmentOptions({ workerConfig, userConfig, mode, environmentName, isEntryWorker, hasNodeJsCompat: hasNodeJsCompat$1 }) {
	const isRolldown = "rolldownVersion" in vite;
	const define$1 = getProcessEnvReplacements(hasNodeJsCompat$1, mode);
	const rollupOptions = {
		input: { [MAIN_ENTRY_NAME]: VIRTUAL_WORKER_ENTRY },
		preserveEntrySignatures: "strict"
	};
	return {
		resolve: {
			noExternal: true,
			conditions: [...defaultConditions, "development|production"],
			builtins: [...cloudflareBuiltInModules]
		},
		define: define$1,
		dev: { createEnvironment(name, config) {
			return new CloudflareDevEnvironment(name, config);
		} },
		build: {
			createEnvironment(name, config) {
				return new vite.BuildEnvironment(name, config);
			},
			target,
			emitAssets: true,
			manifest: isEntryWorker,
			outDir: getOutputDirectory(userConfig, environmentName),
			copyPublicDir: false,
			ssr: true,
			...isRolldown ? { rolldownOptions: {
				...rollupOptions,
				platform: "neutral"
			} } : { rollupOptions }
		},
		optimizeDeps: {
			noDiscovery: false,
			ignoreOutdatedRequests: true,
			entries: vite.normalizePath(workerConfig.main),
			exclude: [...cloudflareBuiltInModules],
			...isRolldown ? { rolldownOptions: {
				platform: "neutral",
				resolve: {
					conditionNames: [...defaultConditions, "development"],
					extensions: [
						".mjs",
						".js",
						".mts",
						".ts",
						".jsx",
						".tsx",
						".json",
						".cjs",
						".cts",
						".ctx"
					]
				},
				transform: {
					target,
					define: define$1
				}
			} } : { esbuildOptions: {
				platform: "neutral",
				target,
				conditions: [...defaultConditions, "development"],
				resolveExtensions: [
					".mjs",
					".js",
					".mts",
					".ts",
					".jsx",
					".tsx",
					".json",
					".cjs",
					".cts",
					".ctx"
				],
				define: define$1
			} }
		},
		keepProcessEnv: true
	};
}
/**
* Gets `process.env` replacement values.
* `process.env.NODE_ENV` is always replaced.
* `process.env` is replaced with an empty object if `nodejs_compat` is not enabled
* @param hasNodeJsCompat - whether `nodejs_compat` is enabled
* @param mode - the Vite mode
* @returns replacement values
*/
function getProcessEnvReplacements(hasNodeJsCompat$1, mode) {
	const nodeEnv = process.env.NODE_ENV || mode;
	const nodeEnvReplacements = {
		"process.env.NODE_ENV": JSON.stringify(nodeEnv),
		"global.process.env.NODE_ENV": JSON.stringify(nodeEnv),
		"globalThis.process.env.NODE_ENV": JSON.stringify(nodeEnv)
	};
	return hasNodeJsCompat$1 ? nodeEnvReplacements : {
		...nodeEnvReplacements,
		"process.env": "{}",
		"global.process.env": "{}",
		"globalThis.process.env": "{}"
	};
}
function initRunners(resolvedPluginConfig, viteDevServer, miniflare) {
	return Promise.all([...resolvedPluginConfig.environmentNameToWorkerMap].map(([environmentName, worker]) => {
		debuglog("Initializing worker:", worker.config.name);
		const isEntryWorker = environmentName === resolvedPluginConfig.entryWorkerEnvironmentName;
		return viteDevServer.environments[environmentName].initRunner(miniflare, worker.config, isEntryWorker);
	}));
}

//#endregion
//#region src/dev-vars.ts
/**
* Gets any variables with which to augment the Worker config in preview mode.
*
* Calls `unstable_getVarsForDev` with the current Cloudflare environment to get local dev variables from the `.dev.vars` and `.env` files.
*/
function getLocalDevVarsForPreview(configPath, cloudflareEnv) {
	const dotDevDotVars = wrangler.unstable_getVarsForDev(configPath, void 0, {}, cloudflareEnv);
	const dotDevDotVarsEntries = Array.from(Object.entries(dotDevDotVars));
	if (dotDevDotVarsEntries.length > 0) return dotDevDotVarsEntries.map(([key, value]) => {
		return `${key} = "${value?.toString().replaceAll(`"`, `\\"`)}"\n`;
	}).join("");
}
/**
* Returns `true` if the `changedFile` matches a `.dev.vars` or `.env` file.
*/
function hasLocalDevVarsFileChanged({ configPaths, cloudflareEnv }, changedFilePath) {
	return [...configPaths].some((configPath) => {
		const configDir = nodePath.dirname(configPath);
		return [
			".dev.vars",
			".env",
			...cloudflareEnv ? [`.dev.vars.${cloudflareEnv}`, `.env.${cloudflareEnv}`] : []
		].some((localDevFile) => changedFilePath === nodePath.join(configDir, localDevFile));
	});
}

//#endregion
//#region src/vite-config.ts
/**
* Throws an error if Worker environments include configuration options that are incompatible with the plugin.
*/
function validateWorkerEnvironmentOptions(resolvedPluginConfig, resolvedViteConfig) {
	const disallowedEnvironmentOptionsMap = /* @__PURE__ */ new Map();
	for (const environmentName of resolvedPluginConfig.environmentNameToWorkerMap.keys()) {
		const environmentOptions = resolvedViteConfig.environments[environmentName];
		assert(environmentOptions, `Missing environment config for "${environmentName}"`);
		const { resolve: resolve$2 } = environmentOptions;
		const disallowedEnvironmentOptions = {};
		if (resolve$2.external === true || resolve$2.external.length) disallowedEnvironmentOptions.resolveExternal = resolve$2.external;
		if (Object.keys(disallowedEnvironmentOptions).length) disallowedEnvironmentOptionsMap.set(environmentName, disallowedEnvironmentOptions);
	}
	if (disallowedEnvironmentOptionsMap.size) {
		const errorMessage = `The following environment options are incompatible with the Cloudflare Vite plugin:\n${[...disallowedEnvironmentOptionsMap].map(([environmentName, disallowedEnvironmentOptions]) => disallowedEnvironmentOptions.resolveExternal && `	- "${environmentName}" environment: \`resolve.external\`: ${JSON.stringify(disallowedEnvironmentOptions.resolveExternal)}\n`).join("")}To resolve this issue, avoid setting \`resolve.external\` in your Cloudflare Worker environments.\n`;
		throw new Error(errorMessage);
	}
}

//#endregion
//#region src/plugins/config.ts
/**
* Plugin to handle configuration and config file watching
*/
const configPlugin = createPlugin("config", (ctx) => {
	return {
		config(userConfig, env) {
			if (ctx.resolvedPluginConfig.type === "preview") return { appType: "custom" };
			if (!ctx.hasShownWorkerConfigWarnings) {
				ctx.setHasShownWorkerConfigWarnings(true);
				const workerConfigWarnings = getWarningForWorkersConfigs(ctx.resolvedPluginConfig.rawConfigs);
				if (workerConfigWarnings) console.warn(workerConfigWarnings);
			}
			return {
				appType: "custom",
				server: { fs: { deny: [
					...[
						".env",
						".env.*",
						"*.{crt,pem}",
						"**/.git/**"
					],
					".dev.vars",
					".dev.vars.*"
				] } },
				environments: ctx.resolvedPluginConfig.type === "workers" ? {
					...Object.fromEntries([...ctx.resolvedPluginConfig.environmentNameToWorkerMap].map(([environmentName, worker]) => {
						return [environmentName, createCloudflareEnvironmentOptions({
							workerConfig: worker.config,
							userConfig,
							mode: env.mode,
							environmentName,
							isEntryWorker: ctx.resolvedPluginConfig.type === "workers" && environmentName === ctx.resolvedPluginConfig.entryWorkerEnvironmentName,
							hasNodeJsCompat: ctx.getNodeJsCompat(environmentName) !== void 0
						})];
					})),
					client: {
						build: { outDir: getOutputDirectory(userConfig, "client") },
						optimizeDeps: { exclude: [...cloudflareBuiltInModules] }
					}
				} : void 0,
				builder: { buildApp: userConfig.builder?.buildApp ?? createBuildApp(ctx.resolvedPluginConfig) }
			};
		},
		configResolved(resolvedViteConfig) {
			ctx.setResolvedViteConfig(resolvedViteConfig);
			if (ctx.resolvedPluginConfig.type === "workers") validateWorkerEnvironmentOptions(ctx.resolvedPluginConfig, ctx.resolvedViteConfig);
		},
		buildStart() {
			ctx.setHasShownWorkerConfigWarnings(false);
		},
		configureServer(viteDevServer) {
			const configChangedHandler = async (changedFilePath) => {
				assertIsNotPreview(ctx);
				if (ctx.resolvedPluginConfig.configPaths.has(changedFilePath) || hasLocalDevVarsFileChanged(ctx.resolvedPluginConfig, changedFilePath) || hasAssetsConfigChanged(ctx.resolvedPluginConfig, ctx.resolvedViteConfig, changedFilePath)) {
					debuglog("Config changed: " + changedFilePath);
					viteDevServer.watcher.off("change", configChangedHandler);
					debuglog("Restarting dev server and aborting previous setup");
					await viteDevServer.restart();
				}
			};
			viteDevServer.watcher.on("change", configChangedHandler);
		},
		buildApp: {
			order: "post",
			async handler(builder) {
				if (ctx.resolvedPluginConfig.type !== "workers") return;
				const workerEnvironments = [...ctx.resolvedPluginConfig.environmentNameToWorkerMap.keys()].map((environmentName) => {
					const environment = builder.environments[environmentName];
					assert(environment, `"${environmentName}" environment not found`);
					return environment;
				});
				await Promise.all(workerEnvironments.filter((environment) => !environment.isBuilt).map((environment) => builder.build(environment)));
				const { entryWorkerEnvironmentName } = ctx.resolvedPluginConfig;
				const entryWorkerEnvironment = builder.environments[entryWorkerEnvironmentName];
				assert(entryWorkerEnvironment, `No "${entryWorkerEnvironmentName}" environment`);
				const entryWorkerBuildDirectory = nodePath.resolve(builder.config.root, entryWorkerEnvironment.config.build.outDir);
				if (!builder.environments.client?.isBuilt) removeAssetsField(entryWorkerBuildDirectory);
			}
		}
	};
});

//#endregion
//#region src/debug.ts
const DEBUG_PATH = "/__debug";
const DEFAULT_INSPECTOR_PORT = 9229;
/**
* Gets the inspector port option that should be passed to Miniflare based on the user's plugin config
*/
async function getInputInspectorPort(ctx, viteServer) {
	if (ctx.resolvedPluginConfig.inspectorPort === void 0 || ctx.resolvedPluginConfig.inspectorPort === 0) {
		const resolvedInspectorPort = await ctx.getResolvedInspectorPort();
		if (resolvedInspectorPort !== null) return resolvedInspectorPort;
	}
	const inputInspectorPort = ctx.resolvedPluginConfig.inspectorPort ?? await getFirstAvailablePort(DEFAULT_INSPECTOR_PORT);
	if (ctx.resolvedPluginConfig.inspectorPort === void 0 && inputInspectorPort !== DEFAULT_INSPECTOR_PORT) viteServer.config.logger.warn(colors.dim(`Default inspector port ${DEFAULT_INSPECTOR_PORT} not available, using ${inputInspectorPort} instead\n`));
	return inputInspectorPort;
}
function getFirstAvailablePort(start) {
	return getPort({ port: portNumbers(start, 65535) });
}
/**
* Modifies the URL printing logic to also include a URL that developers can use to open DevTools to debug their Worker(s)
*/
function addDebugToVitePrintUrls(server) {
	const originalPrintUrls = server.printUrls;
	server.printUrls = () => {
		originalPrintUrls();
		const localUrl = server.resolvedUrls?.local[0];
		if (localUrl) {
			const { protocol, hostname, port } = new URL(localUrl);
			const colorDebugUrl = (url) => colors.dim(colors.yellow(url.replace(/:(\d+)\//, (_, portNumber) => `:${colors.bold(portNumber)}/`)));
			server.config.logger.info(`  ${colors.green("")}  ${colors.bold("Debug")}:   ${colorDebugUrl(`${protocol}//${hostname}:${port}${DEBUG_PATH}`)}`);
		}
	};
}
/**
* Generate HTML that comprises a single script that:
*  - redirects the page to the DevTools for debugging the first available Worker
*  - opens tabs to the DevTools for all the remaining workers if any
*
* Note: this works based on the Miniflare inspector proxy logic (where Workers are available via
* their names)
*/
function getDebugPathHtml(workerNames, inspectorPort) {
	assert(workerNames.length >= 1, "no workers present to debug");
	const workerDevtoolsUrls = workerNames.map((workerName) => {
		const localhost = `localhost:${inspectorPort}/${workerName}`;
		return `https://devtools.devprod.cloudflare.dev/js_app?${new URLSearchParams({
			theme: "systemPreferred",
			debugger: "true",
			ws: localhost,
			domain: workerName
		})}`;
	});
	return `
		<script>
			const workerUrls = ${JSON.stringify(workerDevtoolsUrls)};
			const [firstUrl, ...rest] = workerUrls;
			for (const workerUrl of rest) {
				// open new tabs for the devtools of the various workers
				window.open(workerUrl);
			}
			// redirect the current tab to the devtools of the first worker
			window.location.replace(firstUrl);
		<\/script>
    `;
}

//#endregion
//#region src/plugins/debug.ts
/**
* Plugin to provide a `/__debug` path for debugging Workers
*/
const debugPlugin = createPlugin("debug", (ctx) => {
	return {
		enforce: "pre",
		configureServer(viteDevServer) {
			assertIsNotPreview(ctx);
			if (!!process.env.VSCODE_INSPECTOR_OPTIONS) return;
			if (ctx.resolvedPluginConfig.type === "workers" && ctx.resolvedPluginConfig.inspectorPort !== false) addDebugToVitePrintUrls(viteDevServer);
			const workerNames = ctx.resolvedPluginConfig.type === "workers" ? [...ctx.resolvedPluginConfig.environmentNameToWorkerMap.values()].map((worker) => worker.config.name) : [];
			viteDevServer.middlewares.use(DEBUG_PATH, async (_, res, next) => {
				const resolvedInspectorPort = await ctx.getResolvedInspectorPort();
				if (resolvedInspectorPort) {
					const html = getDebugPathHtml(workerNames, resolvedInspectorPort);
					res.setHeader("Content-Type", "text/html");
					res.end(html);
				} else next();
			});
		},
		async configurePreviewServer(vitePreviewServer) {
			assertIsPreview(ctx);
			if (!!process.env.VSCODE_INSPECTOR_OPTIONS) return;
			if (ctx.resolvedPluginConfig.workers.length >= 1 && ctx.resolvedPluginConfig.inspectorPort !== false) addDebugToVitePrintUrls(vitePreviewServer);
			const workerNames = ctx.resolvedPluginConfig.workers.map((worker) => {
				assert(worker.name, "Expected the Worker to have a name");
				return worker.name;
			});
			vitePreviewServer.middlewares.use(DEBUG_PATH, async (_, res, next) => {
				const resolvedInspectorPort = await ctx.getResolvedInspectorPort();
				if (resolvedInspectorPort) {
					const html = getDebugPathHtml(workerNames, resolvedInspectorPort);
					res.setHeader("Content-Type", "text/html");
					res.end(html);
				} else next();
			});
		}
	};
});

//#endregion
//#region ../containers-shared/src/client/core/ApiError.ts
var ApiError = class extends Error {
	url;
	status;
	statusText;
	body;
	request;
	constructor(request$1, response, message) {
		super(message);
		this.name = "ApiError";
		this.url = response.url;
		this.status = response.status;
		this.statusText = response.statusText;
		this.body = response.body;
		this.request = request$1;
	}
};

//#endregion
//#region ../containers-shared/src/client/core/CancelablePromise.ts
/* istanbul ignore file */
var CancelError = class extends Error {
	constructor(message) {
		super(message);
		this.name = "CancelError";
	}
	get isCancelled() {
		return true;
	}
};
var CancelablePromise = class {
	#isResolved;
	#isRejected;
	#isCancelled;
	#cancelHandlers;
	#promise;
	#resolve;
	#reject;
	constructor(executor) {
		this.#isResolved = false;
		this.#isRejected = false;
		this.#isCancelled = false;
		this.#cancelHandlers = [];
		this.#promise = new Promise((resolve$2, reject) => {
			this.#resolve = resolve$2;
			this.#reject = reject;
			const onResolve = (value) => {
				if (this.#isResolved || this.#isRejected || this.#isCancelled) return;
				this.#isResolved = true;
				this.#resolve?.(value);
			};
			const onReject = (reason) => {
				if (this.#isResolved || this.#isRejected || this.#isCancelled) return;
				this.#isRejected = true;
				this.#reject?.(reason);
			};
			const onCancel = (cancelHandler) => {
				if (this.#isResolved || this.#isRejected || this.#isCancelled) return;
				this.#cancelHandlers.push(cancelHandler);
			};
			Object.defineProperty(onCancel, "isResolved", { get: () => this.#isResolved });
			Object.defineProperty(onCancel, "isRejected", { get: () => this.#isRejected });
			Object.defineProperty(onCancel, "isCancelled", { get: () => this.#isCancelled });
			return executor(onResolve, onReject, onCancel);
		});
	}
	get [Symbol.toStringTag]() {
		return "Cancellable Promise";
	}
	then(onFulfilled, onRejected) {
		return this.#promise.then(onFulfilled, onRejected);
	}
	catch(onRejected) {
		return this.#promise.catch(onRejected);
	}
	finally(onFinally) {
		return this.#promise.finally(onFinally);
	}
	cancel() {
		if (this.#isResolved || this.#isRejected || this.#isCancelled) return;
		this.#isCancelled = true;
		if (this.#cancelHandlers.length) try {
			for (const cancelHandler of this.#cancelHandlers) cancelHandler();
		} catch (error) {
			console.warn("Cancellation threw an error", error);
			return;
		}
		this.#cancelHandlers.length = 0;
		this.#reject?.(new CancelError("Request aborted"));
	}
	get isCancelled() {
		return this.#isCancelled;
	}
};

//#endregion
//#region ../containers-shared/src/client/core/OpenAPI.ts
const OpenAPI = {
	BASE: "",
	VERSION: "1.0.0",
	WITH_CREDENTIALS: false,
	CREDENTIALS: "include",
	TOKEN: void 0,
	USERNAME: void 0,
	PASSWORD: void 0,
	HEADERS: void 0,
	ENCODE_PATH: void 0,
	LOGGER: void 0
};

//#endregion
//#region ../containers-shared/src/client/models/ApplicationRollout.ts
let ApplicationRollout;
(function(_ApplicationRollout) {
	_ApplicationRollout.kind = /* @__PURE__ */ function(kind) {
		kind["FULL_AUTO"] = "full_auto";
		kind["FULL_MANUAL"] = "full_manual";
		kind["DURABLE_OBJECTS_AUTO"] = "durable_objects_auto";
		return kind;
	}({});
	_ApplicationRollout.strategy = /* @__PURE__ */ function(strategy) {
		strategy["ROLLING"] = "rolling";
		return strategy;
	}({});
	_ApplicationRollout.status = /* @__PURE__ */ function(status) {
		status["PENDING"] = "pending";
		status["PROGRESSING"] = "progressing";
		status["COMPLETED"] = "completed";
		status["REVERTED"] = "reverted";
		status["REPLACED"] = "replaced";
		return status;
	}({});
})(ApplicationRollout || (ApplicationRollout = {}));

//#endregion
//#region ../containers-shared/src/client/models/BadRequestWithCodeError.ts
let BadRequestWithCodeError;
(function(_BadRequestWithCodeError) {
	_BadRequestWithCodeError.error = /* @__PURE__ */ function(error) {
		error["VALIDATE_INPUT"] = "VALIDATE_INPUT";
		return error;
	}({});
})(BadRequestWithCodeError || (BadRequestWithCodeError = {}));

//#endregion
//#region ../containers-shared/src/client/models/CreateApplicationRolloutRequest.ts
let CreateApplicationRolloutRequest;
(function(_CreateApplicationRolloutRequest) {
	_CreateApplicationRolloutRequest.strategy = /* @__PURE__ */ function(strategy) {
		strategy["ROLLING"] = "rolling";
		return strategy;
	}({});
	_CreateApplicationRolloutRequest.step_percentage = /* @__PURE__ */ function(step_percentage) {
		step_percentage[step_percentage["_5"] = 5] = "_5";
		step_percentage[step_percentage["_10"] = 10] = "_10";
		step_percentage[step_percentage["_20"] = 20] = "_20";
		step_percentage[step_percentage["_25"] = 25] = "_25";
		step_percentage[step_percentage["_50"] = 50] = "_50";
		step_percentage[step_percentage["_100"] = 100] = "_100";
		return step_percentage;
	}({});
	_CreateApplicationRolloutRequest.kind = /* @__PURE__ */ function(kind) {
		kind["FULL_AUTO"] = "full_auto";
		kind["FULL_MANUAL"] = "full_manual";
		return kind;
	}({});
})(CreateApplicationRolloutRequest || (CreateApplicationRolloutRequest = {}));

//#endregion
//#region ../containers-shared/src/client/models/DeploymentNotFoundError.ts
let DeploymentNotFoundError;
(function(_DeploymentNotFoundError) {
	_DeploymentNotFoundError.error = /* @__PURE__ */ function(error) {
		error["DEPLOYMENT_NOT_FOUND"] = "DEPLOYMENT_NOT_FOUND";
		return error;
	}({});
})(DeploymentNotFoundError || (DeploymentNotFoundError = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryAlreadyExistsError.ts
let ImageRegistryAlreadyExistsError;
(function(_ImageRegistryAlreadyExistsError) {
	_ImageRegistryAlreadyExistsError.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_ALREADY_EXISTS"] = "IMAGE_REGISTRY_ALREADY_EXISTS";
		return error;
	}({});
})(ImageRegistryAlreadyExistsError || (ImageRegistryAlreadyExistsError = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryIsPublic.ts
let ImageRegistryIsPublic;
(function(_ImageRegistryIsPublic) {
	_ImageRegistryIsPublic.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_IS_PUBLIC"] = "IMAGE_REGISTRY_IS_PUBLIC";
		return error;
	}({});
})(ImageRegistryIsPublic || (ImageRegistryIsPublic = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryNotAllowedError.ts
let ImageRegistryNotAllowedError;
(function(_ImageRegistryNotAllowedError) {
	_ImageRegistryNotAllowedError.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_NOT_ALLOWED"] = "IMAGE_REGISTRY_NOT_ALLOWED";
		return error;
	}({});
})(ImageRegistryNotAllowedError || (ImageRegistryNotAllowedError = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryNotFoundError.ts
let ImageRegistryNotFoundError;
(function(_ImageRegistryNotFoundError) {
	_ImageRegistryNotFoundError.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_NOT_FOUND"] = "IMAGE_REGISTRY_NOT_FOUND";
		return error;
	}({});
})(ImageRegistryNotFoundError || (ImageRegistryNotFoundError = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryPermissions.ts
/* istanbul ignore file */
let ImageRegistryPermissions = /* @__PURE__ */ function(ImageRegistryPermissions$1) {
	ImageRegistryPermissions$1["PULL"] = "pull";
	ImageRegistryPermissions$1["PUSH"] = "push";
	return ImageRegistryPermissions$1;
}({});

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryProtocolAlreadyExists.ts
let ImageRegistryProtocolAlreadyExists;
(function(_ImageRegistryProtocolAlreadyExists) {
	_ImageRegistryProtocolAlreadyExists.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_PROTOCOL_ALREADY_EXISTS"] = "IMAGE_REGISTRY_PROTOCOL_ALREADY_EXISTS";
		return error;
	}({});
})(ImageRegistryProtocolAlreadyExists || (ImageRegistryProtocolAlreadyExists = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryProtocolIsReferencedError.ts
let ImageRegistryProtocolIsReferencedError;
(function(_ImageRegistryProtocolIsReferencedError) {
	_ImageRegistryProtocolIsReferencedError.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_PROTO_IS_REFERENCED"] = "IMAGE_REGISTRY_PROTO_IS_REFERENCED";
		return error;
	}({});
})(ImageRegistryProtocolIsReferencedError || (ImageRegistryProtocolIsReferencedError = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryProtocolNotFound.ts
let ImageRegistryProtocolNotFound;
(function(_ImageRegistryProtocolNotFound) {
	_ImageRegistryProtocolNotFound.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_PROTOCOL_NOT_FOUND"] = "IMAGE_REGISTRY_PROTOCOL_NOT_FOUND";
		return error;
	}({});
})(ImageRegistryProtocolNotFound || (ImageRegistryProtocolNotFound = {}));

//#endregion
//#region ../containers-shared/src/client/models/ProvisionerConfiguration.ts
let ProvisionerConfiguration;
(function(_ProvisionerConfiguration) {
	_ProvisionerConfiguration.type = /* @__PURE__ */ function(type) {
		type["NONE"] = "none";
		type["CLOUDINIT"] = "cloudinit";
		return type;
	}({});
})(ProvisionerConfiguration || (ProvisionerConfiguration = {}));

//#endregion
//#region ../containers-shared/src/client/models/RolloutStep.ts
let RolloutStep;
(function(_RolloutStep) {
	_RolloutStep.status = /* @__PURE__ */ function(status) {
		status["PENDING"] = "pending";
		status["PROGRESSING"] = "progressing";
		status["REVERTING"] = "reverting";
		status["COMPLETED"] = "completed";
		status["REVERTED"] = "reverted";
		return status;
	}({});
})(RolloutStep || (RolloutStep = {}));

//#endregion
//#region ../containers-shared/src/client/models/SecretNameAlreadyExists.ts
let SecretNameAlreadyExists;
(function(_SecretNameAlreadyExists) {
	_SecretNameAlreadyExists.error = /* @__PURE__ */ function(error) {
		error["SECRET_NAME_ALREADY_EXISTS"] = "SECRET_NAME_ALREADY_EXISTS";
		return error;
	}({});
})(SecretNameAlreadyExists || (SecretNameAlreadyExists = {}));

//#endregion
//#region ../containers-shared/src/client/models/SecretNotFound.ts
let SecretNotFound;
(function(_SecretNotFound) {
	_SecretNotFound.error = /* @__PURE__ */ function(error) {
		error["SECRET_NAME_NOT_FOUND"] = "SECRET_NAME_NOT_FOUND";
		return error;
	}({});
})(SecretNotFound || (SecretNotFound = {}));

//#endregion
//#region ../containers-shared/src/client/models/SSHPublicKeyNotFoundError.ts
let SSHPublicKeyNotFoundError;
(function(_SSHPublicKeyNotFoundError) {
	_SSHPublicKeyNotFoundError.error = /* @__PURE__ */ function(error) {
		error["SSH_PUBLIC_KEY_NOT_FOUND"] = "SSH_PUBLIC_KEY_NOT_FOUND";
		return error;
	}({});
})(SSHPublicKeyNotFoundError || (SSHPublicKeyNotFoundError = {}));

//#endregion
//#region ../containers-shared/src/client/models/UpdateApplicationRolloutRequest.ts
let UpdateApplicationRolloutRequest;
(function(_UpdateApplicationRolloutRequest) {
	_UpdateApplicationRolloutRequest.action = /* @__PURE__ */ function(action) {
		action["NEXT"] = "next";
		action["PREVIOUS"] = "previous";
		action["REVERT"] = "revert";
		return action;
	}({});
})(UpdateApplicationRolloutRequest || (UpdateApplicationRolloutRequest = {}));

//#endregion
//#region ../containers-shared/src/client/core/request.ts
/* istanbul ignore file */
const isDefined = (value) => {
	return value !== void 0 && value !== null;
};
const isString = (value) => {
	return typeof value === "string";
};
const isStringWithValue = (value) => {
	return isString(value) && value !== "";
};
const isBlob = (value) => {
	return typeof value === "object" && typeof value.type === "string" && typeof value.stream === "function" && typeof value.arrayBuffer === "function" && typeof value.constructor === "function" && typeof value.constructor.name === "string" && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);
};
const base64 = (str) => {
	try {
		return btoa(str);
	} catch (err) {
		return Buffer.from(str).toString("base64");
	}
};
const getQueryString = (params) => {
	const qs = [];
	const append = (key, value) => {
		qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
	};
	const process$1 = (key, value) => {
		if (isDefined(value)) if (Array.isArray(value)) value.forEach((v) => {
			process$1(key, v);
		});
		else if (typeof value === "object") Object.entries(value).forEach(([k, v]) => {
			process$1(`${key}[${k}]`, v);
		});
		else append(key, value);
	};
	Object.entries(params).forEach(([key, value]) => {
		process$1(key, value);
	});
	if (qs.length > 0) return `?${qs.join("&")}`;
	return "";
};
const getUrl = (config, options) => {
	const encoder = config.ENCODE_PATH || encodeURI;
	const path = options.url.replace("{api-version}", config.VERSION).replace(/{(.*?)}/g, (substring, group) => {
		if (options.path?.hasOwnProperty(group)) return encoder(String(options.path[group]));
		return substring;
	});
	const url = `${config.BASE}${path}`;
	if (options.query) return `${url}${getQueryString(options.query)}`;
	return url;
};
const getFormData = (options) => {
	if (options.formData) {
		const formData = new FormData();
		const process$1 = async (key, value) => {
			if (isString(value)) formData.append(key, value);
			else formData.append(key, JSON.stringify(value));
		};
		Object.entries(options.formData).filter(([_, value]) => isDefined(value)).forEach(([key, value]) => {
			if (Array.isArray(value)) value.forEach((v) => process$1(key, v));
			else process$1(key, value);
		});
		return formData;
	}
};
const resolve$1 = async (options, resolver) => {
	if (typeof resolver === "function") return resolver(options);
	return resolver;
};
const getHeaders = async (config, options) => {
	const token = await resolve$1(options, config.TOKEN);
	const username = await resolve$1(options, config.USERNAME);
	const password = await resolve$1(options, config.PASSWORD);
	const additionalHeaders = await resolve$1(options, config.HEADERS);
	const headers = Object.entries({
		Accept: "application/json",
		...additionalHeaders,
		...options.headers
	}).filter(([_, value]) => isDefined(value)).reduce((headers$1, [key, value]) => ({
		...headers$1,
		[key]: String(value)
	}), {});
	if (isStringWithValue(token)) headers["Authorization"] = `Bearer ${token}`;
	if (isStringWithValue(username) && isStringWithValue(password)) headers["Authorization"] = `Basic ${base64(`${username}:${password}`)}`;
	if (options.body) if (options.mediaType) headers["Content-Type"] = options.mediaType;
	else if (isBlob(options.body)) headers["Content-Type"] = options.body.type || "application/octet-stream";
	else if (isString(options.body)) headers["Content-Type"] = "text/plain";
	else headers["Content-Type"] = "application/json";
	return new Headers(headers);
};
const getRequestBody = (options) => {
	if (options.body !== void 0) if (options.mediaType?.includes("/json")) return JSON.stringify(options.body);
	else if (isString(options.body) || isBlob(options.body)) return options.body;
	else return JSON.stringify(options.body);
};
const isResponseSchemaV4 = (config, _options) => {
	return config.BASE.endsWith("/containers");
};
const parseResponseSchemaV4 = (url, response, responseHeader, responseBody) => {
	const fetchResult = typeof responseBody === "object" ? responseBody : JSON.parse(responseBody);
	const ok = response.ok && fetchResult.success;
	let result;
	if (ok) if (fetchResult.result !== void 0) result = fetchResult.result;
	else result = {};
	else result = { error: fetchResult.errors?.[0]?.message };
	return {
		url,
		ok,
		status: response.status,
		statusText: response.statusText,
		body: responseHeader ?? result
	};
};
const sendRequest = async (config, options, url, body, formData, headers, onCancel) => {
	const controller = new AbortController();
	const request$1 = {
		headers,
		body: body ?? formData,
		method: options.method,
		signal: controller.signal
	};
	if (config.WITH_CREDENTIALS) request$1.credentials = config.CREDENTIALS;
	onCancel(() => controller.abort());
	return await fetch(url, request$1);
};
const getResponseHeader = (response, responseHeader) => {
	if (responseHeader) {
		const content = response.headers.get(responseHeader);
		if (isString(content)) return content;
	}
};
const getResponseBody = async (response) => {
	if (response.status !== 204) try {
		const contentType = response.headers.get("Content-Type");
		if (contentType) if (["application/json", "application/problem+json"].some((type) => contentType.toLowerCase().startsWith(type))) return await response.json();
		else return await response.text();
	} catch (error) {
		console.error(error);
	}
};
const catchErrorCodes = (options, result) => {
	const error = {
		400: "Bad Request",
		401: "Unauthorized",
		403: "Forbidden",
		404: "Not Found",
		500: "Internal Server Error",
		502: "Bad Gateway",
		503: "Service Unavailable",
		...options.errors
	}[result.status];
	if (error) throw new ApiError(options, result, error);
	if (!result.ok) throw new ApiError(options, result, "Generic Error");
};
/**
* Request method
* @param config The OpenAPI configuration object
* @param options The request options from the service
* @returns CancelablePromise<T>
* @throws ApiError
*/
const request = (config, options) => {
	return new CancelablePromise(async (resolve$2, reject, onCancel) => {
		try {
			const url = getUrl(config, options);
			const formData = getFormData(options);
			const body = getRequestBody(options);
			const headers = await getHeaders(config, options);
			debugLogRequest(config, url, headers, formData ?? body ?? {});
			if (!onCancel.isCancelled) {
				const response = await sendRequest(config, options, url, body, formData, headers, onCancel);
				const responseBody = await getResponseBody(response);
				const responseHeader = getResponseHeader(response, options.responseHeader);
				let result;
				if (isResponseSchemaV4(config, options)) result = parseResponseSchemaV4(url, response, responseHeader, responseBody);
				else result = {
					url,
					ok: response.ok,
					status: response.status,
					statusText: response.statusText,
					body: responseHeader ?? responseBody
				};
				debugLogResponse(config, result);
				catchErrorCodes(options, result);
				resolve$2(result.body);
			}
		} catch (error) {
			reject(error);
		}
	});
};
const debugLogRequest = async (config, url, headers, body) => {
	config.LOGGER?.debug(`-- START CF API REQUEST: ${url}`);
	const logHeaders = new Headers(headers);
	logHeaders.delete("Authorization");
	config.LOGGER?.debugWithSanitization("HEADERS:", JSON.stringify(logHeaders, null, 2));
	config.LOGGER?.debugWithSanitization("BODY:", JSON.stringify(body instanceof FormData ? await new Response(body).text() : body, null, 2));
	config.LOGGER?.debug("-- END CF API REQUEST");
};
const debugLogResponse = (config, response) => {
	config.LOGGER?.debug("-- START CF API RESPONSE:", response.statusText, response.status);
	config.LOGGER?.debugWithSanitization("RESPONSE:", response.body);
	config.LOGGER?.debug("-- END CF API RESPONSE");
};

//#endregion
//#region ../containers-shared/src/client/services/ImageRegistriesService.ts
/* istanbul ignore file */
var ImageRegistriesService = class {
	/**
	* Create an image registry protocol that resolves to multiple domains.
	* @param requestBody
	* @returns ImageRegistryProtocol The image registry protocol was created
	* @throws ApiError
	*/
	static createImageRegistryProtocol(requestBody) {
		return request(OpenAPI, {
			method: "POST",
			url: "/registries/protos",
			body: requestBody,
			mediaType: "application/json",
			errors: {
				400: `Bad Request that contains a specific constant code and details object about the error.`,
				403: `The registry that is being added is not allowed`,
				409: `Image registry protocol already exists`,
				500: `There has been an internal error`
			}
		});
	}
	/**
	* List all image registry protocols.
	* @returns ImageRegistryProtocols The image registry protocols in the account
	* @throws ApiError
	*/
	static listImageRegistryProtocols() {
		return request(OpenAPI, {
			method: "GET",
			url: "/registries/protos",
			errors: { 500: `There has been an internal error` }
		});
	}
	/**
	* Modify an image registry protocol. The previous list of domains will be replaced by the ones you specify in this endpoint.
	* @param requestBody
	* @returns ImageRegistryProtocol The image registry protocol was modified
	* @throws ApiError
	*/
	static modifyImageRegistryProtocol(requestBody) {
		return request(OpenAPI, {
			method: "PUT",
			url: "/registries/protos",
			body: requestBody,
			mediaType: "application/json",
			errors: {
				400: `Bad Request that contains a specific constant code and details object about the error.`,
				403: `The registry that is being added is not allowed`,
				404: `Image registry protocol doesn't exist`,
				500: `There has been an internal error`
			}
		});
	}
	/**
	* Delete an image registry protocol. Be careful, if there is deployments running referencing this protocol they won't be able to pull the image.
	* @param proto
	* @returns EmptyResponse Image registry protocol was deleted successfully
	* @throws ApiError
	*/
	static deleteImageRegistryProto(proto) {
		return request(OpenAPI, {
			method: "DELETE",
			url: "/registries/protos/{proto}",
			path: { proto },
			errors: {
				400: `The image registry protocol couldn't be deleted because it's referenced by a deployment or application`,
				404: `Image registry protocol doesn't exist`,
				500: `There has been an internal error`
			}
		});
	}
	/**
	* Get a JWT to pull from the image registry
	* Get a JWT to pull from the image registry specifying its domain
	* @param domain
	* @param requestBody
	* @returns AccountRegistryToken Credentials with 'pull' or 'push' permissions to access the registry
	* @throws ApiError
	*/
	static generateImageRegistryCredentials(domain, requestBody) {
		return request(OpenAPI, {
			method: "POST",
			url: "/registries/{domain}/credentials",
			path: { domain },
			body: requestBody,
			mediaType: "application/json",
			errors: {
				400: `Bad Request that contains a specific constant code and details object about the error.`,
				404: `The image registry does not exist`,
				409: `The registry was configured as public, so credentials can not be generated`,
				500: `There has been an internal error`
			}
		});
	}
	/**
	* Delete a registry from the account
	* Delete a registry from the account, this will make Cloudchamber unable to pull images from the registry
	* @param domain
	* @returns EmptyResponse The image registry is deleted
	* @throws ApiError
	*/
	static deleteImageRegistry(domain) {
		return request(OpenAPI, {
			method: "DELETE",
			url: "/registries/{domain}",
			path: { domain },
			errors: {
				404: `The image registry does not exist`,
				500: `There has been an internal error`
			}
		});
	}
	/**
	* Get the list of configured registries in the account
	* Get the list of configured registries in the account
	* @returns CustomerImageRegistry The list of registries that are added in the account
	* @throws ApiError
	*/
	static listImageRegistries() {
		return request(OpenAPI, {
			method: "GET",
			url: "/registries",
			errors: { 500: `There has been an internal error` }
		});
	}
	/**
	* Add a new image registry configuration
	* Add a new image registry into your account, so then Cloudflare can pull docker images with public key JWT authentication
	* @param requestBody
	* @returns CustomerImageRegistry Created a new image registry in the account
	* @throws ApiError
	*/
	static createImageRegistry(requestBody) {
		return request(OpenAPI, {
			method: "POST",
			url: "/registries",
			body: requestBody,
			mediaType: "application/json",
			errors: {
				400: `Image registry input is malformed, see the error details`,
				403: `The registry that is being added is not allowed`,
				409: `The image registry already exists in the account`,
				500: `There has been an internal error`
			}
		});
	}
};

//#endregion
//#region ../containers-shared/src/error.ts
/**
* Base class for errors where the user has done something wrong. These are not
* reported to Sentry. API errors are intentionally *not* `UserError`s, and are
* reported to Sentry. This will help us understand which API errors need better
* messaging.
*/
var UserError = class extends Error {
	telemetryMessage;
	constructor(message, options) {
		super(message, options);
		Object.setPrototypeOf(this, new.target.prototype);
		this.telemetryMessage = options?.telemetryMessage === true ? message : options?.telemetryMessage;
	}
};

//#endregion
//#region ../containers-shared/src/build.ts
async function constructBuildCommand(options, logger) {
	const platform = options.platform ?? "linux/amd64";
	const buildCmd = [
		"build",
		"--load",
		"-t",
		options.tag,
		"--platform",
		platform,
		"--provenance=false"
	];
	if (options.args) for (const arg in options.args) buildCmd.push("--build-arg", `${arg}=${options.args[arg]}`);
	if (options.setNetworkToHost) buildCmd.push("--network", "host");
	const dockerfile = readFileSync(options.pathToDockerfile, "utf-8");
	buildCmd.push("-f", "-");
	buildCmd.push(options.buildContext);
	logger?.debug(`Building image with command: ${buildCmd.join(" ")}`);
	return {
		buildCmd,
		dockerfile
	};
}
function dockerBuild(dockerPath, options) {
	let errorHandled = false;
	let resolve$2;
	let reject;
	const ready = new Promise((res, rej) => {
		resolve$2 = res;
		reject = rej;
	});
	const child = spawn(dockerPath, options.buildCmd, {
		stdio: [
			"pipe",
			"inherit",
			"inherit"
		],
		detached: true
	});
	if (child.stdin !== null) {
		child.stdin.write(options.dockerfile);
		child.stdin.end();
	}
	child.on("exit", (code) => {
		if (code === 0) resolve$2();
		else if (!errorHandled) {
			errorHandled = true;
			reject(new UserError(`Docker build exited with code: ${code}`));
		}
	});
	child.on("error", (err) => {
		if (!errorHandled) {
			errorHandled = true;
			reject(err);
		}
	});
	return {
		abort: () => {
			child.unref();
			if (child.pid !== void 0) process.kill(-child.pid);
		},
		ready
	};
}
async function buildImage(dockerPath, options) {
	const { buildCmd, dockerfile } = await constructBuildCommand({
		tag: options.image_tag,
		pathToDockerfile: options.dockerfile,
		buildContext: options.image_build_context,
		args: options.image_vars,
		platform: "linux/amd64"
	});
	return dockerBuild(dockerPath, {
		buildCmd,
		dockerfile
	});
}

//#endregion
//#region ../containers-shared/src/login.ts
/**
* Gets push and pull credentials for a configured image registry
* and runs `docker login`, so subsequent image pushes or pulls are
* authenticated
*/
async function dockerLoginImageRegistry(pathToDocker, domain) {
	const credentials = await ImageRegistriesService.generateImageRegistryCredentials(domain, {
		expiration_minutes: 15,
		permissions: [ImageRegistryPermissions.PUSH, ImageRegistryPermissions.PULL]
	});
	const child = spawn(pathToDocker, [
		"login",
		"--password-stdin",
		"--username",
		credentials.username,
		domain
	], { stdio: [
		"pipe",
		"inherit",
		"inherit"
	] }).on("error", (err) => {
		throw err;
	});
	child.stdin.write(credentials.password);
	child.stdin.end();
	await new Promise((resolve$2, reject) => {
		child.on("close", (code) => {
			if (code === 0) resolve$2();
			else reject(new UserError(`Login failed with code: ${code}`));
		});
	});
}

//#endregion
//#region ../containers-shared/src/registry.ts
const MF_DEV_CONTAINER_PREFIX = "cloudflare-dev";

//#endregion
//#region ../containers-shared/src/knobs.ts
const getCloudflareContainerRegistry = () => {
	return process.env.CLOUDFLARE_CONTAINER_REGISTRY ?? (process.env.WRANGLER_API_ENVIRONMENT === "staging" ? "staging.registry.cloudflare.com" : "registry.cloudflare.com");
};
/** Prefixes with the cloudflare-dev namespace. The name should be the container's DO classname, and the tag a build uuid. */
const getDevContainerImageName = (name, tag) => {
	return `${MF_DEV_CONTAINER_PREFIX}/${name.toLowerCase()}:${tag}`;
};

//#endregion
//#region ../containers-shared/src/inspect.ts
async function dockerImageInspect(dockerPath, options) {
	return new Promise((resolve$2, reject) => {
		const proc = spawn(dockerPath, [
			"image",
			"inspect",
			options.imageTag,
			"--format",
			options.formatString
		], { stdio: [
			"ignore",
			"pipe",
			"pipe"
		] });
		let stdout = "";
		let stderr = "";
		proc.stdout.on("data", (chunk) => stdout += chunk);
		proc.stderr.on("data", (chunk) => stderr += chunk);
		proc.on("close", (code) => {
			if (code !== 0) return reject(new UserError(`failed inspecting image locally: ${stderr.trim()}`));
			resolve$2(stdout.trim());
		});
		proc.on("error", (err) => reject(err));
	});
}

//#endregion
//#region ../containers-shared/src/utils.ts
/** helper for simple docker command call that don't require any io handling */
const runDockerCmd = (dockerPath, args, stdio) => {
	let aborted = false;
	let resolve$2;
	let reject;
	const ready = new Promise((res, rej) => {
		resolve$2 = res;
		reject = rej;
	});
	const child = spawn(dockerPath, args, {
		stdio: stdio ?? "inherit",
		detached: true
	});
	let errorHandled = false;
	child.on("close", (code) => {
		if (code === 0 || aborted) resolve$2({ aborted });
		else if (!errorHandled) {
			errorHandled = true;
			reject(new UserError(`Docker command exited with code: ${code}`));
		}
	});
	child.on("error", (err) => {
		if (!errorHandled) {
			errorHandled = true;
			reject(new UserError(`Docker command failed: ${err.message}`));
		}
	});
	return {
		abort: () => {
			aborted = true;
			child.unref();
			if (child.pid !== void 0) process.kill(-child.pid);
		},
		ready,
		then: async (onResolve, onReject) => ready.then(onResolve).catch(onReject)
	};
};
const runDockerCmdWithOutput = (dockerPath, args) => {
	try {
		return execFileSync(dockerPath, args, { encoding: "utf8" }).trim();
	} catch (error) {
		throw new UserError(`Failed running docker command: ${error.message}. Command: ${dockerPath} ${args.join(" ")}`);
	}
};
/** Checks whether docker is running on the system */
const isDockerRunning = async (dockerPath) => {
	try {
		await runDockerCmd(dockerPath, ["info"], [
			"inherit",
			"pipe",
			"pipe"
		]);
	} catch {
		return false;
	}
	return true;
};
/** throws when docker is not installed */
const verifyDockerInstalled = async (dockerPath, isDev = true) => {
	if (!await isDockerRunning(dockerPath)) throw new UserError(`The Docker CLI could not be launched. Please ensure that the Docker CLI is installed and the daemon is running.
Other container tooling that is compatible with the Docker CLI and engine may work, but is not yet guaranteed to do so. You can specify an executable with the environment variable WRANGLER_DOCKER_BIN and a socket with DOCKER_HOST.${isDev ? "\nTo suppress this error if you do not intend on triggering any container instances, set dev.enable_containers to false in your Wrangler config or passing in --enable-containers=false." : ""}`);
};
function isDir(inputPath) {
	return statSync(inputPath).isDirectory();
}
/** returns true if it is a dockerfile, false if it is a registry link, throws if neither */
const isDockerfile = (image, configPath) => {
	const baseDir = configPath ? path4.dirname(configPath) : process.cwd();
	const maybeDockerfile = path4.resolve(baseDir, image);
	if (existsSync(maybeDockerfile)) {
		if (isDir(maybeDockerfile)) throw new UserError(`${image} is a directory, you should specify a path to the Dockerfile`);
		return true;
	}
	const errorPrefix = `The image "${image}" does not appear to be a valid path to a Dockerfile, or a valid image registry path:\n`;
	try {
		new URL(`https://${image}`);
	} catch (e) {
		if (e instanceof Error) throw new UserError(errorPrefix + e.message);
		throw e;
	}
	const imageParts = image.split("/");
	if (!imageParts[imageParts.length - 1]?.includes(":")) throw new UserError(errorPrefix + `If this is an image registry path, it needs to include at least a tag ':' (e.g: docker.io/httpd:1)`);
	if (image.includes("://")) throw new UserError(errorPrefix + `Image reference should not include the protocol part (e.g: docker.io/httpd:1, not https://docker.io/httpd:1)`);
	return false;
};
/**
* Kills and removes any containers which come from the given image tag
*/
const cleanupContainers = (dockerPath, imageTags) => {
	try {
		const containerIds = getContainerIdsByImageTags(dockerPath, imageTags);
		if (containerIds.length === 0) return true;
		runDockerCmdWithOutput(dockerPath, [
			"rm",
			"--force",
			...containerIds
		]);
		return true;
	} catch {
		return false;
	}
};
/**
* See https://docs.docker.com/reference/cli/docker/container/ls/#ancestor
*
* @param dockerPath The path to the Docker executable
* @param imageTags A set of ancestor image tags
* @returns The ids of all containers that share the given image tags as ancestors.
*/
function getContainerIdsByImageTags(dockerPath, imageTags) {
	const ids = /* @__PURE__ */ new Set();
	for (const imageTag of imageTags) getContainerIdsFromImage(dockerPath, imageTag).forEach((id) => ids.add(id));
	return Array.from(ids);
}
const getContainerIdsFromImage = (dockerPath, ancestorImage) => {
	return runDockerCmdWithOutput(dockerPath, [
		"ps",
		"-a",
		"--filter",
		`ancestor=${ancestorImage}`,
		"--format",
		"{{.ID}}"
	]).split("\n").filter((line) => line.trim());
};
/**
* While all ports are exposed in prod, a limitation of local dev with docker is that
* users will have to manually expose ports in their Dockerfile.
* We want to fail early and clearly if a user tries to develop with a container
* that has no ports exposed and is definitely not accessible.
*
* (A user could still use `getTCPPort()` on a port that is not exposed, but we leave that error for runtime.)
*/
async function checkExposedPorts(dockerPath, options) {
	if (await dockerImageInspect(dockerPath, {
		imageTag: options.image_tag,
		formatString: "{{ len .Config.ExposedPorts }}"
	}) === "0") throw new UserError(`The container "${options.class_name}" does not expose any ports. In your Dockerfile, please expose any ports you intend to connect to.\nFor additional information please see: https://developers.cloudflare.com/containers/local-dev/#exposing-ports.
`);
}
/**
* Generates a random container build id
*/
function generateContainerBuildId() {
	return randomUUID().slice(0, 8);
}
/**
* Run `docker context ls` to get the socket from the currently active Docker context
* @returns The socket path or null if we are not able to determine it
*/
function getDockerSocketFromContext(dockerPath) {
	try {
		const currentContext = runDockerCmdWithOutput(dockerPath, [
			"context",
			"ls",
			"--format",
			"json"
		]).trim().split("\n").map((line) => JSON.parse(line)).find((context) => context.Current === true);
		if (currentContext && currentContext.DockerEndpoint) return currentContext.DockerEndpoint;
	} catch {}
	return null;
}
/**
* Resolve Docker host as follows:
* 1. Check WRANGLER_DOCKER_HOST environment variable
* 2. Check DOCKER_HOST environment variable
* 3. Try to get socket from active Docker context
* 4. Fall back to platform-specific defaults
*/
function resolveDockerHost(dockerPath) {
	if (process.env.WRANGLER_DOCKER_HOST) return process.env.WRANGLER_DOCKER_HOST;
	if (process.env.DOCKER_HOST) return process.env.DOCKER_HOST;
	const contextSocket = getDockerSocketFromContext(dockerPath);
	if (contextSocket) return contextSocket;
	return process.platform === "win32" ? "//./pipe/docker_engine" : "unix:///var/run/docker.sock";
}
/**
* Get all repository tags for a given image
*/
async function getImageRepoTags(dockerPath, imageTag) {
	try {
		return (await dockerImageInspect(dockerPath, {
			imageTag,
			formatString: "{{ range .RepoTags }}{{ . }}\n{{ end }}"
		})).split("\n").filter((tag) => tag.trim() !== "");
	} catch {
		return [];
	}
}
/**
* Checks if the given image has any duplicate tags from previous dev sessions,
* and remove them if so.
*/
async function cleanupDuplicateImageTags(dockerPath, imageTag) {
	try {
		const tagsToRemove = (await getImageRepoTags(dockerPath, imageTag)).filter((tag) => tag !== imageTag && tag.startsWith("cloudflare-dev"));
		if (tagsToRemove.length > 0) runDockerCmdWithOutput(dockerPath, ["rmi", ...tagsToRemove]);
	} catch {}
}

//#endregion
//#region ../containers-shared/src/client/models/ExternalRegistryKind.ts
/* istanbul ignore file */
/**
* The type of external registry that is being configured.
*/
let ExternalRegistryKind = /* @__PURE__ */ function(ExternalRegistryKind$1) {
	ExternalRegistryKind$1["ECR"] = "ECR";
	return ExternalRegistryKind$1;
}({});

//#endregion
//#region ../containers-shared/src/images.ts
async function pullImage(dockerPath, options, logger, isVite) {
	const domain = new URL(`http://${options.image_uri}`).hostname;
	const isExternalRegistry = domain !== getCloudflareContainerRegistry();
	try {
		await dockerLoginImageRegistry(dockerPath, domain);
	} catch (e) {
		if (!isExternalRegistry) {
			if (isVite) throw new UserError(`Using images from the Cloudflare-managed registry is not currently supported with the Vite plugin.
You should use a Dockerfile or a supported external registry and authenticate to that registry separately using \`docker login\` or similar.
Supported external registries are currently: ${Object.values(ExternalRegistryKind).join(", ")}.`);
			throw e;
		}
		logger?.warn("Unable to retrieve configured registry credentials from Cloudflare.\nUnless this is a public image, you will need to run `wrangler containers registries configure` before deploying.\nAttempting to pull image anyway...");
	}
	const pull = runDockerCmd(dockerPath, [
		"pull",
		options.image_uri,
		"--platform",
		"linux/amd64"
	]);
	return {
		abort: () => {
			pull.abort();
		},
		ready: pull.ready.then(async ({ aborted }) => {
			if (!aborted) await runDockerCmd(dockerPath, [
				"tag",
				options.image_uri,
				options.image_tag
			]);
		})
	};
}
/**
*
* Builds or pulls the container images for local development. This
* will be called before starting the local development server, and by a rebuild
* hotkey during development.
*
* Because this runs when local dev starts, we also do some validation here,
* such as checking if the Docker CLI is installed, and if the container images
* expose any ports.
*/
async function prepareContainerImagesForDev(args) {
	const { dockerPath, containerOptions, onContainerImagePreparationStart, onContainerImagePreparationEnd } = args;
	let aborted = false;
	if (process.platform === "win32") throw new UserError("Local development with containers is currently not supported on Windows. You should use WSL instead. You can also set `enable_containers` to false if you do not need to develop the container part of your application.");
	await verifyDockerInstalled(dockerPath);
	for (const options of containerOptions) {
		if ("dockerfile" in options) {
			const build = await buildImage(dockerPath, options);
			onContainerImagePreparationStart({
				containerOptions: options,
				abort: () => {
					aborted = true;
					build.abort();
				}
			});
			await build.ready;
			onContainerImagePreparationEnd({ containerOptions: options });
		} else {
			const pull = await pullImage(dockerPath, options, args.logger, args.isVite);
			onContainerImagePreparationStart({
				containerOptions: options,
				abort: () => {
					aborted = true;
					pull.abort();
				}
			});
			await pull.ready;
			onContainerImagePreparationEnd({ containerOptions: options });
		}
		if (!aborted) {
			await cleanupDuplicateImageTags(dockerPath, options.image_tag);
			await checkExposedPorts(dockerPath, options);
		}
	}
}

//#endregion
//#region ../workers-shared/asset-worker/src/utils/rules-engine.ts
const ESCAPE_REGEX_CHARACTERS = /[-/\\^$*+?.()|[\]{}]/g;
const escapeRegex = (str) => {
	return str.replace(ESCAPE_REGEX_CHARACTERS, "\\$&");
};
const generateGlobOnlyRuleRegExp = (rule) => {
	rule = rule.split("*").map(escapeRegex).join(".*");
	rule = "^" + rule + "$";
	return RegExp(rule);
};
const generateStaticRoutingRuleMatcher = (rules) => ({ request: request$1 }) => {
	const { pathname } = new URL(request$1.url);
	for (const rule of rules) try {
		if (generateGlobOnlyRuleRegExp(rule).test(pathname)) return true;
	} catch {}
	return false;
};

//#endregion
//#region src/constants.ts
const ROUTER_WORKER_NAME = "__router-worker__";
const ASSET_WORKER_NAME = "__asset-worker__";
const VITE_PROXY_WORKER_NAME = "__vite_proxy_worker__";
const kRequestType = Symbol("kRequestType");

//#endregion
//#region src/containers.ts
/**
* Returns the path to the Docker executable as defined by the
* `WRANGLER_DOCKER_BIN` environment variable, or the default value
* `"docker"`
*/
function getDockerPath() {
	return process.env["WRANGLER_DOCKER_BIN"] || "docker";
}
/**
* @returns Container options suitable for building or pulling images,
* with image tag set to well-known dev format, or undefined if
* containers are not enabled or not configured.
*/
function getContainerOptions(options) {
	const { containersConfig, containerBuildId, configPath } = options;
	if (!containersConfig?.length) return;
	return containersConfig.map((container) => {
		if (isDockerfile(container.image, configPath)) return {
			dockerfile: container.image,
			image_build_context: container.image_build_context ?? path4.dirname(container.image),
			image_vars: container.image_vars,
			class_name: container.class_name,
			image_tag: getDevContainerImageName(container.class_name, containerBuildId)
		};
		else return {
			image_uri: container.image,
			class_name: container.class_name,
			image_tag: getDevContainerImageName(container.class_name, containerBuildId)
		};
	});
}

//#endregion
//#region src/miniflare-options.ts
const INTERNAL_WORKERS_COMPATIBILITY_DATE = "2024-10-04";
const PUBLIC_DIR_PREFIX = "/__vite_public_dir__";
function getPersistenceRoot(root, persistState) {
	if (persistState === false) return;
	return nodePath.resolve(root, typeof persistState === "object" ? persistState.path : ".wrangler/state", "v3");
}
const miniflareModulesRoot = process.platform === "win32" ? "Z:\\" : "/";
const ROUTER_WORKER_PATH = "./workers/router-worker.js";
const ASSET_WORKER_PATH = "./workers/asset-worker.js";
const VITE_PROXY_WORKER_PATH = "./workers/vite-proxy-worker.js";
const RUNNER_PATH = "./workers/runner-worker.js";
const WRAPPER_PATH = "__VITE_WORKER_ENTRY__";
/** Map that maps worker configPaths to their existing remote proxy session data (if any) */
const remoteProxySessionsDataMap = /* @__PURE__ */ new Map();
async function getDevMiniflareOptions(ctx, viteDevServer) {
	const inputInspectorPort = await getInputInspectorPort(ctx, viteDevServer);
	const { resolvedPluginConfig, resolvedViteConfig, entryWorkerConfig } = ctx;
	const assetsConfig = getAssetsConfig(resolvedPluginConfig, entryWorkerConfig, resolvedViteConfig);
	const assetWorkers = [
		{
			name: ROUTER_WORKER_NAME,
			compatibilityDate: INTERNAL_WORKERS_COMPATIBILITY_DATE,
			modulesRoot: miniflareModulesRoot,
			modules: [{
				type: "ESModule",
				path: nodePath.join(miniflareModulesRoot, ROUTER_WORKER_PATH),
				contents: fs$1.readFileSync(fileURLToPath(new URL(ROUTER_WORKER_PATH, import.meta.url)))
			}],
			bindings: { CONFIG: { has_user_worker: resolvedPluginConfig.type === "workers" } },
			serviceBindings: {
				ASSET_WORKER: ASSET_WORKER_NAME,
				...entryWorkerConfig ? { USER_WORKER: entryWorkerConfig.name } : {}
			}
		},
		{
			name: ASSET_WORKER_NAME,
			compatibilityDate: INTERNAL_WORKERS_COMPATIBILITY_DATE,
			modulesRoot: miniflareModulesRoot,
			modules: [{
				type: "ESModule",
				path: nodePath.join(miniflareModulesRoot, ASSET_WORKER_PATH),
				contents: fs$1.readFileSync(fileURLToPath(new URL(ASSET_WORKER_PATH, import.meta.url)))
			}],
			bindings: {
				CONFIG: assetsConfig,
				__VITE_HEADERS__: JSON.stringify(viteDevServer.config.server.headers)
			},
			serviceBindings: {
				__VITE_HTML_EXISTS__: async (request$1) => {
					const { pathname } = new URL(request$1.url);
					if (pathname.endsWith(".html")) {
						const { root, publicDir } = resolvedViteConfig;
						const publicDirInRoot = publicDir.startsWith(withTrailingSlash(root));
						const publicPath = withTrailingSlash(publicDir.slice(root.length));
						if (publicDirInRoot && pathname.startsWith(publicPath)) return Response$1.json(null);
						const publicDirFilePath = nodePath.join(publicDir, pathname);
						const rootDirFilePath = nodePath.join(root, pathname);
						for (const resolvedPath of [publicDirFilePath, rootDirFilePath]) try {
							if ((await fsp.stat(resolvedPath)).isFile()) return Response$1.json(resolvedPath === publicDirFilePath ? `${PUBLIC_DIR_PREFIX}${pathname}` : pathname);
						} catch {}
					}
					return Response$1.json(null);
				},
				__VITE_FETCH_HTML__: async (request$1) => {
					const { pathname } = new URL(request$1.url);
					const { root, publicDir } = resolvedViteConfig;
					const isInPublicDir = pathname.startsWith(PUBLIC_DIR_PREFIX);
					const resolvedPath = isInPublicDir ? nodePath.join(publicDir, pathname.slice(20)) : nodePath.join(root, pathname);
					try {
						let html = await fsp.readFile(resolvedPath, "utf-8");
						if (!isInPublicDir) html = await viteDevServer.transformIndexHtml(resolvedPath, html);
						return new Response$1(html, { headers: { "Content-Type": "text/html" } });
					} catch {
						throw new Error(`Unexpected error. Failed to load "${pathname}".`);
					}
				}
			}
		},
		{
			name: VITE_PROXY_WORKER_NAME,
			compatibilityDate: INTERNAL_WORKERS_COMPATIBILITY_DATE,
			modulesRoot: miniflareModulesRoot,
			modules: [{
				type: "ESModule",
				path: nodePath.join(miniflareModulesRoot, VITE_PROXY_WORKER_PATH),
				contents: fs$1.readFileSync(fileURLToPath(new URL(VITE_PROXY_WORKER_PATH, import.meta.url)))
			}],
			serviceBindings: {
				...entryWorkerConfig ? { ENTRY_USER_WORKER: entryWorkerConfig.name } : {},
				__VITE_MIDDLEWARE__: { node: (req, res) => viteDevServer.middlewares(req, res) }
			}
		}
	];
	const containerTagToOptionsMap = /* @__PURE__ */ new Map();
	const workersFromConfig = resolvedPluginConfig.type === "workers" ? await Promise.all([...resolvedPluginConfig.environmentNameToWorkerMap].map(async ([environmentName, worker]) => {
		const bindings = wrangler.unstable_convertConfigBindingsToStartWorkerBindings(worker.config);
		const preExistingRemoteProxySession = worker.config.configPath ? remoteProxySessionsDataMap.get(worker.config.configPath) : void 0;
		const remoteProxySessionData = !resolvedPluginConfig.remoteBindings ? null : await wrangler.maybeStartOrUpdateRemoteProxySession({
			name: worker.config.name,
			bindings: bindings ?? {},
			account_id: worker.config.account_id
		}, preExistingRemoteProxySession ?? null);
		if (worker.config.configPath && remoteProxySessionData) remoteProxySessionsDataMap.set(worker.config.configPath, remoteProxySessionData);
		let containerBuildId;
		if (worker.config.containers?.length && worker.config.dev.enable_containers) {
			const dockerPath = getDockerPath();
			worker.config.dev.container_engine = resolveDockerHost(dockerPath);
			containerBuildId = generateContainerBuildId();
			const options = getContainerOptions({
				containersConfig: worker.config.containers,
				containerBuildId,
				configPath: worker.config.configPath
			});
			for (const option of options ?? []) containerTagToOptionsMap.set(option.image_tag, option);
		}
		const { externalWorkers: externalWorkers$1, workerOptions } = wrangler.unstable_getMiniflareWorkerOptions({
			...worker.config,
			assets: void 0
		}, resolvedPluginConfig.cloudflareEnv, {
			remoteProxyConnectionString: remoteProxySessionData?.session?.remoteProxyConnectionString,
			containerBuildId
		});
		const wrappers = [
			`import { createWorkerEntrypointWrapper, createDurableObjectWrapper, createWorkflowEntrypointWrapper } from "${RUNNER_PATH}";`,
			`export { __VITE_RUNNER_OBJECT__ } from "${RUNNER_PATH}";`,
			`export default createWorkerEntrypointWrapper("default");`
		];
		const exportTypes = ctx.workerNameToExportTypesMap.get(worker.config.name);
		assert(exportTypes, `Expected exportTypes to be defined`);
		for (const [name, type] of Object.entries(exportTypes)) wrappers.push(`export const ${name} = create${type}Wrapper("${name}");`);
		return {
			externalWorkers: externalWorkers$1,
			worker: {
				...workerOptions,
				name: worker.config.name,
				modulesRoot: miniflareModulesRoot,
				modules: [{
					type: "ESModule",
					path: nodePath.join(miniflareModulesRoot, WRAPPER_PATH),
					contents: wrappers.join("\n")
				}, {
					type: "ESModule",
					path: nodePath.join(miniflareModulesRoot, RUNNER_PATH),
					contents: fs$1.readFileSync(fileURLToPath(new URL(RUNNER_PATH, import.meta.url)))
				}],
				unsafeUseModuleFallbackService: true,
				unsafeInspectorProxy: inputInspectorPort !== false,
				unsafeDirectSockets: environmentName === resolvedPluginConfig.entryWorkerEnvironmentName ? [{
					serviceName: VITE_PROXY_WORKER_NAME,
					proxy: true
				}, ...Object.entries(exportTypes).filter(([_, type]) => type === "WorkerEntrypoint").map(([entrypoint]) => ({
					entrypoint,
					proxy: true
				}))] : [],
				unsafeEvalBinding: "__VITE_UNSAFE_EVAL__",
				serviceBindings: {
					...workerOptions.serviceBindings,
					...environmentName === resolvedPluginConfig.entryWorkerEnvironmentName && worker.config.assets?.binding ? { [worker.config.assets.binding]: { node: (req, res) => {
						req[kRequestType] = "asset";
						viteDevServer.middlewares(req, res);
					} } } : {},
					__VITE_INVOKE_MODULE__: async (request$1) => {
						const payload = await request$1.json();
						const result = await viteDevServer.environments[environmentName].hot.handleInvoke(payload);
						return Response$1.json(result);
					}
				},
				durableObjects: {
					...workerOptions.durableObjects,
					__VITE_RUNNER_OBJECT__: {
						className: "__VITE_RUNNER_OBJECT__",
						unsafeUniqueKey: kUnsafeEphemeralUniqueKey,
						unsafePreventEviction: true
					}
				}
			}
		};
	})) : [];
	const userWorkers = workersFromConfig.map((options) => options.worker);
	const externalWorkers = workersFromConfig.flatMap((options) => options.externalWorkers);
	const logger = new ViteMiniflareLogger(resolvedViteConfig);
	return {
		miniflareOptions: {
			log: logger,
			logRequests: false,
			inspectorPort: inputInspectorPort === false ? void 0 : inputInspectorPort,
			unsafeDevRegistryPath: getDefaultDevRegistryPath(),
			unsafeTriggerHandlers: true,
			handleStructuredLogs: getStructuredLogsLogger(logger),
			defaultPersistRoot: getPersistenceRoot(resolvedViteConfig.root, resolvedPluginConfig.persistState),
			workers: [
				...assetWorkers,
				...externalWorkers,
				...userWorkers
			],
			async unsafeModuleFallbackService(request$1) {
				const rawSpecifier = new URL(request$1.url).searchParams.get("rawSpecifier");
				assert(rawSpecifier, `Unexpected error: no specifier in request to module fallback service.`);
				const match = additionalModuleRE.exec(rawSpecifier);
				assert(match, `Unexpected error: no match for module: ${rawSpecifier}.`);
				const [full, moduleType, modulePath] = match;
				assert(moduleType, `Unexpected error: module type not found in reference: ${full}.`);
				assert(modulePath, `Unexpected error: module path not found in reference: ${full}.`);
				let contents;
				try {
					contents = await fsp.readFile(modulePath);
				} catch {
					throw new Error(`Import "${modulePath}" not found. Does the file exist?`);
				}
				switch (moduleType) {
					case "CompiledWasm": return Response$1.json({ wasm: Array.from(contents) });
					case "Data": return Response$1.json({ data: Array.from(contents) });
					case "Text": return Response$1.json({ text: contents.toString() });
					default: return Response$1.error();
				}
			}
		},
		containerTagToOptionsMap
	};
}
function getPreviewModules(main, modulesRules) {
	assert(modulesRules, `Unexpected error: 'modulesRules' is undefined`);
	const rootPath = nodePath.dirname(main);
	const entryPath = nodePath.basename(main);
	return {
		rootPath,
		modules: [{
			type: "ESModule",
			path: entryPath
		}, ...modulesRules.flatMap(({ type, include }) => globSync(include, {
			cwd: rootPath,
			ignore: entryPath
		}).map((globPath) => ({
			type,
			path: globPath
		})))]
	};
}
async function getPreviewMiniflareOptions(ctx, vitePreviewServer) {
	const inputInspectorPort = await getInputInspectorPort(ctx, vitePreviewServer);
	const { resolvedPluginConfig, resolvedViteConfig } = ctx;
	const containerTagToOptionsMap = /* @__PURE__ */ new Map();
	const workers = (await Promise.all(resolvedPluginConfig.workers.map(async (workerConfig, i$1) => {
		const bindings = wrangler.unstable_convertConfigBindingsToStartWorkerBindings(workerConfig);
		const preExistingRemoteProxySessionData = workerConfig.configPath ? remoteProxySessionsDataMap.get(workerConfig.configPath) : void 0;
		const remoteProxySessionData = !resolvedPluginConfig.remoteBindings ? null : await wrangler.maybeStartOrUpdateRemoteProxySession({
			name: workerConfig.name,
			bindings: bindings ?? {},
			account_id: workerConfig.account_id
		}, preExistingRemoteProxySessionData ?? null);
		if (workerConfig.configPath && remoteProxySessionData) remoteProxySessionsDataMap.set(workerConfig.configPath, remoteProxySessionData);
		let containerBuildId;
		if (workerConfig.containers?.length && workerConfig.dev.enable_containers) {
			const dockerPath = getDockerPath();
			workerConfig.dev.container_engine = resolveDockerHost(dockerPath);
			containerBuildId = generateContainerBuildId();
			const options = getContainerOptions({
				containersConfig: workerConfig.containers,
				containerBuildId,
				configPath: workerConfig.configPath
			});
			for (const option of options ?? []) containerTagToOptionsMap.set(option.image_tag, option);
		}
		const miniflareWorkerOptions = wrangler.unstable_getMiniflareWorkerOptions(workerConfig, void 0, {
			remoteProxyConnectionString: remoteProxySessionData?.session?.remoteProxyConnectionString,
			containerBuildId
		});
		const { externalWorkers } = miniflareWorkerOptions;
		const { modulesRules,...workerOptions } = miniflareWorkerOptions.workerOptions;
		return [{
			...workerOptions,
			name: workerOptions.name ?? workerConfig.name,
			unsafeInspectorProxy: inputInspectorPort !== false,
			unsafeDirectSockets: i$1 === 0 ? [{
				entrypoint: void 0,
				proxy: true
			}] : [],
			...miniflareWorkerOptions.main ? getPreviewModules(miniflareWorkerOptions.main, modulesRules) : {
				modules: true,
				script: ""
			}
		}, ...externalWorkers];
	}))).flat();
	const logger = new ViteMiniflareLogger(resolvedViteConfig);
	return {
		miniflareOptions: {
			log: logger,
			inspectorPort: inputInspectorPort === false ? void 0 : inputInspectorPort,
			unsafeDevRegistryPath: getDefaultDevRegistryPath(),
			unsafeTriggerHandlers: true,
			handleStructuredLogs: getStructuredLogsLogger(logger),
			defaultPersistRoot: getPersistenceRoot(resolvedViteConfig.root, resolvedPluginConfig.persistState),
			workers
		},
		containerTagToOptionsMap
	};
}
/**
* A Miniflare logger that forwards messages onto a Vite logger.
*/
var ViteMiniflareLogger = class extends Log {
	logger;
	constructor(config) {
		super(miniflareLogLevelFromViteLogLevel(config.logLevel));
		this.logger = config.logger;
	}
	logWithLevel(level, message) {
		switch (level) {
			case LogLevel.ERROR: return this.logger.error(message);
			case LogLevel.WARN: return this.logger.warn(message);
			case LogLevel.INFO: return this.logger.info(message);
		}
	}
	logReady() {}
};
function miniflareLogLevelFromViteLogLevel(level = "info") {
	switch (level) {
		case "error": return LogLevel.ERROR;
		case "warn": return LogLevel.WARN;
		case "info": return LogLevel.INFO;
		case "silent": return LogLevel.NONE;
	}
}
/**
* Generates a log handler to be passed as the `handleStructuredLogs` option to miniflare
*
* @param logger the vite logger to use
* @returns the log handler to pass to miniflare
*/
function getStructuredLogsLogger(logger) {
	return ({ level, message }) => {
		if (level === "warn") return logger.warn(message);
		if (level === "error") return logger.logWithLevel(LogLevel.ERROR, message);
		return logger.info(message);
	};
}

//#endregion
//#region src/websockets.ts
/**
* Handles 'upgrade' requests to the Vite HTTP server and forwards WebSocket events between the client and Worker environments.
*/
function handleWebSocket(httpServer, miniflare, entryWorkerName) {
	const nodeWebSocket = new WebSocketServer({ noServer: true });
	httpServer.on("upgrade", async (request$1, socket, head) => {
		const url = new URL(request$1.url ?? "", UNKNOWN_HOST);
		if (request$1.headers["sec-websocket-protocol"]?.startsWith("vite")) return;
		const headers = createHeaders(request$1);
		if (entryWorkerName) headers.set(CoreHeaders.ROUTE_OVERRIDE, entryWorkerName);
		const workerWebSocket = (await miniflare.dispatchFetch(url, {
			headers,
			method: request$1.method
		})).webSocket;
		if (!workerWebSocket) {
			socket.destroy();
			return;
		}
		nodeWebSocket.handleUpgrade(request$1, socket, head, async (clientWebSocket) => {
			coupleWebSocket(clientWebSocket, workerWebSocket);
			nodeWebSocket.emit("connection", clientWebSocket, request$1);
		});
	});
}

//#endregion
//#region src/plugins/dev.ts
let exitCallback$2 = () => {};
process.on("exit", () => {
	exitCallback$2();
});
/**
* Plugin to provide core development functionality
*/
const devPlugin = createPlugin("dev", (ctx) => {
	let containerImageTags = /* @__PURE__ */ new Set();
	return {
		async buildEnd() {
			if (ctx.resolvedViteConfig.command === "serve" && containerImageTags.size) cleanupContainers(getDockerPath(), containerImageTags);
			debuglog("buildEnd:", ctx.isRestartingDevServer ? "restarted" : "disposing");
			if (!ctx.isRestartingDevServer) try {
				await ctx.disposeMiniflare();
			} catch (error) {
				debuglog("Failed to dispose Miniflare instance:", error);
			}
		},
		async configureServer(viteDevServer) {
			assertIsNotPreview(ctx);
			const initialOptions = await getDevMiniflareOptions(ctx, viteDevServer);
			let containerTagToOptionsMap = initialOptions.containerTagToOptionsMap;
			await ctx.startOrUpdateMiniflare(initialOptions.miniflareOptions);
			let preMiddleware;
			if (ctx.resolvedPluginConfig.type === "workers") {
				debuglog("Initializing the Vite module runners");
				await initRunners(ctx.resolvedPluginConfig, viteDevServer, ctx.miniflare);
				const currentWorkerNameToExportTypesMap = await getCurrentWorkerNameToExportTypesMap(ctx.resolvedPluginConfig, viteDevServer, ctx.miniflare);
				if (compareWorkerNameToExportTypesMaps(ctx.workerNameToExportTypesMap, currentWorkerNameToExportTypesMap)) {
					ctx.setWorkerNameToExportTypesMap(currentWorkerNameToExportTypesMap);
					const updatedOptions = await getDevMiniflareOptions(ctx, viteDevServer);
					containerTagToOptionsMap = updatedOptions.containerTagToOptionsMap;
					await ctx.startOrUpdateMiniflare(updatedOptions.miniflareOptions);
					await initRunners(ctx.resolvedPluginConfig, viteDevServer, ctx.miniflare);
				}
				for (const environmentName of ctx.resolvedPluginConfig.environmentNameToWorkerMap.keys()) {
					const environment = viteDevServer.environments[environmentName];
					assert(environment, `Expected environment "${environmentName}" to be defined`);
					environment.hot.on("vite-plugin-cloudflare:worker-export-types", async (newExportTypes) => {
						const workerConfig = ctx.getWorkerConfig(environmentName);
						assert(workerConfig, `Expected workerConfig for environment "${environmentName}" to be defined`);
						const oldExportTypes = ctx.workerNameToExportTypesMap.get(workerConfig.name);
						assert(oldExportTypes, `Expected export types for Worker "${workerConfig.name}" to be defined`);
						if (compareExportTypes(oldExportTypes, newExportTypes)) {
							viteDevServer.config.logger.info(colors.dim(colors.yellow("Worker exports have changed. Restarting dev server.")));
							await viteDevServer.restart();
						}
					});
				}
				const entryWorkerConfig = ctx.entryWorkerConfig;
				assert(entryWorkerConfig, `No entry Worker config`);
				const entryWorkerName = entryWorkerConfig.name;
				if (viteDevServer.httpServer) handleWebSocket(viteDevServer.httpServer, ctx.miniflare, entryWorkerName);
				const staticRouting = entryWorkerConfig.assets?.run_worker_first === true ? { user_worker: ["/*"] } : ctx.resolvedPluginConfig.staticRouting;
				if (staticRouting) {
					const excludeRulesMatcher = generateStaticRoutingRuleMatcher(staticRouting.asset_worker ?? []);
					const includeRulesMatcher = generateStaticRoutingRuleMatcher(staticRouting.user_worker);
					const userWorkerHandler = createRequestHandler(async (request$1) => {
						request$1.headers.set(CoreHeaders.ROUTE_OVERRIDE, entryWorkerName);
						return ctx.miniflare.dispatchFetch(request$1, { redirect: "manual" });
					});
					preMiddleware = async (req, res, next) => {
						assert(req.url, `req.url not defined`);
						const request$1 = new Request(new URL(req.url, UNKNOWN_HOST));
						if (req[kRequestType] === "asset") next();
						else if (excludeRulesMatcher({ request: request$1 })) {
							req[kRequestType] = "asset";
							next();
						} else if (includeRulesMatcher({ request: request$1 })) userWorkerHandler(req, res, next);
						else next();
					};
				}
				if (containerTagToOptionsMap.size) {
					viteDevServer.config.logger.info(colors.dim(colors.yellow(" Building container images for local development...\n")));
					await prepareContainerImagesForDev({
						dockerPath: getDockerPath(),
						containerOptions: [...containerTagToOptionsMap.values()],
						onContainerImagePreparationStart: () => {},
						onContainerImagePreparationEnd: () => {},
						logger: viteDevServer.config.logger,
						isVite: true
					});
					containerImageTags = new Set(containerTagToOptionsMap.keys());
					viteDevServer.config.logger.info(colors.dim(colors.yellow("\n Containers successfully built. To rebuild your containers during development, restart the Vite dev server (r + enter).")));
					exitCallback$2 = () => {
						if (containerImageTags.size) cleanupContainers(getDockerPath(), containerImageTags);
					};
				}
			}
			return () => {
				if (preMiddleware) {
					const middlewareStack = viteDevServer.middlewares.stack;
					const cachedTransformMiddlewareIndex = middlewareStack.findIndex((middleware) => "name" in middleware.handle && middleware.handle.name === "viteCachedTransformMiddleware");
					assert(cachedTransformMiddlewareIndex !== -1, "Failed to find viteCachedTransformMiddleware");
					middlewareStack.splice(cachedTransformMiddlewareIndex, 0, {
						route: "",
						handle: preMiddleware
					});
				}
				viteDevServer.middlewares.use(createRequestHandler(async (request$1, req) => {
					if (req[kRequestType] === "asset") {
						request$1.headers.set(CoreHeaders.ROUTE_OVERRIDE, ASSET_WORKER_NAME);
						return ctx.miniflare.dispatchFetch(request$1, { redirect: "manual" });
					} else {
						request$1.headers.set(CoreHeaders.ROUTE_OVERRIDE, ROUTER_WORKER_NAME);
						return ctx.miniflare.dispatchFetch(request$1, { redirect: "manual" });
					}
				}));
			};
		}
	};
});

//#endregion
//#region src/plugins/nodejs-compat.ts
/**
* Plugin to support the `nodejs_als` compatibility flag
*/
const nodeJsAlsPlugin = createPlugin("nodejs-als", (ctx) => {
	return { configEnvironment(name) {
		if (hasNodeJsAls(ctx.getWorkerConfig(name))) return {
			resolve: { builtins: ["async_hooks", "node:async_hooks"] },
			optimizeDeps: { exclude: ["async_hooks", "node:async_hooks"] }
		};
	} };
});
/**
* Plugin to support the `nodejs_compat` compatibility flag
*/
const nodeJsCompatPlugin = createPlugin("nodejs-compat", (ctx) => {
	return {
		configEnvironment(name) {
			const nodeJsCompat = ctx.getNodeJsCompat(name);
			if (nodeJsCompat) return {
				resolve: { builtins: [...nodeJsCompat.externals] },
				optimizeDeps: { exclude: [...nodeJsBuiltins] }
			};
		},
		applyToEnvironment(environment) {
			return ctx.getNodeJsCompat(environment.name) !== void 0;
		},
		enforce: "pre",
		async resolveId(source, importer, options) {
			const nodeJsCompat = ctx.getNodeJsCompat(this.environment.name);
			assertHasNodeJsCompat(nodeJsCompat);
			if (nodeJsCompat.isGlobalVirtualModule(source)) return source;
			const result = nodeJsCompat.resolveNodeJsImport(source);
			if (!result) return this.resolve(source, importer, options);
			if (this.environment.mode === "dev") {
				assert(this.environment.depsOptimizer, "depsOptimizer is required in dev mode");
				const { id } = this.environment.depsOptimizer.registerMissingImport(result.unresolved, result.resolved);
				return this.resolve(id, importer, options);
			}
			return this.resolve(result.resolved, importer, options);
		},
		load(id) {
			const nodeJsCompat = ctx.getNodeJsCompat(this.environment.name);
			assertHasNodeJsCompat(nodeJsCompat);
			return nodeJsCompat.getGlobalVirtualModule(id);
		},
		async configureServer(viteDevServer) {
			await Promise.all(Object.values(viteDevServer.environments).flatMap(async (environment) => {
				const nodeJsCompat = ctx.getNodeJsCompat(environment.name);
				if (nodeJsCompat) {
					await environment.depsOptimizer?.init();
					return Array.from(nodeJsCompat.entries).map((entry) => {
						const result = nodeJsCompat.resolveNodeJsImport(entry);
						if (result) return (environment.depsOptimizer?.registerMissingImport(result.unresolved, result.resolved))?.processing;
					});
				}
			}));
		}
	};
});
let exitCallback$1 = () => {};
process.on("exit", () => {
	exitCallback$1();
});
/**
* Plugin to warn if Node.js APIs are used without enabling the `nodejs_compat` compatibility flag
*/
const nodeJsCompatWarningsPlugin = createPlugin("nodejs-compat-warnings", (ctx) => {
	const nodeJsCompatWarningsMap = /* @__PURE__ */ new Map();
	exitCallback$1 = () => {
		for (const nodeJsCompatWarnings of nodeJsCompatWarningsMap.values()) nodeJsCompatWarnings.renderWarnings();
	};
	function resolveId(environmentName, source, importer) {
		const workerConfig = ctx.getWorkerConfig(environmentName);
		const nodeJsCompat = ctx.getNodeJsCompat(environmentName);
		if (workerConfig && !nodeJsCompat) {
			if (hasNodeJsAls(workerConfig) && isNodeAlsModule(source)) return;
			const nodeJsCompatWarnings = nodeJsCompatWarningsMap.get(workerConfig);
			if (nodeJsBuiltins.has(source)) {
				nodeJsCompatWarnings?.registerImport(source, importer);
				return {
					id: source,
					external: true
				};
			}
		}
	}
	return {
		enforce: "pre",
		configEnvironment(environmentName) {
			const workerConfig = ctx.getWorkerConfig(environmentName);
			const nodeJsCompat = ctx.getNodeJsCompat(environmentName);
			if (workerConfig && !nodeJsCompat) return { optimizeDeps: { ..."rolldownVersion" in vite ? { rolldownOptions: { plugins: [{
				name: "vite-plugin-cloudflare:nodejs-compat-warnings-resolver",
				resolveId(source, importer) {
					return resolveId(environmentName, source, importer);
				}
			}] } } : { esbuildOptions: { plugins: [{
				name: "vite-plugin-cloudflare:nodejs-compat-warnings-resolver",
				setup(build) {
					build.onResolve({ filter: NODEJS_MODULES_RE }, ({ path, importer }) => {
						if (hasNodeJsAls(workerConfig) && isNodeAlsModule(path)) return;
						nodeJsCompatWarningsMap.get(workerConfig)?.registerImport(path, importer);
						return {
							path,
							external: true
						};
					});
				}
			}] } } } };
		},
		configResolved(resolvedViteConfig) {
			for (const environmentName of Object.keys(resolvedViteConfig.environments)) {
				const workerConfig = ctx.getWorkerConfig(environmentName);
				const nodeJsCompat = ctx.getNodeJsCompat(environmentName);
				if (workerConfig && !nodeJsCompat) nodeJsCompatWarningsMap.set(workerConfig, new NodeJsCompatWarnings(environmentName, resolvedViteConfig));
			}
		},
		async resolveId(source, importer) {
			return resolveId(this.environment.name, source, importer);
		}
	};
});

//#endregion
//#region src/plugins/output-config.ts
/**
* Plugin to generate additional output files as part of the build, including the output `wrangler.json` file.
*/
const outputConfigPlugin = createPlugin("output-config", (ctx) => {
	return {
		generateBundle(_, bundle) {
			assertIsNotPreview(ctx);
			let outputConfig;
			if (ctx.resolvedPluginConfig.type === "workers") {
				const inputConfig = ctx.getWorkerConfig(this.environment.name);
				if (!inputConfig) return;
				const entryChunk = Object.values(bundle).find((chunk) => chunk.type === "chunk" && chunk.isEntry && chunk.name === MAIN_ENTRY_NAME);
				assert(entryChunk, `Expected entry chunk with name "${MAIN_ENTRY_NAME}"`);
				const isEntryWorker = this.environment.name === ctx.resolvedPluginConfig.entryWorkerEnvironmentName;
				outputConfig = {
					...inputConfig,
					main: entryChunk.fileName,
					no_bundle: true,
					rules: [{
						type: "ESModule",
						globs: ["**/*.js", "**/*.mjs"]
					}],
					assets: isEntryWorker ? {
						...inputConfig.assets,
						directory: getAssetsDirectory(this.environment.config.build.outDir, ctx.resolvedViteConfig)
					} : void 0
				};
				if (inputConfig.configPath) {
					const localDevVars = getLocalDevVarsForPreview(inputConfig.configPath, ctx.resolvedPluginConfig.cloudflareEnv);
					if (localDevVars) this.emitFile({
						type: "asset",
						fileName: ".dev.vars",
						source: localDevVars
					});
				}
			} else if (this.environment.name === "client") {
				const inputConfig = ctx.resolvedPluginConfig.config;
				outputConfig = {
					...inputConfig,
					assets: {
						...inputConfig.assets,
						directory: "."
					}
				};
				this.emitFile({
					type: "asset",
					fileName: ".assetsignore",
					source: `${["wrangler.json", ".dev.vars"].join("\n")}\n`
				});
			}
			if (!outputConfig) return;
			if (outputConfig.unsafe && Object.keys(outputConfig.unsafe).length === 0) outputConfig.unsafe = void 0;
			this.emitFile({
				type: "asset",
				fileName: "wrangler.json",
				source: JSON.stringify(outputConfig)
			});
		},
		writeBundle() {
			assertIsNotPreview(ctx);
			if (this.environment.name === (ctx.resolvedPluginConfig.type === "workers" ? ctx.resolvedPluginConfig.entryWorkerEnvironmentName : "client")) writeDeployConfig(ctx.resolvedPluginConfig, ctx.resolvedViteConfig);
		}
	};
});
function getAssetsDirectory(workerOutputDirectory, resolvedViteConfig) {
	const clientOutputDirectory = resolvedViteConfig.environments.client?.build.outDir;
	assert(clientOutputDirectory, "Unexpected error: client output directory is undefined");
	return nodePath.relative(nodePath.resolve(resolvedViteConfig.root, workerOutputDirectory), nodePath.resolve(resolvedViteConfig.root, clientOutputDirectory));
}

//#endregion
//#region src/plugins/preview.ts
let exitCallback = () => {};
process.on("exit", () => {
	exitCallback();
});
/**
* Plugin to provide core preview functionality
*/
const previewPlugin = createPlugin("preview", (ctx) => {
	return { async configurePreviewServer(vitePreviewServer) {
		assertIsPreview(ctx);
		const closePreviewServer = vitePreviewServer.close.bind(vitePreviewServer);
		vitePreviewServer.close = async () => {
			await Promise.all([ctx.disposeMiniflare(), closePreviewServer()]);
		};
		const { miniflareOptions, containerTagToOptionsMap } = await getPreviewMiniflareOptions(ctx, vitePreviewServer);
		await ctx.startOrUpdateMiniflare(miniflareOptions);
		if (containerTagToOptionsMap.size) {
			const dockerPath = getDockerPath();
			vitePreviewServer.config.logger.info(colors.dim(colors.yellow(" Building container images for local preview...\n")));
			await prepareContainerImagesForDev({
				dockerPath: getDockerPath(),
				containerOptions: [...containerTagToOptionsMap.values()],
				onContainerImagePreparationStart: () => {},
				onContainerImagePreparationEnd: () => {},
				logger: vitePreviewServer.config.logger,
				isVite: true
			});
			const containerImageTags = new Set(containerTagToOptionsMap.keys());
			vitePreviewServer.config.logger.info(colors.dim(colors.yellow("\n Containers successfully built.\n")));
			exitCallback = () => {
				if (containerImageTags.size) cleanupContainers(dockerPath, containerImageTags);
			};
		}
		handleWebSocket(vitePreviewServer.httpServer, ctx.miniflare);
		vitePreviewServer.middlewares.use(createRequestHandler((request$1) => {
			return ctx.miniflare.dispatchFetch(request$1, { redirect: "manual" });
		}));
	} };
});

//#endregion
//#region src/plugins/shortcuts.ts
const shortcutsPlugin = createPlugin("shortcuts", (ctx) => {
	const isCustomShortcutsSupported = satisfiesViteVersion("7.2.7");
	return {
		async configureServer(viteDevServer) {
			if (!isCustomShortcutsSupported) return;
			assertIsNotPreview(ctx);
			addBindingsShortcut(viteDevServer, ctx);
		},
		async configurePreviewServer(vitePreviewServer) {
			if (!isCustomShortcutsSupported) return;
			assertIsPreview(ctx);
			addBindingsShortcut(vitePreviewServer, ctx);
		}
	};
});
function addBindingsShortcut(server, ctx) {
	const workerConfigs = ctx.allWorkerConfigs;
	if (workerConfigs.length === 0) return;
	const registryPath = getDefaultDevRegistryPath();
	const printBindingsShortcut = {
		key: "b",
		description: "list configured Cloudflare bindings",
		action: (viteServer) => {
			viteServer.config.logger.info("");
			for (const workerConfig of workerConfigs) wrangler.unstable_printBindings({
				...workerConfig,
				assets: workerConfig.assets?.binding ? {
					...workerConfig.assets,
					binding: workerConfig.assets.binding
				} : void 0,
				unsafe: {
					bindings: workerConfig.unsafe.bindings,
					metadata: workerConfig.unsafe.metadata,
					capnp: workerConfig.unsafe.capnp
				},
				queues: workerConfig.queues.producers?.map((queue) => ({
					...queue,
					queue_name: queue.queue
				}))
			}, workerConfig.tail_consumers, workerConfig.streaming_tail_consumers, workerConfig.containers, {
				warnIfNoBindings: true,
				isMultiWorker: workerConfigs.length > 1,
				name: workerConfig.name ?? "Your Worker",
				registry: getWorkerRegistry(registryPath),
				log: (message) => viteServer.config.logger.info(message)
			});
		}
	};
	const bindCLIShortcuts = server.bindCLIShortcuts.bind(server);
	server.bindCLIShortcuts = (options) => {
		if (server.httpServer && process.stdin.isTTY && !process.env.CI && options?.print) server.config.logger.info(colors.dim(colors.green("  ")) + colors.dim("  press ") + colors.bold(`${printBindingsShortcut.key} + enter`) + colors.dim(` to ${printBindingsShortcut.description}`));
		bindCLIShortcuts(options);
	};
	server.bindCLIShortcuts({ customShortcuts: [printBindingsShortcut] });
}

//#endregion
//#region src/plugins/trigger-handlers.ts
/**
* Plugin to forward `/cdn-cgi/handler/*` routes to trigger handlers in development
*/
const triggerHandlersPlugin = createPlugin("trigger-handlers", (ctx) => {
	return {
		enforce: "pre",
		async configureServer(viteDevServer) {
			const entryWorkerConfig = ctx.entryWorkerConfig;
			if (!entryWorkerConfig) return;
			const entryWorkerName = entryWorkerConfig.name;
			const requestHandler = createRequestHandler((request$1) => {
				request$1.headers.set(CoreHeaders.ROUTE_OVERRIDE, entryWorkerName);
				return ctx.miniflare.dispatchFetch(request$1, { redirect: "manual" });
			});
			viteDevServer.middlewares.use("/cdn-cgi/handler/", requestHandler);
		}
	};
});

//#endregion
//#region src/plugins/wasm.ts
/**
* Plugin to support the `.wasm?init` extension
*/
const wasmHelperPlugin = createPlugin("wasm-helper", (ctx) => {
	return {
		enforce: "pre",
		applyToEnvironment(environment) {
			return ctx.getWorkerConfig(environment.name) !== void 0;
		},
		load(id) {
			if (!id.endsWith(".wasm?init")) return;
			return `
					import wasm from "${cleanUrl(id)}";
					export default function(opts = {}) {
						return WebAssembly.instantiate(wasm, opts);
					}
				`;
		}
	};
});

//#endregion
//#region src/index.ts
const sharedContext = {
	hasShownWorkerConfigWarnings: false,
	isRestartingDevServer: false
};
await assertWranglerVersion();
/**
* Vite plugin that enables a full-featured integration between Vite and the Cloudflare Workers runtime.
*
* See the [README](https://github.com/cloudflare/workers-sdk/tree/main/packages/vite-plugin-cloudflare#readme) for more details.
*
* @param pluginConfig An optional {@link PluginConfig} object.
*/
function cloudflare(pluginConfig = {}) {
	const ctx = new PluginContext(sharedContext);
	return [
		{
			name: "vite-plugin-cloudflare",
			sharedDuringBuild: true,
			config(userConfig, env) {
				ctx.setResolvedPluginConfig(resolvePluginConfig(pluginConfig, userConfig, env));
			},
			async configureServer(viteDevServer) {
				const restartServer = viteDevServer.restart.bind(viteDevServer);
				viteDevServer.restart = async () => {
					try {
						ctx.setIsRestartingDevServer(true);
						debuglog("From server.restart(): Restarting server...");
						await restartServer();
						debuglog("From server.restart(): Restarted server...");
					} finally {
						ctx.setIsRestartingDevServer(false);
					}
				};
			}
		},
		configPlugin(ctx),
		devPlugin(ctx),
		previewPlugin(ctx),
		shortcutsPlugin(ctx),
		debugPlugin(ctx),
		triggerHandlersPlugin(ctx),
		virtualModulesPlugin(ctx),
		virtualClientFallbackPlugin(ctx),
		outputConfigPlugin(ctx),
		wasmHelperPlugin(ctx),
		additionalModulesPlugin(ctx),
		nodeJsAlsPlugin(ctx),
		nodeJsCompatPlugin(ctx),
		nodeJsCompatWarningsPlugin(ctx)
	];
}

//#endregion
export { cloudflare, getLocalWorkerdCompatibilityDate };
//# sourceMappingURL=index.mjs.map