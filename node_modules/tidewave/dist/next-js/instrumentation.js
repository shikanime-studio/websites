import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// src/logger/circular-buffer.ts
class CircularBuffer {
  buffer;
  maxSize;
  writeIndex = 0;
  count = 0;
  constructor(maxSize = 1024) {
    this.buffer = new Array(maxSize);
    this.maxSize = maxSize;
  }
  addLog(log) {
    this.buffer[this.writeIndex] = log;
    this.writeIndex = (this.writeIndex + 1) % this.maxSize;
    this.count = Math.min(this.count + 1, this.maxSize);
  }
  getLogs(options) {
    let logs = this.getAllLogs();
    if (options?.level) {
      const level = options.level.toUpperCase();
      logs = logs.filter((log) => log.severityText === level);
    }
    if (options?.since) {
      const sinceDate = new Date(options.since);
      logs = logs.filter((log) => new Date(log.timestamp) >= sinceDate);
    }
    if (options?.grep) {
      const regex = new RegExp(options.grep, "i");
      logs = logs.filter((log) => regex.test(log.body) || regex.test(JSON.stringify(log.attributes)));
    }
    if (options?.tail) {
      logs = logs.slice(-options.tail);
    }
    return logs;
  }
  getAllLogs() {
    if (this.count < this.maxSize) {
      return this.buffer.slice(0, this.count).filter(Boolean);
    }
    return [...this.buffer.slice(this.writeIndex), ...this.buffer.slice(0, this.writeIndex)].filter(Boolean);
  }
  getStats() {
    return {
      totalLogs: this.count,
      bufferSize: this.maxSize,
      bufferUsage: Math.min(this.count / this.maxSize * 100, 100).toFixed(1) + "%"
    };
  }
  clear() {
    this.buffer = new Array(this.maxSize);
    this.writeIndex = 0;
    this.count = 0;
  }
}
var circularBuffer;
var init_circular_buffer = __esm(() => {
  if (!globalThis.__tidewaveCircularBuffer) {
    globalThis.__tidewaveCircularBuffer = new CircularBuffer(1024);
  }
  circularBuffer = globalThis.__tidewaveCircularBuffer;
});

// src/logger/tidewave-span-processor.ts
class TidewaveSpanProcessor {
  onStart(_span, _parentContext) {}
  onEnd(span) {
    try {
      const spanType = span.attributes["next.span_type"];
      const httpMethod = span.attributes["http.method"];
      const relevantSpanTypes = [
        "BaseServer.handleRequest",
        "AppRender.getBodyResult",
        "AppRouteRouteHandlers.runHandler"
      ];
      if (!spanType || !relevantSpanTypes.includes(spanType)) {
        return;
      }
      const route = span.attributes["next.route"] || span.attributes["http.route"];
      const httpUrl = span.attributes["http.url"];
      const httpTarget = span.attributes["http.target"];
      const httpStatusCode = span.attributes["http.status_code"];
      const path = route || httpTarget || httpUrl || "unknown";
      if (typeof path === "string" && path.startsWith("/tidewave")) {
        return;
      }
      const durationMs = this.calculateDuration(span);
      let message = "";
      let severity = "INFO";
      if (spanType === "BaseServer.handleRequest") {
        const method = httpMethod || "UNKNOWN";
        const status = httpStatusCode || "unknown";
        message = `${method} ${path} ${status} ${durationMs.toFixed(2)}ms`;
        if (typeof httpStatusCode === "number") {
          if (httpStatusCode >= 500)
            severity = "ERROR";
          else if (httpStatusCode >= 400)
            severity = "WARN";
        }
      } else if (spanType === "AppRender.getBodyResult") {
        message = `Rendered route: ${route || "unknown"} (${durationMs.toFixed(2)}ms)`;
      } else if (spanType === "AppRouteRouteHandlers.runHandler") {
        message = `API route: ${route || "unknown"} (${durationMs.toFixed(2)}ms)`;
      }
      circularBuffer.addLog({
        timestamp: new Date(span.endTime[0] * 1000 + span.endTime[1] / 1e6).toISOString(),
        severityText: severity,
        body: message,
        attributes: {
          "log.origin": "opentelemetry-span",
          "span.name": span.name,
          "span.kind": span.kind,
          "span.type": spanType,
          "http.method": httpMethod,
          "http.route": route,
          "http.status_code": httpStatusCode,
          "duration.ms": durationMs
        }
      });
    } catch (_error) {}
  }
  calculateDuration(span) {
    const startTimeMs = span.startTime[0] * 1000 + span.startTime[1] / 1e6;
    const endTimeMs = span.endTime[0] * 1000 + span.endTime[1] / 1e6;
    return endTimeMs - startTimeMs;
  }
  async forceFlush() {}
  async shutdown() {}
}
var init_tidewave_span_processor = __esm(() => {
  init_circular_buffer();
});

// src/logger/tidewave-log-record-processor.ts
class TidewaveLogRecordProcessor {
  onEmit(logRecord, _context) {
    try {
      const body = String(logRecord.body || "");
      circularBuffer.addLog({
        timestamp: new Date(logRecord.hrTime[0] * 1000 + logRecord.hrTime[1] / 1e6).toISOString(),
        severityText: logRecord.severityText || "INFO",
        body,
        attributes: logRecord.attributes,
        resource: logRecord.resource?.attributes
      });
    } catch (_error) {}
  }
  async forceFlush() {}
  async shutdown() {}
}
var init_tidewave_log_record_processor = __esm(() => {
  init_circular_buffer();
});

// src/logger/instrumentation.ts
var exports_instrumentation = {};
__export(exports_instrumentation, {
  TidewaveSpanProcessor: () => TidewaveSpanProcessor,
  TidewaveLogRecordProcessor: () => TidewaveLogRecordProcessor
});
function stripAnsiCodes(text) {
  return text.replace(ANSI_REGEX, "");
}
function patchConsole() {
  const isBrowser = typeof globalThis !== "undefined" && typeof globalThis.window !== "undefined";
  if (isBrowser) {
    return;
  }
  if (globalThis.__TIDEWAVE_CONSOLE_PATCHED__) {
    return;
  }
  const severityMap = {
    log: "INFO",
    info: "INFO",
    warn: "WARN",
    error: "ERROR",
    debug: "DEBUG"
  };
  Object.entries(severityMap).forEach(([method, severity]) => {
    const original = console[method].bind(console);
    console[method] = (...args) => {
      try {
        const body = args.map((arg) => {
          if (typeof arg === "string")
            return arg;
          if (arg instanceof Error) {
            return String(arg.stack);
          }
          if (typeof arg === "object") {
            try {
              return JSON.stringify(arg);
            } catch {
              return String(arg);
            }
          }
          return String(arg);
        }).map(stripAnsiCodes).join(" ");
        circularBuffer.addLog({
          timestamp: new Date().toISOString(),
          severityText: severity,
          body,
          attributes: {
            "log.origin": "console",
            "log.method": method
          }
        });
      } catch {}
      original(...args);
    };
  });
  globalThis.__TIDEWAVE_CONSOLE_PATCHED__ = true;
}
var ANSI_REGEX;
var init_instrumentation = __esm(() => {
  init_circular_buffer();
  init_tidewave_span_processor();
  init_tidewave_log_record_processor();
  ANSI_REGEX = /\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])/g;
  patchConsole();
});

// src/next-js/instrumentation.ts
init_instrumentation();
export {
  TidewaveSpanProcessor,
  TidewaveLogRecordProcessor
};
