{"version":3,"file":"utils.js","sources":["../../src/utils.ts"],"sourcesContent":["/**\n * Simple assertion function for runtime checks.\n * Throws an error if the condition is false.\n */\nexport function assert(\n  condition: unknown,\n  message?: string,\n): asserts condition {\n  if (!condition) {\n    throw new Error(message || `Assertion failed`)\n  }\n}\n\n/**\n * A map that returns a default value for keys that are not present.\n */\nexport class DefaultMap<K, V> extends Map<K, V> {\n  constructor(\n    private defaultValue: () => V,\n    entries?: Iterable<[K, V]>,\n  ) {\n    super(entries)\n  }\n\n  get(key: K): V {\n    if (!this.has(key)) {\n      // this.set(key, this.defaultValue())\n      return this.defaultValue()\n    }\n    return super.get(key)!\n  }\n\n  /**\n   * Update the value for a key using a function.\n   */\n  update(key: K, updater: (value: V) => V): V {\n    const value = this.get(key)\n    const newValue = updater(value)\n    this.set(key, newValue)\n    return newValue\n  }\n}\n\n// JS engines have various limits on how many args can be passed to a function\n// with a spread operator, so we need to split the operation into chunks\n// 32767 is the max for Chrome 14, all others are higher\n// TODO: investigate the performance of this and other approaches\nconst chunkSize = 30000\nexport function chunkedArrayPush(array: Array<unknown>, other: Array<unknown>) {\n  if (other.length <= chunkSize) {\n    array.push(...other)\n  } else {\n    for (let i = 0; i < other.length; i += chunkSize) {\n      const chunk = other.slice(i, i + chunkSize)\n      array.push(...chunk)\n    }\n  }\n}\n\nexport function binarySearch<T>(\n  array: Array<T>,\n  value: T,\n  comparator: (a: T, b: T) => number,\n): number {\n  let low = 0\n  let high = array.length\n  while (low < high) {\n    const mid = Math.floor((low + high) / 2)\n    const comparison = comparator(array[mid]!, value)\n    if (comparison < 0) {\n      low = mid + 1\n    } else if (comparison > 0) {\n      high = mid\n    } else {\n      return mid\n    }\n  }\n  return low\n}\n\n/**\n * Utility for generating unique IDs for objects and values.\n * Uses WeakMap for object reference tracking and consistent hashing for primitives.\n */\nexport class ObjectIdGenerator {\n  private objectIds = new WeakMap<object, number>()\n  private nextId = 0\n\n  /**\n   * Get a unique identifier for any value.\n   * - Objects: Uses WeakMap for reference-based identity\n   * - Primitives: Uses consistent string-based hashing\n   */\n  getId(value: any): number {\n    // For primitives, use a simple hash of their string representation\n    if (typeof value !== `object` || value === null) {\n      const str = String(value)\n      let hashValue = 0\n      for (let i = 0; i < str.length; i++) {\n        const char = str.charCodeAt(i)\n        hashValue = (hashValue << 5) - hashValue + char\n        hashValue = hashValue & hashValue // Convert to 32-bit integer\n      }\n      return hashValue\n    }\n\n    // For objects, use WeakMap to assign unique IDs\n    if (!this.objectIds.has(value)) {\n      this.objectIds.set(value, this.nextId++)\n    }\n    return this.objectIds.get(value)!\n  }\n\n  /**\n   * Get a string representation of the ID for use in composite keys.\n   */\n  getStringId(value: any): string {\n    if (value === null) return `null`\n    if (value === undefined) return `undefined`\n    if (typeof value !== `object`) return `str_${String(value)}`\n\n    return `obj_${this.getId(value)}`\n  }\n}\n\n/**\n * Global instance for cases where a shared object ID space is needed.\n */\nexport const globalObjectIdGenerator = new ObjectIdGenerator()\n\nexport function* concatIterable<T>(\n  ...iterables: Array<Iterable<T>>\n): Iterable<T> {\n  for (const iterable of iterables) {\n    yield* iterable\n  }\n}\n\nexport function* mapIterable<T, U>(\n  it: Iterable<T>,\n  fn: (t: T) => U,\n): Iterable<U> {\n  for (const t of it) {\n    yield fn(t)\n  }\n}\n\nexport type HRange = [number, number] // half-open [start, end[ i.e. end is exclusive\n\n/**\n * Computes the difference between two half-open ranges.\n * @param a - The first half-open range\n * @param b - The second half-open range\n * @returns The difference between the two ranges\n */\nexport function diffHalfOpen(a: HRange, b: HRange) {\n  const [a1, a2] = a\n  const [b1, b2] = b\n\n  // A \\ B can be up to two segments (left and right of the overlap)\n  const onlyInA: Array<number> = [\n    ...range(a1, Math.min(a2, b1)), // left side of A outside B\n    ...range(Math.max(a1, b2), a2), // right side of A outside B\n  ]\n\n  // B \\ A similarly\n  const onlyInB: Array<number> = [\n    ...range(b1, Math.min(b2, a1)),\n    ...range(Math.max(b1, a2), b2),\n  ]\n\n  return { onlyInA, onlyInB }\n}\n\nfunction range(start: number, end: number): Array<number> {\n  const out: Array<number> = []\n  for (let i = start; i < end; i++) out.push(i)\n  return out\n}\n\n/**\n * Compares two keys (string | number) in a consistent, deterministic way.\n * Handles mixed types by ordering strings before numbers.\n */\nexport function compareKeys(a: string | number, b: string | number): number {\n  // Same type: compare directly\n  if (typeof a === typeof b) {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  }\n  // Different types: strings come before numbers\n  return typeof a === `string` ? -1 : 1\n}\n"],"names":[],"mappings":"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"}