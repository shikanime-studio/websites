{"version":3,"file":"inject-source.js","sources":["../../src/inject-source.ts"],"sourcesContent":["import { normalizePath } from 'vite'\nimport { gen, parse, t, trav } from './babel'\nimport { matcher } from './matcher'\nimport type { types as Babel, NodePath } from '@babel/core'\nimport type { ParseResult } from '@babel/parser'\n\nconst getPropsNameFromFunctionDeclaration = (\n  functionDeclaration:\n    | t.VariableDeclarator\n    | t.FunctionExpression\n    | t.FunctionDeclaration\n    | t.ArrowFunctionExpression,\n) => {\n  let propsName: string | null = null\n\n  if (functionDeclaration.type === 'FunctionExpression') {\n    const firstArgument = functionDeclaration.params[0]\n    // handles (props) => {}\n    if (firstArgument && firstArgument.type === 'Identifier') {\n      propsName = firstArgument.name\n    }\n    // handles ({ ...props }) => {}\n    if (firstArgument && firstArgument.type === 'ObjectPattern') {\n      firstArgument.properties.forEach((prop) => {\n        if (\n          prop.type === 'RestElement' &&\n          prop.argument.type === 'Identifier'\n        ) {\n          propsName = prop.argument.name\n        }\n      })\n    }\n    return propsName\n  }\n  if (functionDeclaration.type === 'ArrowFunctionExpression') {\n    const firstArgument = functionDeclaration.params[0]\n    // handles (props) => {}\n    if (firstArgument && firstArgument.type === 'Identifier') {\n      propsName = firstArgument.name\n    }\n    // handles ({ ...props }) => {}\n    if (firstArgument && firstArgument.type === 'ObjectPattern') {\n      firstArgument.properties.forEach((prop) => {\n        if (\n          prop.type === 'RestElement' &&\n          prop.argument.type === 'Identifier'\n        ) {\n          propsName = prop.argument.name\n        }\n      })\n    }\n    return propsName\n  }\n  if (functionDeclaration.type === 'FunctionDeclaration') {\n    const firstArgument = functionDeclaration.params[0]\n    // handles (props) => {}\n    if (firstArgument && firstArgument.type === 'Identifier') {\n      propsName = firstArgument.name\n    }\n    // handles ({ ...props }) => {}\n    if (firstArgument && firstArgument.type === 'ObjectPattern') {\n      firstArgument.properties.forEach((prop) => {\n        if (\n          prop.type === 'RestElement' &&\n          prop.argument.type === 'Identifier'\n        ) {\n          propsName = prop.argument.name\n        }\n      })\n    }\n    return propsName\n  }\n  // Arrow function case\n  if (\n    functionDeclaration.init?.type === 'ArrowFunctionExpression' ||\n    functionDeclaration.init?.type === 'FunctionExpression'\n  ) {\n    const firstArgument = functionDeclaration.init.params[0]\n    // handles (props) => {}\n    if (firstArgument && firstArgument.type === 'Identifier') {\n      propsName = firstArgument.name\n    }\n    // handles ({ ...props }) => {}\n    if (firstArgument && firstArgument.type === 'ObjectPattern') {\n      firstArgument.properties.forEach((prop) => {\n        if (\n          prop.type === 'RestElement' &&\n          prop.argument.type === 'Identifier'\n        ) {\n          propsName = prop.argument.name\n        }\n      })\n    }\n  }\n  return propsName\n}\n\nconst getNameOfElement = (\n  element: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n): string => {\n  if (element.type === 'JSXIdentifier') {\n    return element.name\n  }\n  if (element.type === 'JSXMemberExpression') {\n    return `${getNameOfElement(element.object)}.${getNameOfElement(element.property)}`\n  }\n\n  return `${element.namespace.name}:${element.name.name}`\n}\n\nconst transformJSX = (\n  element: NodePath<t.JSXOpeningElement>,\n  propsName: string | null,\n  file: string,\n  ignorePatterns: Array<string | RegExp>,\n) => {\n  const loc = element.node.loc\n  if (!loc) return\n  const line = loc.start.line\n  const column = loc.start.column\n  const nameOfElement = getNameOfElement(element.node.name)\n  const isIgnored = matcher(ignorePatterns, nameOfElement)\n  if (\n    nameOfElement === 'Fragment' ||\n    nameOfElement === 'React.Fragment' ||\n    isIgnored\n  ) {\n    return\n  }\n  const hasDataSource = element.node.attributes.some(\n    (attr) =>\n      attr.type === 'JSXAttribute' &&\n      attr.name.type === 'JSXIdentifier' &&\n      attr.name.name === 'data-tsd-source',\n  )\n  // Check if props are spread\n  const hasSpread = element.node.attributes.some(\n    (attr) =>\n      attr.type === 'JSXSpreadAttribute' &&\n      attr.argument.type === 'Identifier' &&\n      attr.argument.name === propsName,\n  )\n\n  if (hasSpread || hasDataSource) {\n    // Do not inject if props are spread\n    return\n  }\n\n  // Inject data-source as a string: \"<file>:<line>:<column>\"\n  element.node.attributes.push(\n    t.jsxAttribute(\n      t.jsxIdentifier('data-tsd-source'),\n      t.stringLiteral(`${file}:${line}:${column + 1}`),\n    ),\n  )\n\n  return true\n}\n\nconst transform = (\n  ast: ParseResult<Babel.File>,\n  file: string,\n  ignorePatterns: Array<string | RegExp>,\n) => {\n  let didTransform = false\n\n  trav(ast, {\n    FunctionDeclaration(functionDeclaration) {\n      const propsName = getPropsNameFromFunctionDeclaration(\n        functionDeclaration.node,\n      )\n      functionDeclaration.traverse({\n        JSXOpeningElement(element) {\n          const transformed = transformJSX(\n            element,\n            propsName,\n            file,\n            ignorePatterns,\n          )\n          if (transformed) {\n            didTransform = true\n          }\n        },\n      })\n    },\n    ArrowFunctionExpression(path) {\n      const propsName = getPropsNameFromFunctionDeclaration(path.node)\n      path.traverse({\n        JSXOpeningElement(element) {\n          const transformed = transformJSX(\n            element,\n            propsName,\n            file,\n            ignorePatterns,\n          )\n          if (transformed) {\n            didTransform = true\n          }\n        },\n      })\n    },\n    FunctionExpression(path) {\n      const propsName = getPropsNameFromFunctionDeclaration(path.node)\n      path.traverse({\n        JSXOpeningElement(element) {\n          const transformed = transformJSX(\n            element,\n            propsName,\n            file,\n            ignorePatterns,\n          )\n          if (transformed) {\n            didTransform = true\n          }\n        },\n      })\n    },\n    VariableDeclaration(path) {\n      const functionDeclaration = path.node.declarations.find((decl) => {\n        return (\n          decl.init?.type === 'ArrowFunctionExpression' ||\n          decl.init?.type === 'FunctionExpression'\n        )\n      })\n      if (!functionDeclaration) {\n        return\n      }\n      const propsName = getPropsNameFromFunctionDeclaration(functionDeclaration)\n\n      path.traverse({\n        JSXOpeningElement(element) {\n          const transformed = transformJSX(\n            element,\n            propsName,\n            file,\n            ignorePatterns,\n          )\n          if (transformed) {\n            didTransform = true\n          }\n        },\n      })\n    },\n  })\n\n  return didTransform\n}\n\nexport function addSourceToJsx(\n  code: string,\n  id: string,\n  ignore: {\n    files?: Array<string | RegExp>\n    components?: Array<string | RegExp>\n  } = {},\n) {\n  const [filePath] = id.split('?')\n  // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n  const location = filePath?.replace(normalizePath(process.cwd()), '')!\n\n  const fileIgnored = matcher(ignore.files || [], location)\n  if (fileIgnored) {\n    return\n  }\n  try {\n    const ast = parse(code, {\n      sourceType: 'module',\n      plugins: ['jsx', 'typescript'],\n    })\n    const didTransform = transform(ast, location, ignore.components || [])\n    if (!didTransform) {\n      return\n    }\n    return gen(ast, {\n      sourceMaps: true,\n      retainLines: true,\n      filename: id,\n      sourceFileName: filePath,\n    })\n  } catch (e) {\n    return\n  }\n}\n"],"names":[],"mappings":"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"}