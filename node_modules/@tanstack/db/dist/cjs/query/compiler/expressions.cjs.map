{"version":3,"file":"expressions.cjs","sources":["../../../../src/query/compiler/expressions.ts"],"sourcesContent":["import { Func, PropRef, Value } from '../ir.js'\nimport type { BasicExpression, OrderBy } from '../ir.js'\n\n/**\n * Normalizes a WHERE clause expression by removing table aliases from property references.\n *\n * This function recursively traverses an expression tree and creates new BasicExpression\n * instances with normalized paths. The main transformation is removing the collection alias\n * from property reference paths (e.g., `['user', 'id']` becomes `['id']` when `collectionAlias`\n * is `'user'`), which is needed when converting query-level expressions to collection-level\n * expressions for subscriptions.\n *\n * @param whereClause - The WHERE clause expression to normalize\n * @param collectionAlias - The alias of the collection being filtered (to strip from paths)\n * @returns A new BasicExpression with normalized paths\n *\n * @example\n * // Input: ref with path ['user', 'id'] where collectionAlias is 'user'\n * // Output: ref with path ['id']\n */\nexport function normalizeExpressionPaths(\n  whereClause: BasicExpression<boolean>,\n  collectionAlias: string,\n): BasicExpression<boolean> {\n  const tpe = whereClause.type\n  if (tpe === `val`) {\n    return new Value(whereClause.value)\n  } else if (tpe === `ref`) {\n    const path = whereClause.path\n    if (Array.isArray(path)) {\n      if (path[0] === collectionAlias && path.length > 1) {\n        // Remove the table alias from the path for single-collection queries\n        return new PropRef(path.slice(1))\n      } else if (path.length === 1 && path[0] !== undefined) {\n        // Single field reference\n        return new PropRef([path[0]])\n      }\n    }\n    // Fallback for non-array paths\n    return new PropRef(Array.isArray(path) ? path : [String(path)])\n  } else {\n    // Recursively convert all arguments\n    const args: Array<BasicExpression> = []\n    for (const arg of whereClause.args) {\n      const convertedArg = normalizeExpressionPaths(\n        arg as BasicExpression<boolean>,\n        collectionAlias,\n      )\n      args.push(convertedArg)\n    }\n    return new Func(whereClause.name, args)\n  }\n}\n\nexport function normalizeOrderByPaths(\n  orderBy: OrderBy,\n  collectionAlias: string,\n): OrderBy {\n  const normalizedOrderBy = orderBy.map((clause) => {\n    const basicExp = normalizeExpressionPaths(\n      clause.expression,\n      collectionAlias,\n    )\n\n    return {\n      ...clause,\n      expression: basicExp,\n    }\n  })\n\n  return normalizedOrderBy\n}\n"],"names":["Value","PropRef","Func"],"mappings":";;;AAoBO,SAAS,yBACd,aACA,iBAC0B;AAC1B,QAAM,MAAM,YAAY;AACxB,MAAI,QAAQ,OAAO;AACjB,WAAO,IAAIA,GAAAA,MAAM,YAAY,KAAK;AAAA,EACpC,WAAW,QAAQ,OAAO;AACxB,UAAM,OAAO,YAAY;AACzB,QAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,UAAI,KAAK,CAAC,MAAM,mBAAmB,KAAK,SAAS,GAAG;AAElD,eAAO,IAAIC,GAAAA,QAAQ,KAAK,MAAM,CAAC,CAAC;AAAA,MAClC,WAAW,KAAK,WAAW,KAAK,KAAK,CAAC,MAAM,QAAW;AAErD,eAAO,IAAIA,GAAAA,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;AAAA,MAC9B;AAAA,IACF;AAEA,WAAO,IAAIA,GAAAA,QAAQ,MAAM,QAAQ,IAAI,IAAI,OAAO,CAAC,OAAO,IAAI,CAAC,CAAC;AAAA,EAChE,OAAO;AAEL,UAAM,OAA+B,CAAA;AACrC,eAAW,OAAO,YAAY,MAAM;AAClC,YAAM,eAAe;AAAA,QACnB;AAAA,QACA;AAAA,MAAA;AAEF,WAAK,KAAK,YAAY;AAAA,IACxB;AACA,WAAO,IAAIC,GAAAA,KAAK,YAAY,MAAM,IAAI;AAAA,EACxC;AACF;AAEO,SAAS,sBACd,SACA,iBACS;AACT,QAAM,oBAAoB,QAAQ,IAAI,CAAC,WAAW;AAChD,UAAM,WAAW;AAAA,MACf,OAAO;AAAA,MACP;AAAA,IAAA;AAGF,WAAO;AAAA,MACL,GAAG;AAAA,MACH,YAAY;AAAA,IAAA;AAAA,EAEhB,CAAC;AAED,SAAO;AACT;;;"}