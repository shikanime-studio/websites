{"version":3,"file":"ref-proxy.cjs","sources":["../../../../src/query/builder/ref-proxy.ts"],"sourcesContent":["import { PropRef, Value } from '../ir.js'\nimport type { BasicExpression } from '../ir.js'\nimport type { RefLeaf } from './types.js'\n\nexport interface RefProxy<T = any> {\n  /** @internal */\n  readonly __refProxy: true\n  /** @internal */\n  readonly __path: Array<string>\n  /** @internal */\n  readonly __type: T\n}\n\n/**\n * Type for creating a RefProxy for a single row/type without namespacing\n * Used in collection indexes and where clauses\n */\nexport type SingleRowRefProxy<T> =\n  T extends Record<string, any>\n    ? {\n        [K in keyof T]: T[K] extends Record<string, any>\n          ? SingleRowRefProxy<T[K]> & RefProxy<T[K]>\n          : RefLeaf<T[K]>\n      } & RefProxy<T>\n    : RefProxy<T>\n\n/**\n * Creates a proxy object that records property access paths for a single row\n * Used in collection indexes and where clauses\n */\nexport function createSingleRowRefProxy<\n  T extends Record<string, any>,\n>(): SingleRowRefProxy<T> {\n  const cache = new Map<string, any>()\n\n  function createProxy(path: Array<string>): any {\n    const pathKey = path.join(`.`)\n    if (cache.has(pathKey)) {\n      return cache.get(pathKey)\n    }\n\n    const proxy = new Proxy({} as any, {\n      get(target, prop, receiver) {\n        if (prop === `__refProxy`) return true\n        if (prop === `__path`) return path\n        if (prop === `__type`) return undefined // Type is only for TypeScript inference\n        if (typeof prop === `symbol`) return Reflect.get(target, prop, receiver)\n\n        const newPath = [...path, String(prop)]\n        return createProxy(newPath)\n      },\n\n      has(target, prop) {\n        if (prop === `__refProxy` || prop === `__path` || prop === `__type`)\n          return true\n        return Reflect.has(target, prop)\n      },\n\n      ownKeys(target) {\n        return Reflect.ownKeys(target)\n      },\n\n      getOwnPropertyDescriptor(target, prop) {\n        if (prop === `__refProxy` || prop === `__path` || prop === `__type`) {\n          return { enumerable: false, configurable: true }\n        }\n        return Reflect.getOwnPropertyDescriptor(target, prop)\n      },\n    })\n\n    cache.set(pathKey, proxy)\n    return proxy\n  }\n\n  // Return the root proxy that starts with an empty path\n  return createProxy([]) as SingleRowRefProxy<T>\n}\n\n/**\n * Creates a proxy object that records property access paths\n * Used in callbacks like where, select, etc. to create type-safe references\n */\nexport function createRefProxy<T extends Record<string, any>>(\n  aliases: Array<string>,\n): RefProxy<T> & T {\n  const cache = new Map<string, any>()\n  let accessId = 0 // Monotonic counter to record evaluation order\n\n  function createProxy(path: Array<string>): any {\n    const pathKey = path.join(`.`)\n    if (cache.has(pathKey)) {\n      return cache.get(pathKey)\n    }\n\n    const proxy = new Proxy({} as any, {\n      get(target, prop, receiver) {\n        if (prop === `__refProxy`) return true\n        if (prop === `__path`) return path\n        if (prop === `__type`) return undefined // Type is only for TypeScript inference\n        if (typeof prop === `symbol`) return Reflect.get(target, prop, receiver)\n\n        const newPath = [...path, String(prop)]\n        return createProxy(newPath)\n      },\n\n      has(target, prop) {\n        if (prop === `__refProxy` || prop === `__path` || prop === `__type`)\n          return true\n        return Reflect.has(target, prop)\n      },\n\n      ownKeys(target) {\n        const id = ++accessId\n        const sentinelKey = `__SPREAD_SENTINEL__${path.join(`.`)}__${id}`\n        if (!Object.prototype.hasOwnProperty.call(target, sentinelKey)) {\n          Object.defineProperty(target, sentinelKey, {\n            enumerable: true,\n            configurable: true,\n            value: true,\n          })\n        }\n        return Reflect.ownKeys(target)\n      },\n\n      getOwnPropertyDescriptor(target, prop) {\n        if (prop === `__refProxy` || prop === `__path` || prop === `__type`) {\n          return { enumerable: false, configurable: true }\n        }\n        return Reflect.getOwnPropertyDescriptor(target, prop)\n      },\n    })\n\n    cache.set(pathKey, proxy)\n    return proxy\n  }\n\n  // Create the root proxy with all aliases as top-level properties\n  const rootProxy = new Proxy({} as any, {\n    get(target, prop, receiver) {\n      if (prop === `__refProxy`) return true\n      if (prop === `__path`) return []\n      if (prop === `__type`) return undefined // Type is only for TypeScript inference\n      if (typeof prop === `symbol`) return Reflect.get(target, prop, receiver)\n\n      const propStr = String(prop)\n      if (aliases.includes(propStr)) {\n        return createProxy([propStr])\n      }\n\n      return undefined\n    },\n\n    has(target, prop) {\n      if (prop === `__refProxy` || prop === `__path` || prop === `__type`)\n        return true\n      if (typeof prop === `string` && aliases.includes(prop)) return true\n      return Reflect.has(target, prop)\n    },\n\n    ownKeys(_target) {\n      return [...aliases, `__refProxy`, `__path`, `__type`]\n    },\n\n    getOwnPropertyDescriptor(target, prop) {\n      if (prop === `__refProxy` || prop === `__path` || prop === `__type`) {\n        return { enumerable: false, configurable: true }\n      }\n      if (typeof prop === `string` && aliases.includes(prop)) {\n        return { enumerable: true, configurable: true }\n      }\n      return undefined\n    },\n  })\n\n  return rootProxy\n}\n\n/**\n * Converts a value to an Expression\n * If it's a RefProxy, creates a Ref, otherwise creates a Value\n */\nexport function toExpression<T = any>(value: T): BasicExpression<T>\nexport function toExpression(value: RefProxy<any>): BasicExpression<any>\nexport function toExpression(value: any): BasicExpression<any> {\n  if (isRefProxy(value)) {\n    return new PropRef(value.__path)\n  }\n  // If it's already an Expression (Func, Ref, Value) or Agg, return it directly\n  if (\n    value &&\n    typeof value === `object` &&\n    `type` in value &&\n    (value.type === `func` ||\n      value.type === `ref` ||\n      value.type === `val` ||\n      value.type === `agg`)\n  ) {\n    return value\n  }\n  return new Value(value)\n}\n\n/**\n * Type guard to check if a value is a RefProxy\n */\nexport function isRefProxy(value: any): value is RefProxy {\n  return value && typeof value === `object` && value.__refProxy === true\n}\n\n/**\n * Helper to create a Value expression from a literal\n */\nexport function val<T>(value: T): BasicExpression<T> {\n  return new Value(value)\n}\n"],"names":["PropRef","Value"],"mappings":";;;AA8BO,SAAS,0BAEU;AACxB,QAAM,4BAAY,IAAA;AAElB,WAAS,YAAY,MAA0B;AAC7C,UAAM,UAAU,KAAK,KAAK,GAAG;AAC7B,QAAI,MAAM,IAAI,OAAO,GAAG;AACtB,aAAO,MAAM,IAAI,OAAO;AAAA,IAC1B;AAEA,UAAM,QAAQ,IAAI,MAAM,IAAW;AAAA,MACjC,IAAI,QAAQ,MAAM,UAAU;AAC1B,YAAI,SAAS,aAAc,QAAO;AAClC,YAAI,SAAS,SAAU,QAAO;AAC9B,YAAI,SAAS,SAAU,QAAO;AAC9B,YAAI,OAAO,SAAS,SAAU,QAAO,QAAQ,IAAI,QAAQ,MAAM,QAAQ;AAEvE,cAAM,UAAU,CAAC,GAAG,MAAM,OAAO,IAAI,CAAC;AACtC,eAAO,YAAY,OAAO;AAAA,MAC5B;AAAA,MAEA,IAAI,QAAQ,MAAM;AAChB,YAAI,SAAS,gBAAgB,SAAS,YAAY,SAAS;AACzD,iBAAO;AACT,eAAO,QAAQ,IAAI,QAAQ,IAAI;AAAA,MACjC;AAAA,MAEA,QAAQ,QAAQ;AACd,eAAO,QAAQ,QAAQ,MAAM;AAAA,MAC/B;AAAA,MAEA,yBAAyB,QAAQ,MAAM;AACrC,YAAI,SAAS,gBAAgB,SAAS,YAAY,SAAS,UAAU;AACnE,iBAAO,EAAE,YAAY,OAAO,cAAc,KAAA;AAAA,QAC5C;AACA,eAAO,QAAQ,yBAAyB,QAAQ,IAAI;AAAA,MACtD;AAAA,IAAA,CACD;AAED,UAAM,IAAI,SAAS,KAAK;AACxB,WAAO;AAAA,EACT;AAGA,SAAO,YAAY,CAAA,CAAE;AACvB;AAMO,SAAS,eACd,SACiB;AACjB,QAAM,4BAAY,IAAA;AAClB,MAAI,WAAW;AAEf,WAAS,YAAY,MAA0B;AAC7C,UAAM,UAAU,KAAK,KAAK,GAAG;AAC7B,QAAI,MAAM,IAAI,OAAO,GAAG;AACtB,aAAO,MAAM,IAAI,OAAO;AAAA,IAC1B;AAEA,UAAM,QAAQ,IAAI,MAAM,IAAW;AAAA,MACjC,IAAI,QAAQ,MAAM,UAAU;AAC1B,YAAI,SAAS,aAAc,QAAO;AAClC,YAAI,SAAS,SAAU,QAAO;AAC9B,YAAI,SAAS,SAAU,QAAO;AAC9B,YAAI,OAAO,SAAS,SAAU,QAAO,QAAQ,IAAI,QAAQ,MAAM,QAAQ;AAEvE,cAAM,UAAU,CAAC,GAAG,MAAM,OAAO,IAAI,CAAC;AACtC,eAAO,YAAY,OAAO;AAAA,MAC5B;AAAA,MAEA,IAAI,QAAQ,MAAM;AAChB,YAAI,SAAS,gBAAgB,SAAS,YAAY,SAAS;AACzD,iBAAO;AACT,eAAO,QAAQ,IAAI,QAAQ,IAAI;AAAA,MACjC;AAAA,MAEA,QAAQ,QAAQ;AACd,cAAM,KAAK,EAAE;AACb,cAAM,cAAc,sBAAsB,KAAK,KAAK,GAAG,CAAC,KAAK,EAAE;AAC/D,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,QAAQ,WAAW,GAAG;AAC9D,iBAAO,eAAe,QAAQ,aAAa;AAAA,YACzC,YAAY;AAAA,YACZ,cAAc;AAAA,YACd,OAAO;AAAA,UAAA,CACR;AAAA,QACH;AACA,eAAO,QAAQ,QAAQ,MAAM;AAAA,MAC/B;AAAA,MAEA,yBAAyB,QAAQ,MAAM;AACrC,YAAI,SAAS,gBAAgB,SAAS,YAAY,SAAS,UAAU;AACnE,iBAAO,EAAE,YAAY,OAAO,cAAc,KAAA;AAAA,QAC5C;AACA,eAAO,QAAQ,yBAAyB,QAAQ,IAAI;AAAA,MACtD;AAAA,IAAA,CACD;AAED,UAAM,IAAI,SAAS,KAAK;AACxB,WAAO;AAAA,EACT;AAGA,QAAM,YAAY,IAAI,MAAM,IAAW;AAAA,IACrC,IAAI,QAAQ,MAAM,UAAU;AAC1B,UAAI,SAAS,aAAc,QAAO;AAClC,UAAI,SAAS,SAAU,QAAO,CAAA;AAC9B,UAAI,SAAS,SAAU,QAAO;AAC9B,UAAI,OAAO,SAAS,SAAU,QAAO,QAAQ,IAAI,QAAQ,MAAM,QAAQ;AAEvE,YAAM,UAAU,OAAO,IAAI;AAC3B,UAAI,QAAQ,SAAS,OAAO,GAAG;AAC7B,eAAO,YAAY,CAAC,OAAO,CAAC;AAAA,MAC9B;AAEA,aAAO;AAAA,IACT;AAAA,IAEA,IAAI,QAAQ,MAAM;AAChB,UAAI,SAAS,gBAAgB,SAAS,YAAY,SAAS;AACzD,eAAO;AACT,UAAI,OAAO,SAAS,YAAY,QAAQ,SAAS,IAAI,EAAG,QAAO;AAC/D,aAAO,QAAQ,IAAI,QAAQ,IAAI;AAAA,IACjC;AAAA,IAEA,QAAQ,SAAS;AACf,aAAO,CAAC,GAAG,SAAS,cAAc,UAAU,QAAQ;AAAA,IACtD;AAAA,IAEA,yBAAyB,QAAQ,MAAM;AACrC,UAAI,SAAS,gBAAgB,SAAS,YAAY,SAAS,UAAU;AACnE,eAAO,EAAE,YAAY,OAAO,cAAc,KAAA;AAAA,MAC5C;AACA,UAAI,OAAO,SAAS,YAAY,QAAQ,SAAS,IAAI,GAAG;AACtD,eAAO,EAAE,YAAY,MAAM,cAAc,KAAA;AAAA,MAC3C;AACA,aAAO;AAAA,IACT;AAAA,EAAA,CACD;AAED,SAAO;AACT;AAQO,SAAS,aAAa,OAAkC;AAC7D,MAAI,WAAW,KAAK,GAAG;AACrB,WAAO,IAAIA,GAAAA,QAAQ,MAAM,MAAM;AAAA,EACjC;AAEA,MACE,SACA,OAAO,UAAU,YACjB,UAAU,UACT,MAAM,SAAS,UACd,MAAM,SAAS,SACf,MAAM,SAAS,SACf,MAAM,SAAS,QACjB;AACA,WAAO;AAAA,EACT;AACA,SAAO,IAAIC,GAAAA,MAAM,KAAK;AACxB;AAKO,SAAS,WAAW,OAA+B;AACxD,SAAO,SAAS,OAAO,UAAU,YAAY,MAAM,eAAe;AACpE;;;;;"}