{"version":3,"file":"queueStrategy.cjs","sources":["../../../src/strategies/queueStrategy.ts"],"sourcesContent":["import { LiteQueuer } from '@tanstack/pacer-lite/lite-queuer'\nimport type { QueueStrategy, QueueStrategyOptions } from './types'\nimport type { Transaction } from '../transactions'\n\n/**\n * Creates a queue strategy that processes all mutations in order with proper serialization.\n *\n * Unlike other strategies that may drop executions, queue ensures every\n * mutation is processed sequentially. Each transaction commit completes before\n * the next one starts. Useful when data consistency is critical and\n * every operation must complete in order.\n *\n * @param options - Configuration for queue behavior (FIFO/LIFO, timing, size limits)\n * @returns A queue strategy instance\n *\n * @example\n * ```ts\n * // FIFO queue - process in order received\n * const mutate = usePacedMutations({\n *   mutationFn: async ({ transaction }) => {\n *     await api.save(transaction.mutations)\n *   },\n *   strategy: queueStrategy({\n *     wait: 200,\n *     addItemsTo: 'back',\n *     getItemsFrom: 'front'\n *   })\n * })\n * ```\n *\n * @example\n * ```ts\n * // LIFO queue - process most recent first\n * const mutate = usePacedMutations({\n *   mutationFn: async ({ transaction }) => {\n *     await api.save(transaction.mutations)\n *   },\n *   strategy: queueStrategy({\n *     wait: 200,\n *     addItemsTo: 'back',\n *     getItemsFrom: 'back'\n *   })\n * })\n * ```\n */\nexport function queueStrategy(options?: QueueStrategyOptions): QueueStrategy {\n  // Manual promise chaining to ensure async serialization\n  // LiteQueuer (unlike AsyncQueuer from @tanstack/pacer) lacks built-in async queue\n  // primitives and concurrency control. We compensate by manually chaining promises\n  // to ensure each transaction completes before the next one starts.\n  let processingChain = Promise.resolve()\n\n  const queuer = new LiteQueuer<() => Transaction>(\n    (fn) => {\n      // Chain each transaction to the previous one's completion\n      processingChain = processingChain\n        .then(async () => {\n          const transaction = fn()\n          // Wait for the transaction to be persisted before processing next item\n          await transaction.isPersisted.promise\n        })\n        .catch(() => {\n          // Errors are handled via transaction.isPersisted.promise and surfaced there.\n          // This catch prevents unhandled promise rejections from breaking the chain,\n          // ensuring subsequent transactions can still execute even if one fails.\n        })\n    },\n    {\n      wait: options?.wait ?? 0,\n      maxSize: options?.maxSize,\n      addItemsTo: options?.addItemsTo ?? `back`, // Default FIFO: add to back\n      getItemsFrom: options?.getItemsFrom ?? `front`, // Default FIFO: get from front\n      started: true, // Start processing immediately\n    },\n  )\n\n  return {\n    _type: `queue`,\n    options,\n    execute: <T extends object = Record<string, unknown>>(\n      fn: () => Transaction<T>,\n    ) => {\n      // Add the transaction-creating function to the queue\n      queuer.addItem(fn as () => Transaction)\n    },\n    cleanup: () => {\n      queuer.stop()\n      queuer.clear()\n    },\n  }\n}\n"],"names":["LiteQueuer"],"mappings":";;;AA6CO,SAAS,cAAc,SAA+C;AAK3E,MAAI,kBAAkB,QAAQ,QAAA;AAE9B,QAAM,SAAS,IAAIA,WAAAA;AAAAA,IACjB,CAAC,OAAO;AAEN,wBAAkB,gBACf,KAAK,YAAY;AAChB,cAAM,cAAc,GAAA;AAEpB,cAAM,YAAY,YAAY;AAAA,MAChC,CAAC,EACA,MAAM,MAAM;AAAA,MAIb,CAAC;AAAA,IACL;AAAA,IACA;AAAA,MACE,MAAM,SAAS,QAAQ;AAAA,MACvB,SAAS,SAAS;AAAA,MAClB,YAAY,SAAS,cAAc;AAAA;AAAA,MACnC,cAAc,SAAS,gBAAgB;AAAA;AAAA,MACvC,SAAS;AAAA;AAAA,IAAA;AAAA,EACX;AAGF,SAAO;AAAA,IACL,OAAO;AAAA,IACP;AAAA,IACA,SAAS,CACP,OACG;AAEH,aAAO,QAAQ,EAAuB;AAAA,IACxC;AAAA,IACA,SAAS,MAAM;AACb,aAAO,KAAA;AACP,aAAO,MAAA;AAAA,IACT;AAAA,EAAA;AAEJ;;"}