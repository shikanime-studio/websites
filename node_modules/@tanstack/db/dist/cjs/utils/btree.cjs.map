{"version":3,"file":"btree.cjs","sources":["../../../src/utils/btree.ts"],"sourcesContent":["// This file was copied from https://github.com/qwertie/btree-typescript/tree/master and adapted to our needs.\n// We removed methods that we don't need.\n\n// B+ tree by David Piepgrass. License: MIT\ntype EditRangeResult<V, R = number> = {\n  value?: V\n  break?: R\n  delete?: boolean\n}\n\ntype index = number\n\n// Informative microbenchmarks & stuff:\n// http://www.jayconrod.com/posts/52/a-tour-of-v8-object-representation (very educational)\n// https://blog.mozilla.org/luke/2012/10/02/optimizing-javascript-variable-access/ (local vars are faster than properties)\n// http://benediktmeurer.de/2017/12/13/an-introduction-to-speculative-optimization-in-v8/ (other stuff)\n// https://jsperf.com/js-in-operator-vs-alternatives (avoid 'in' operator; `.p!==undefined` faster than `hasOwnProperty('p')` in all browsers)\n// https://jsperf.com/instanceof-vs-typeof-vs-constructor-vs-member (speed of type tests varies wildly across browsers)\n// https://jsperf.com/detecting-arrays-new (a.constructor===Array is best across browsers, assuming a is an object)\n// https://jsperf.com/shallow-cloning-methods (a constructor is faster than Object.create; hand-written clone faster than Object.assign)\n// https://jsperf.com/ways-to-fill-an-array (slice-and-replace is fastest)\n// https://jsperf.com/math-min-max-vs-ternary-vs-if (Math.min/max is slow on Edge)\n// https://jsperf.com/array-vs-property-access-speed (v.x/v.y is faster than a[0]/a[1] in major browsers IF hidden class is constant)\n// https://jsperf.com/detect-not-null-or-undefined (`x==null` slightly slower than `x===null||x===undefined` on all browsers)\n// Overall, microbenchmarks suggest Firefox is the fastest browser for JavaScript and Edge is the slowest.\n// Lessons from https://v8project.blogspot.com/2017/09/elements-kinds-in-v8.html:\n//   - Avoid holes in arrays. Avoid `new Array(N)`, it will be \"holey\" permanently.\n//   - Don't read outside bounds of an array (it scans prototype chain).\n//   - Small integer arrays are stored differently from doubles\n//   - Adding non-numbers to an array deoptimizes it permanently into a general array\n//   - Objects can be used like arrays (e.g. have length property) but are slower\n//   - V8 source (NewElementsCapacity in src/objects.h): arrays grow by 50% + 16 elements\n\n/**\n * A reasonably fast collection of key-value pairs with a powerful API.\n * Largely compatible with the standard Map. BTree is a B+ tree data structure,\n * so the collection is sorted by key.\n *\n * B+ trees tend to use memory more efficiently than hashtables such as the\n * standard Map, especially when the collection contains a large number of\n * items. However, maintaining the sort order makes them modestly slower:\n * O(log size) rather than O(1). This B+ tree implementation supports O(1)\n * fast cloning. It also supports freeze(), which can be used to ensure that\n * a BTree is not changed accidentally.\n *\n * Confusingly, the ES6 Map.forEach(c) method calls c(value,key) instead of\n * c(key,value), in contrast to other methods such as set() and entries()\n * which put the key first. I can only assume that the order was reversed on\n * the theory that users would usually want to examine values and ignore keys.\n * BTree's forEach() therefore works the same way, but a second method\n * `.forEachPair((key,value)=>{...})` is provided which sends you the key\n * first and the value second; this method is slightly faster because it is\n * the \"native\" for-each method for this class.\n *\n * Out of the box, BTree supports keys that are numbers, strings, arrays of\n * numbers/strings, Date, and objects that have a valueOf() method returning a\n * number or string. Other data types, such as arrays of Date or custom\n * objects, require a custom comparator, which you must pass as the second\n * argument to the constructor (the first argument is an optional list of\n * initial items). Symbols cannot be used as keys because they are unordered\n * (one Symbol is never \"greater\" or \"less\" than another).\n *\n * @example\n * Given a {name: string, age: number} object, you can create a tree sorted by\n * name and then by age like this:\n *\n *     var tree = new BTree(undefined, (a, b) => {\n *       if (a.name > b.name)\n *         return 1; // Return a number >0 when a > b\n *       else if (a.name < b.name)\n *         return -1; // Return a number <0 when a < b\n *       else // names are equal (or incomparable)\n *         return a.age - b.age; // Return >0 when a.age > b.age\n *     });\n *\n *     tree.set({name:\"Bill\", age:17}, \"happy\");\n *     tree.set({name:\"Fran\", age:40}, \"busy & stressed\");\n *     tree.set({name:\"Bill\", age:55}, \"recently laid off\");\n *     tree.forEachPair((k, v) => {\n *       console.log(`Name: ${k.name} Age: ${k.age} Status: ${v}`);\n *     });\n *\n * @description\n * The \"range\" methods (`forEach, forRange, editRange`) will return the number\n * of elements that were scanned. In addition, the callback can return {break:R}\n * to stop early and return R from the outer function.\n *\n * - TODO: Test performance of preallocating values array at max size\n * - TODO: Add fast initialization when a sorted array is provided to constructor\n *\n * For more documentation see https://github.com/qwertie/btree-typescript\n *\n * Are you a C# developer? You might like the similar data structures I made for C#:\n * BDictionary, BList, etc. See http://core.loyc.net/collections/\n *\n * @author David Piepgrass\n */\nexport class BTree<K = any, V = any> {\n  private _root: BNode<K, V> = EmptyLeaf as BNode<K, V>\n  _size = 0\n  _maxNodeSize: number\n\n  /**\n   * provides a total order over keys (and a strict partial order over the type K)\n   * @returns a negative value if a < b, 0 if a === b and a positive value if a > b\n   */\n  _compare: (a: K, b: K) => number\n\n  /**\n   * Initializes an empty B+ tree.\n   * @param compare Custom function to compare pairs of elements in the tree.\n   *   If not specified, defaultComparator will be used which is valid as long as K extends DefaultComparable.\n   * @param entries A set of key-value pairs to initialize the tree\n   * @param maxNodeSize Branching factor (maximum items or children per node)\n   *   Must be in range 4..256. If undefined or <4 then default is used; if >256 then 256.\n   */\n  public constructor(\n    compare: (a: K, b: K) => number,\n    entries?: Array<[K, V]>,\n    maxNodeSize?: number,\n  ) {\n    this._maxNodeSize = maxNodeSize! >= 4 ? Math.min(maxNodeSize!, 256) : 32\n    this._compare = compare\n    if (entries) this.setPairs(entries)\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // ES6 Map<K,V> methods /////////////////////////////////////////////////////\n\n  /** Gets the number of key-value pairs in the tree. */\n  get size() {\n    return this._size\n  }\n  /** Gets the number of key-value pairs in the tree. */\n  get length() {\n    return this._size\n  }\n  /** Returns true iff the tree contains no key-value pairs. */\n  get isEmpty() {\n    return this._size === 0\n  }\n\n  /** Releases the tree so that its size is 0. */\n  clear() {\n    this._root = EmptyLeaf as BNode<K, V>\n    this._size = 0\n  }\n\n  /**\n   * Finds a pair in the tree and returns the associated value.\n   * @param defaultValue a value to return if the key was not found.\n   * @returns the value, or defaultValue if the key was not found.\n   * @description Computational complexity: O(log size)\n   */\n  get(key: K, defaultValue?: V): V | undefined {\n    return this._root.get(key, defaultValue, this)\n  }\n\n  /**\n   * Adds or overwrites a key-value pair in the B+ tree.\n   * @param key the key is used to determine the sort order of\n   *        data in the tree.\n   * @param value data to associate with the key (optional)\n   * @param overwrite Whether to overwrite an existing key-value pair\n   *        (default: true). If this is false and there is an existing\n   *        key-value pair then this method has no effect.\n   * @returns true if a new key-value pair was added.\n   * @description Computational complexity: O(log size)\n   * Note: when overwriting a previous entry, the key is updated\n   * as well as the value. This has no effect unless the new key\n   * has data that does not affect its sort order.\n   */\n  set(key: K, value: V, overwrite?: boolean): boolean {\n    if (this._root.isShared) this._root = this._root.clone()\n    const result = this._root.set(key, value, overwrite, this)\n    if (result === true || result === false) return result\n    // Root node has split, so create a new root node.\n    this._root = new BNodeInternal<K, V>([this._root, result])\n    return true\n  }\n\n  /**\n   * Returns true if the key exists in the B+ tree, false if not.\n   * Use get() for best performance; use has() if you need to\n   * distinguish between \"undefined value\" and \"key not present\".\n   * @param key Key to detect\n   * @description Computational complexity: O(log size)\n   */\n  has(key: K): boolean {\n    return this.forRange(key, key, true, undefined) !== 0\n  }\n\n  /**\n   * Removes a single key-value pair from the B+ tree.\n   * @param key Key to find\n   * @returns true if a pair was found and removed, false otherwise.\n   * @description Computational complexity: O(log size)\n   */\n  delete(key: K): boolean {\n    return this.editRange(key, key, true, DeleteRange) !== 0\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // Additional methods ///////////////////////////////////////////////////////\n\n  /** Returns the maximum number of children/values before nodes will split. */\n  get maxNodeSize() {\n    return this._maxNodeSize\n  }\n\n  /** Gets the lowest key in the tree. Complexity: O(log size) */\n  minKey(): K | undefined {\n    return this._root.minKey()\n  }\n\n  /** Gets the highest key in the tree. Complexity: O(1) */\n  maxKey(): K | undefined {\n    return this._root.maxKey()\n  }\n\n  /** Gets an array of all keys, sorted */\n  keysArray() {\n    const results: Array<K> = []\n    this._root.forRange(\n      this.minKey()!,\n      this.maxKey()!,\n      true,\n      false,\n      this,\n      0,\n      (k, _v) => {\n        results.push(k)\n      },\n    )\n    return results\n  }\n\n  /** Returns the next pair whose key is larger than the specified key (or undefined if there is none).\n   * If key === undefined, this function returns the lowest pair.\n   * @param key The key to search for.\n   * @param reusedArray Optional array used repeatedly to store key-value pairs, to\n   * avoid creating a new array on every iteration.\n   */\n  nextHigherPair(key: K | undefined, reusedArray?: [K, V]): [K, V] | undefined {\n    reusedArray = reusedArray || ([] as unknown as [K, V])\n    if (key === undefined) {\n      return this._root.minPair(reusedArray)\n    }\n    return this._root.getPairOrNextHigher(\n      key,\n      this._compare,\n      false,\n      reusedArray,\n    )\n  }\n\n  /** Returns the next key larger than the specified key, or undefined if there is none.\n   *  Also, nextHigherKey(undefined) returns the lowest key.\n   */\n  nextHigherKey(key: K | undefined): K | undefined {\n    const p = this.nextHigherPair(key, ReusedArray as [K, V])\n    return p && p[0]\n  }\n\n  /** Returns the next pair whose key is smaller than the specified key (or undefined if there is none).\n   *  If key === undefined, this function returns the highest pair.\n   * @param key The key to search for.\n   * @param reusedArray Optional array used repeatedly to store key-value pairs, to\n   *        avoid creating a new array each time you call this method.\n   */\n  nextLowerPair(key: K | undefined, reusedArray?: [K, V]): [K, V] | undefined {\n    reusedArray = reusedArray || ([] as unknown as [K, V])\n    if (key === undefined) {\n      return this._root.maxPair(reusedArray)\n    }\n    return this._root.getPairOrNextLower(key, this._compare, false, reusedArray)\n  }\n\n  /** Returns the next key smaller than the specified key, or undefined if there is none.\n   *  Also, nextLowerKey(undefined) returns the highest key.\n   */\n  nextLowerKey(key: K | undefined): K | undefined {\n    const p = this.nextLowerPair(key, ReusedArray as [K, V])\n    return p && p[0]\n  }\n\n  /** Adds all pairs from a list of key-value pairs.\n   * @param pairs Pairs to add to this tree. If there are duplicate keys,\n   *        later pairs currently overwrite earlier ones (e.g. [[0,1],[0,7]]\n   *        associates 0 with 7.)\n   * @param overwrite Whether to overwrite pairs that already exist (if false,\n   *        pairs[i] is ignored when the key pairs[i][0] already exists.)\n   * @returns The number of pairs added to the collection.\n   * @description Computational complexity: O(pairs.length * log(size + pairs.length))\n   */\n  setPairs(pairs: Array<[K, V]>, overwrite?: boolean): number {\n    let added = 0\n    for (const pair of pairs) {\n      if (this.set(pair[0], pair[1], overwrite)) added++\n    }\n    return added\n  }\n\n  forRange(\n    low: K,\n    high: K,\n    includeHigh: boolean,\n    onFound?: (k: K, v: V, counter: number) => void,\n    initialCounter?: number,\n  ): number\n\n  /**\n   * Scans the specified range of keys, in ascending order by key.\n   * Note: the callback `onFound` must not insert or remove items in the\n   * collection. Doing so may cause incorrect data to be sent to the\n   * callback afterward.\n   * @param low The first key scanned will be greater than or equal to `low`.\n   * @param high Scanning stops when a key larger than this is reached.\n   * @param includeHigh If the `high` key is present, `onFound` is called for\n   *        that final pair if and only if this parameter is true.\n   * @param onFound A function that is called for each key-value pair. This\n   *        function can return {break:R} to stop early with result R.\n   * @param initialCounter Initial third argument of onFound. This value\n   *        increases by one each time `onFound` is called. Default: 0\n   * @returns The number of values found, or R if the callback returned\n   *        `{break:R}` to stop early.\n   * @description Computational complexity: O(number of items scanned + log size)\n   */\n  forRange<R = number>(\n    low: K,\n    high: K,\n    includeHigh: boolean,\n    onFound?: (k: K, v: V, counter: number) => { break?: R } | void,\n    initialCounter?: number,\n  ): R | number {\n    const r = this._root.forRange(\n      low,\n      high,\n      includeHigh,\n      false,\n      this,\n      initialCounter || 0,\n      onFound,\n    )\n    return typeof r === `number` ? r : r.break!\n  }\n\n  /**\n   * Scans and potentially modifies values for a subsequence of keys.\n   * Note: the callback `onFound` should ideally be a pure function.\n   *   Specfically, it must not insert items, call clone(), or change\n   *   the collection except via return value; out-of-band editing may\n   *   cause an exception or may cause incorrect data to be sent to\n   *   the callback (duplicate or missed items). It must not cause a\n   *   clone() of the collection, otherwise the clone could be modified\n   *   by changes requested by the callback.\n   * @param low The first key scanned will be greater than or equal to `low`.\n   * @param high Scanning stops when a key larger than this is reached.\n   * @param includeHigh If the `high` key is present, `onFound` is called for\n   *        that final pair if and only if this parameter is true.\n   * @param onFound A function that is called for each key-value pair. This\n   *        function can return `{value:v}` to change the value associated\n   *        with the current key, `{delete:true}` to delete the current pair,\n   *        `{break:R}` to stop early with result R, or it can return nothing\n   *        (undefined or {}) to cause no effect and continue iterating.\n   *        `{break:R}` can be combined with one of the other two commands.\n   *        The third argument `counter` is the number of items iterated\n   *        previously; it equals 0 when `onFound` is called the first time.\n   * @returns The number of values scanned, or R if the callback returned\n   *        `{break:R}` to stop early.\n   * @description\n   *   Computational complexity: O(number of items scanned + log size)\n   *   Note: if the tree has been cloned with clone(), any shared\n   *   nodes are copied before `onFound` is called. This takes O(n) time\n   *   where n is proportional to the amount of shared data scanned.\n   */\n  editRange<R = V>(\n    low: K,\n    high: K,\n    includeHigh: boolean,\n    onFound: (k: K, v: V, counter: number) => EditRangeResult<V, R> | void,\n    initialCounter?: number,\n  ): R | number {\n    let root = this._root\n    if (root.isShared) this._root = root = root.clone()\n    try {\n      const r = root.forRange(\n        low,\n        high,\n        includeHigh,\n        true,\n        this,\n        initialCounter || 0,\n        onFound,\n      )\n      return typeof r === `number` ? r : r.break!\n    } finally {\n      let isShared\n      while (root.keys.length <= 1 && !root.isLeaf) {\n        isShared ||= root.isShared\n        this._root = root =\n          root.keys.length === 0\n            ? EmptyLeaf\n            : (root as any as BNodeInternal<K, V>).children[0]!\n      }\n      // If any ancestor of the new root was shared, the new root must also be shared\n      if (isShared) {\n        root.isShared = true\n      }\n    }\n  }\n}\n\n/** Leaf node / base class. **************************************************/\nclass BNode<K, V> {\n  // If this is an internal node, _keys[i] is the highest key in children[i].\n  keys: Array<K>\n  values: Array<V>\n  // True if this node might be within multiple `BTree`s (or have multiple parents).\n  // If so, it must be cloned before being mutated to avoid changing an unrelated tree.\n  // This is transitive: if it's true, children are also shared even if `isShared!=true`\n  // in those children. (Certain operations will propagate isShared=true to children.)\n  isShared: true | undefined\n  get isLeaf() {\n    return (this as any).children === undefined\n  }\n\n  constructor(keys: Array<K> = [], values?: Array<V>) {\n    this.keys = keys\n    this.values = values || undefVals\n    this.isShared = undefined\n  }\n\n  // /////////////////////////////////////////////////////////////////////////\n  // Shared methods /////////////////////////////////////////////////////////\n\n  maxKey() {\n    return this.keys[this.keys.length - 1]\n  }\n\n  // If key not found, returns i^failXor where i is the insertion index.\n  // Callers that don't care whether there was a match will set failXor=0.\n  indexOf(key: K, failXor: number, cmp: (a: K, b: K) => number): index {\n    const keys = this.keys\n    let lo = 0,\n      hi = keys.length,\n      mid = hi >> 1\n    while (lo < hi) {\n      const c = cmp(keys[mid]!, key)\n      if (c < 0) lo = mid + 1\n      else if (c > 0)\n        // key < keys[mid]\n        hi = mid\n      else if (c === 0) return mid\n      else {\n        // c is NaN or otherwise invalid\n        if (key === key)\n          // at least the search key is not NaN\n          return keys.length\n        else throw new Error(`BTree: NaN was used as a key`)\n      }\n      mid = (lo + hi) >> 1\n    }\n    return mid ^ failXor\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // Leaf Node: misc //////////////////////////////////////////////////////////\n\n  minKey(): K | undefined {\n    return this.keys[0]\n  }\n\n  minPair(reusedArray: [K, V]): [K, V] | undefined {\n    if (this.keys.length === 0) return undefined\n    reusedArray[0] = this.keys[0]!\n    reusedArray[1] = this.values[0]!\n    return reusedArray\n  }\n\n  maxPair(reusedArray: [K, V]): [K, V] | undefined {\n    if (this.keys.length === 0) return undefined\n    const lastIndex = this.keys.length - 1\n    reusedArray[0] = this.keys[lastIndex]!\n    reusedArray[1] = this.values[lastIndex]!\n    return reusedArray\n  }\n\n  clone(): BNode<K, V> {\n    const v = this.values\n    return new BNode<K, V>(this.keys.slice(0), v === undefVals ? v : v.slice(0))\n  }\n\n  get(key: K, defaultValue: V | undefined, tree: BTree<K, V>): V | undefined {\n    const i = this.indexOf(key, -1, tree._compare)\n    return i < 0 ? defaultValue : this.values[i]\n  }\n\n  getPairOrNextLower(\n    key: K,\n    compare: (a: K, b: K) => number,\n    inclusive: boolean,\n    reusedArray: [K, V],\n  ): [K, V] | undefined {\n    const i = this.indexOf(key, -1, compare)\n    const indexOrLower = i < 0 ? ~i - 1 : inclusive ? i : i - 1\n    if (indexOrLower >= 0) {\n      reusedArray[0] = this.keys[indexOrLower]!\n      reusedArray[1] = this.values[indexOrLower]!\n      return reusedArray\n    }\n    return undefined\n  }\n\n  getPairOrNextHigher(\n    key: K,\n    compare: (a: K, b: K) => number,\n    inclusive: boolean,\n    reusedArray: [K, V],\n  ): [K, V] | undefined {\n    const i = this.indexOf(key, -1, compare)\n    const indexOrLower = i < 0 ? ~i : inclusive ? i : i + 1\n    const keys = this.keys\n    if (indexOrLower < keys.length) {\n      reusedArray[0] = keys[indexOrLower]!\n      reusedArray[1] = this.values[indexOrLower]!\n      return reusedArray\n    }\n    return undefined\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // Leaf Node: set & node splitting //////////////////////////////////////////\n\n  set(\n    key: K,\n    value: V,\n    overwrite: boolean | undefined,\n    tree: BTree<K, V>,\n  ): boolean | BNode<K, V> {\n    let i = this.indexOf(key, -1, tree._compare)\n    if (i < 0) {\n      // key does not exist yet\n      i = ~i\n      tree._size++\n\n      if (this.keys.length < tree._maxNodeSize) {\n        return this.insertInLeaf(i, key, value, tree)\n      } else {\n        // This leaf node is full and must split\n        const newRightSibling = this.splitOffRightSide()\n        let target: BNode<K, V> = this\n        if (i > this.keys.length) {\n          i -= this.keys.length\n          target = newRightSibling\n        }\n        target.insertInLeaf(i, key, value, tree)\n        return newRightSibling\n      }\n    } else {\n      // Key already exists\n      if (overwrite !== false) {\n        if (value !== undefined) this.reifyValues()\n        // usually this is a no-op, but some users may wish to edit the key\n        this.keys[i] = key\n        this.values[i] = value\n      }\n      return false\n    }\n  }\n\n  reifyValues() {\n    if (this.values === undefVals)\n      return (this.values = this.values.slice(0, this.keys.length))\n    return this.values\n  }\n\n  insertInLeaf(i: index, key: K, value: V, tree: BTree<K, V>) {\n    this.keys.splice(i, 0, key)\n    if (this.values === undefVals) {\n      while (undefVals.length < tree._maxNodeSize) undefVals.push(undefined)\n      if (value === undefined) {\n        return true\n      } else {\n        this.values = undefVals.slice(0, this.keys.length - 1)\n      }\n    }\n    this.values.splice(i, 0, value)\n    return true\n  }\n\n  takeFromRight(rhs: BNode<K, V>) {\n    // Reminder: parent node must update its copy of key for this node\n    // assert: neither node is shared\n    // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)\n    let v = this.values\n    if (rhs.values === undefVals) {\n      if (v !== undefVals) v.push(undefined as any)\n    } else {\n      v = this.reifyValues()\n      v.push(rhs.values.shift()!)\n    }\n    this.keys.push(rhs.keys.shift()!)\n  }\n\n  takeFromLeft(lhs: BNode<K, V>) {\n    // Reminder: parent node must update its copy of key for this node\n    // assert: neither node is shared\n    // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)\n    let v = this.values\n    if (lhs.values === undefVals) {\n      if (v !== undefVals) v.unshift(undefined as any)\n    } else {\n      v = this.reifyValues()\n      v.unshift(lhs.values.pop()!)\n    }\n    this.keys.unshift(lhs.keys.pop()!)\n  }\n\n  splitOffRightSide(): BNode<K, V> {\n    // Reminder: parent node must update its copy of key for this node\n    const half = this.keys.length >> 1,\n      keys = this.keys.splice(half)\n    const values =\n      this.values === undefVals ? undefVals : this.values.splice(half)\n    return new BNode<K, V>(keys, values)\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // Leaf Node: scanning & deletions //////////////////////////////////////////\n\n  forRange<R>(\n    low: K,\n    high: K,\n    includeHigh: boolean | undefined,\n    editMode: boolean,\n    tree: BTree<K, V>,\n    count: number,\n    onFound?: (k: K, v: V, counter: number) => EditRangeResult<V, R> | void,\n  ): EditRangeResult<V, R> | number {\n    const cmp = tree._compare\n    let iLow, iHigh\n    if (high === low) {\n      if (!includeHigh) return count\n      iHigh = (iLow = this.indexOf(low, -1, cmp)) + 1\n      if (iLow < 0) return count\n    } else {\n      iLow = this.indexOf(low, 0, cmp)\n      iHigh = this.indexOf(high, -1, cmp)\n      if (iHigh < 0) iHigh = ~iHigh\n      else if (includeHigh === true) iHigh++\n    }\n    const keys = this.keys,\n      values = this.values\n    if (onFound !== undefined) {\n      for (let i = iLow; i < iHigh; i++) {\n        const key = keys[i]!\n        const result = onFound(key, values[i]!, count++)\n        if (result !== undefined) {\n          if (editMode === true) {\n            if (key !== keys[i] || this.isShared === true)\n              throw new Error(`BTree illegally changed or cloned in editRange`)\n            if (result.delete) {\n              this.keys.splice(i, 1)\n              if (this.values !== undefVals) this.values.splice(i, 1)\n              tree._size--\n              i--\n              iHigh--\n            } else if (result.hasOwnProperty(`value`)) {\n              values[i] = result.value!\n            }\n          }\n          if (result.break !== undefined) return result\n        }\n      }\n    } else count += iHigh - iLow\n    return count\n  }\n\n  /** Adds entire contents of right-hand sibling (rhs is left unchanged) */\n  mergeSibling(rhs: BNode<K, V>, _: number) {\n    this.keys.push.apply(this.keys, rhs.keys)\n    if (this.values === undefVals) {\n      if (rhs.values === undefVals) return\n      this.values = this.values.slice(0, this.keys.length)\n    }\n    this.values.push.apply(this.values, rhs.reifyValues())\n  }\n}\n\n/** Internal node (non-leaf node) ********************************************/\nclass BNodeInternal<K, V> extends BNode<K, V> {\n  // Note: conventionally B+ trees have one fewer key than the number of\n  // children, but I find it easier to keep the array lengths equal: each\n  // keys[i] caches the value of children[i].maxKey().\n  children: Array<BNode<K, V>>\n\n  /**\n   * This does not mark `children` as shared, so it is the responsibility of the caller\n   * to ensure children are either marked shared, or aren't included in another tree.\n   */\n  constructor(children: Array<BNode<K, V>>, keys?: Array<K>) {\n    if (!keys) {\n      keys = []\n      for (let i = 0; i < children.length; i++) keys[i] = children[i]!.maxKey()!\n    }\n    super(keys)\n    this.children = children\n  }\n\n  minKey() {\n    return this.children[0]!.minKey()\n  }\n\n  minPair(reusedArray: [K, V]): [K, V] | undefined {\n    return this.children[0]!.minPair(reusedArray)\n  }\n\n  maxPair(reusedArray: [K, V]): [K, V] | undefined {\n    return this.children[this.children.length - 1]!.maxPair(reusedArray)\n  }\n\n  get(key: K, defaultValue: V | undefined, tree: BTree<K, V>): V | undefined {\n    const i = this.indexOf(key, 0, tree._compare),\n      children = this.children\n    return i < children.length\n      ? children[i]!.get(key, defaultValue, tree)\n      : undefined\n  }\n\n  getPairOrNextLower(\n    key: K,\n    compare: (a: K, b: K) => number,\n    inclusive: boolean,\n    reusedArray: [K, V],\n  ): [K, V] | undefined {\n    const i = this.indexOf(key, 0, compare),\n      children = this.children\n    if (i >= children.length) return this.maxPair(reusedArray)\n    const result = children[i]!.getPairOrNextLower(\n      key,\n      compare,\n      inclusive,\n      reusedArray,\n    )\n    if (result === undefined && i > 0) {\n      return children[i - 1]!.maxPair(reusedArray)\n    }\n    return result\n  }\n\n  getPairOrNextHigher(\n    key: K,\n    compare: (a: K, b: K) => number,\n    inclusive: boolean,\n    reusedArray: [K, V],\n  ): [K, V] | undefined {\n    const i = this.indexOf(key, 0, compare),\n      children = this.children,\n      length = children.length\n    if (i >= length) return undefined\n    const result = children[i]!.getPairOrNextHigher(\n      key,\n      compare,\n      inclusive,\n      reusedArray,\n    )\n    if (result === undefined && i < length - 1) {\n      return children[i + 1]!.minPair(reusedArray)\n    }\n    return result\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // Internal Node: set & node splitting //////////////////////////////////////\n\n  set(\n    key: K,\n    value: V,\n    overwrite: boolean | undefined,\n    tree: BTree<K, V>,\n  ): boolean | BNodeInternal<K, V> {\n    const c = this.children,\n      max = tree._maxNodeSize,\n      cmp = tree._compare\n    let i = Math.min(this.indexOf(key, 0, cmp), c.length - 1),\n      child = c[i]!\n\n    if (child.isShared) c[i] = child = child.clone()\n    if (child.keys.length >= max) {\n      // child is full; inserting anything else will cause a split.\n      // Shifting an item to the left or right sibling may avoid a split.\n      // We can do a shift if the adjacent node is not full and if the\n      // current key can still be placed in the same node after the shift.\n      let other: BNode<K, V> | undefined\n      if (\n        i > 0 &&\n        (other = c[i - 1]!).keys.length < max &&\n        cmp(child.keys[0]!, key) < 0\n      ) {\n        if (other.isShared) c[i - 1] = other = other.clone()\n        other.takeFromRight(child)\n        this.keys[i - 1] = other.maxKey()!\n      } else if (\n        (other = c[i + 1]) !== undefined &&\n        other.keys.length < max &&\n        cmp(child.maxKey()!, key) < 0\n      ) {\n        if (other.isShared) c[i + 1] = other = other.clone()\n        other.takeFromLeft(child)\n        this.keys[i] = c[i]!.maxKey()!\n      }\n    }\n\n    const result = child.set(key, value, overwrite, tree)\n    if (result === false) return false\n    this.keys[i] = child.maxKey()!\n    if (result === true) return true\n\n    // The child has split and `result` is a new right child... does it fit?\n    if (this.keys.length < max) {\n      // yes\n      this.insert(i + 1, result)\n      return true\n    } else {\n      // no, we must split also\n      const newRightSibling = this.splitOffRightSide()\n      let target: BNodeInternal<K, V> = this\n      if (cmp(result.maxKey()!, this.maxKey()!) > 0) {\n        target = newRightSibling\n        i -= this.keys.length\n      }\n      target.insert(i + 1, result)\n      return newRightSibling\n    }\n  }\n\n  /**\n   * Inserts `child` at index `i`.\n   * This does not mark `child` as shared, so it is the responsibility of the caller\n   * to ensure that either child is marked shared, or it is not included in another tree.\n   */\n  insert(i: index, child: BNode<K, V>) {\n    this.children.splice(i, 0, child)\n    this.keys.splice(i, 0, child.maxKey()!)\n  }\n\n  /**\n   * Split this node.\n   * Modifies this to remove the second half of the items, returning a separate node containing them.\n   */\n  splitOffRightSide() {\n    // assert !this.isShared;\n    const half = this.children.length >> 1\n    return new BNodeInternal<K, V>(\n      this.children.splice(half),\n      this.keys.splice(half),\n    )\n  }\n\n  takeFromRight(rhs: BNode<K, V>) {\n    // Reminder: parent node must update its copy of key for this node\n    // assert: neither node is shared\n    // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)\n    this.keys.push(rhs.keys.shift()!)\n    this.children.push((rhs as BNodeInternal<K, V>).children.shift()!)\n  }\n\n  takeFromLeft(lhs: BNode<K, V>) {\n    // Reminder: parent node must update its copy of key for this node\n    // assert: neither node is shared\n    // assert rhs.keys.length > (maxNodeSize/2 && this.keys.length<maxNodeSize)\n    this.keys.unshift(lhs.keys.pop()!)\n    this.children.unshift((lhs as BNodeInternal<K, V>).children.pop()!)\n  }\n\n  // ///////////////////////////////////////////////////////////////////////////\n  // Internal Node: scanning & deletions //////////////////////////////////////\n\n  // Note: `count` is the next value of the third argument to `onFound`.\n  //       A leaf node's `forRange` function returns a new value for this counter,\n  //       unless the operation is to stop early.\n  forRange<R>(\n    low: K,\n    high: K,\n    includeHigh: boolean | undefined,\n    editMode: boolean,\n    tree: BTree<K, V>,\n    count: number,\n    onFound?: (k: K, v: V, counter: number) => EditRangeResult<V, R> | void,\n  ): EditRangeResult<V, R> | number {\n    const cmp = tree._compare\n    const keys = this.keys,\n      children = this.children\n    let iLow = this.indexOf(low, 0, cmp),\n      i = iLow\n    const iHigh = Math.min(\n      high === low ? iLow : this.indexOf(high, 0, cmp),\n      keys.length - 1,\n    )\n    if (!editMode) {\n      // Simple case\n      for (; i <= iHigh; i++) {\n        const result = children[i]!.forRange(\n          low,\n          high,\n          includeHigh,\n          editMode,\n          tree,\n          count,\n          onFound,\n        )\n        if (typeof result !== `number`) return result\n        count = result\n      }\n    } else if (i <= iHigh) {\n      try {\n        for (; i <= iHigh; i++) {\n          if (children[i]!.isShared) children[i] = children[i]!.clone()\n          const result = children[i]!.forRange(\n            low,\n            high,\n            includeHigh,\n            editMode,\n            tree,\n            count,\n            onFound,\n          )\n          // Note: if children[i] is empty then keys[i]=undefined.\n          //       This is an invalid state, but it is fixed below.\n          keys[i] = children[i]!.maxKey()!\n          if (typeof result !== `number`) return result\n          count = result\n        }\n      } finally {\n        // Deletions may have occurred, so look for opportunities to merge nodes.\n        const half = tree._maxNodeSize >> 1\n        if (iLow > 0) iLow--\n        for (i = iHigh; i >= iLow; i--) {\n          if (children[i]!.keys.length <= half) {\n            if (children[i]!.keys.length !== 0) {\n              this.tryMerge(i, tree._maxNodeSize)\n            } else {\n              // child is empty! delete it!\n              keys.splice(i, 1)\n              children.splice(i, 1)\n            }\n          }\n        }\n        if (children.length !== 0 && children[0]!.keys.length === 0)\n          check(false, `emptiness bug`)\n      }\n    }\n    return count\n  }\n\n  /** Merges child i with child i+1 if their combined size is not too large */\n  tryMerge(i: index, maxSize: number): boolean {\n    const children = this.children\n    if (i >= 0 && i + 1 < children.length) {\n      if (children[i]!.keys.length + children[i + 1]!.keys.length <= maxSize) {\n        if (children[i]!.isShared)\n          // cloned already UNLESS i is outside scan range\n          children[i] = children[i]!.clone()\n        children[i]!.mergeSibling(children[i + 1]!, maxSize)\n        children.splice(i + 1, 1)\n        this.keys.splice(i + 1, 1)\n        this.keys[i] = children[i]!.maxKey()!\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * Move children from `rhs` into this.\n   * `rhs` must be part of this tree, and be removed from it after this call\n   * (otherwise isShared for its children could be incorrect).\n   */\n  mergeSibling(rhs: BNode<K, V>, maxNodeSize: number) {\n    // assert !this.isShared;\n    const oldLength = this.keys.length\n    this.keys.push.apply(this.keys, rhs.keys)\n    const rhsChildren = (rhs as any as BNodeInternal<K, V>).children\n    this.children.push.apply(this.children, rhsChildren)\n\n    if (rhs.isShared && !this.isShared) {\n      // All children of a shared node are implicitly shared, and since their new\n      // parent is not shared, they must now be explicitly marked as shared.\n      for (const child of rhsChildren) child.isShared = true\n    }\n\n    // If our children are themselves almost empty due to a mass-delete,\n    // they may need to be merged too (but only the oldLength-1 and its\n    // right sibling should need this).\n    this.tryMerge(oldLength - 1, maxNodeSize)\n  }\n}\n\n// Optimization: this array of `undefined`s is used instead of a normal\n// array of values in nodes where `undefined` is the only value.\n// Its length is extended to max node size on first use; since it can\n// be shared between trees with different maximums, its length can only\n// increase, never decrease. Its type should be undefined[] but strangely\n// TypeScript won't allow the comparison V[] === undefined[]. To prevent\n// users from making this array too large, BTree has a maximum node size.\n//\n// FAQ: undefVals[i] is already undefined, so why increase the array size?\n// Reading outside the bounds of an array is relatively slow because it\n// has the side effect of scanning the prototype chain.\nconst undefVals: Array<any> = []\n\nconst Delete = { delete: true },\n  DeleteRange = () => Delete\nconst EmptyLeaf = (function () {\n  const n = new BNode<any, any>()\n  n.isShared = true\n  return n\n})()\nconst ReusedArray: Array<any> = [] // assumed thread-local\n\nfunction check(fact: boolean, ...args: Array<any>) {\n  if (!fact) {\n    args.unshift(`B+ tree`) // at beginning of message\n    throw new Error(args.join(` `))\n  }\n}\n"],"names":[],"mappings":"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"}