{"version":3,"file":"mutations.js","sources":["../../../src/collection/mutations.ts"],"sourcesContent":["import { withArrayChangeTracking, withChangeTracking } from '../proxy'\nimport { createTransaction, getActiveTransaction } from '../transactions'\nimport {\n  DeleteKeyNotFoundError,\n  DuplicateKeyError,\n  InvalidKeyError,\n  InvalidSchemaError,\n  KeyUpdateNotAllowedError,\n  MissingDeleteHandlerError,\n  MissingInsertHandlerError,\n  MissingUpdateArgumentError,\n  MissingUpdateHandlerError,\n  NoKeysPassedToDeleteError,\n  NoKeysPassedToUpdateError,\n  SchemaMustBeSynchronousError,\n  SchemaValidationError,\n  UndefinedKeyError,\n  UpdateKeyNotFoundError,\n} from '../errors'\nimport type { Collection, CollectionImpl } from './index.js'\nimport type { StandardSchemaV1 } from '@standard-schema/spec'\nimport type {\n  CollectionConfig,\n  InsertConfig,\n  OperationConfig,\n  PendingMutation,\n  StandardSchema,\n  Transaction as TransactionType,\n  TransactionWithMutations,\n  UtilsRecord,\n  WritableDeep,\n} from '../types'\nimport type { CollectionLifecycleManager } from './lifecycle'\nimport type { CollectionStateManager } from './state'\n\nexport class CollectionMutationsManager<\n  TOutput extends object = Record<string, unknown>,\n  TKey extends string | number = string | number,\n  TUtils extends UtilsRecord = {},\n  TSchema extends StandardSchemaV1 = StandardSchemaV1,\n  TInput extends object = TOutput,\n> {\n  private lifecycle!: CollectionLifecycleManager<TOutput, TKey, TSchema, TInput>\n  private state!: CollectionStateManager<TOutput, TKey, TSchema, TInput>\n  private collection!: CollectionImpl<TOutput, TKey, TUtils, TSchema, TInput>\n  private config!: CollectionConfig<TOutput, TKey, TSchema>\n  private id: string\n\n  constructor(config: CollectionConfig<TOutput, TKey, TSchema>, id: string) {\n    this.id = id\n    this.config = config\n  }\n\n  setDeps(deps: {\n    lifecycle: CollectionLifecycleManager<TOutput, TKey, TSchema, TInput>\n    state: CollectionStateManager<TOutput, TKey, TSchema, TInput>\n    collection: CollectionImpl<TOutput, TKey, TUtils, TSchema, TInput>\n  }) {\n    this.lifecycle = deps.lifecycle\n    this.state = deps.state\n    this.collection = deps.collection\n  }\n\n  private ensureStandardSchema(schema: unknown): StandardSchema<TOutput> {\n    // If the schema already implements the standard-schema interface, return it\n    if (schema && `~standard` in (schema as {})) {\n      return schema as StandardSchema<TOutput>\n    }\n\n    throw new InvalidSchemaError()\n  }\n\n  public validateData(\n    data: unknown,\n    type: `insert` | `update`,\n    key?: TKey,\n  ): TOutput | never {\n    if (!this.config.schema) return data as TOutput\n\n    const standardSchema = this.ensureStandardSchema(this.config.schema)\n\n    // For updates, we need to merge with the existing data before validation\n    if (type === `update` && key) {\n      // Get the existing data for this key\n      const existingData = this.state.get(key)\n\n      if (\n        existingData &&\n        data &&\n        typeof data === `object` &&\n        typeof existingData === `object`\n      ) {\n        // Merge the update with the existing data\n        const mergedData = Object.assign({}, existingData, data)\n\n        // Validate the merged data\n        const result = standardSchema[`~standard`].validate(mergedData)\n\n        // Ensure validation is synchronous\n        if (result instanceof Promise) {\n          throw new SchemaMustBeSynchronousError()\n        }\n\n        // If validation fails, throw a SchemaValidationError with the issues\n        if (`issues` in result && result.issues) {\n          const typedIssues = result.issues.map((issue) => ({\n            message: issue.message,\n            path: issue.path?.map((p) => String(p)),\n          }))\n          throw new SchemaValidationError(type, typedIssues)\n        }\n\n        // Extract only the modified keys from the validated result\n        const validatedMergedData = result.value as TOutput\n        const modifiedKeys = Object.keys(data)\n        const extractedChanges = Object.fromEntries(\n          modifiedKeys.map((k) => [k, validatedMergedData[k as keyof TOutput]]),\n        ) as TOutput\n\n        return extractedChanges\n      }\n    }\n\n    // For inserts or updates without existing data, validate the data directly\n    const result = standardSchema[`~standard`].validate(data)\n\n    // Ensure validation is synchronous\n    if (result instanceof Promise) {\n      throw new SchemaMustBeSynchronousError()\n    }\n\n    // If validation fails, throw a SchemaValidationError with the issues\n    if (`issues` in result && result.issues) {\n      const typedIssues = result.issues.map((issue) => ({\n        message: issue.message,\n        path: issue.path?.map((p) => String(p)),\n      }))\n      throw new SchemaValidationError(type, typedIssues)\n    }\n\n    return result.value as TOutput\n  }\n\n  public generateGlobalKey(key: any, item: any): string {\n    if (typeof key !== `string` && typeof key !== `number`) {\n      // Preserve specific error for undefined keys\n      if (typeof key === `undefined`) {\n        throw new UndefinedKeyError(item)\n      }\n      throw new InvalidKeyError(key, item)\n    }\n\n    return `KEY::${this.id}/${key}`\n  }\n\n  /**\n   * Inserts one or more items into the collection\n   */\n  insert = (data: TInput | Array<TInput>, config?: InsertConfig) => {\n    this.lifecycle.validateCollectionUsable(`insert`)\n    const state = this.state\n    const ambientTransaction = getActiveTransaction()\n\n    // If no ambient transaction exists, check for an onInsert handler early\n    if (!ambientTransaction && !this.config.onInsert) {\n      throw new MissingInsertHandlerError()\n    }\n\n    const items = Array.isArray(data) ? data : [data]\n    const mutations: Array<PendingMutation<TOutput>> = []\n    const keysInCurrentBatch = new Set<TKey>()\n\n    // Create mutations for each item\n    items.forEach((item) => {\n      // Validate the data against the schema if one exists\n      const validatedData = this.validateData(item, `insert`)\n\n      // Check if an item with this ID already exists in the collection or in the current batch\n      const key = this.config.getKey(validatedData)\n      if (this.state.has(key) || keysInCurrentBatch.has(key)) {\n        throw new DuplicateKeyError(key)\n      }\n      keysInCurrentBatch.add(key)\n      const globalKey = this.generateGlobalKey(key, item)\n\n      const mutation: PendingMutation<TOutput, `insert`> = {\n        mutationId: crypto.randomUUID(),\n        original: {},\n        modified: validatedData,\n        // Pick the values from validatedData based on what's passed in - this is for cases\n        // where a schema has default values. The validated data has the extra default\n        // values but for changes, we just want to show the data that was actually passed in.\n        changes: Object.fromEntries(\n          Object.keys(item).map((k) => [\n            k,\n            validatedData[k as keyof typeof validatedData],\n          ]),\n        ) as TInput,\n        globalKey,\n        key,\n        metadata: config?.metadata as unknown,\n        syncMetadata: this.config.sync.getSyncMetadata?.() || {},\n        optimistic: config?.optimistic ?? true,\n        type: `insert`,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        collection: this.collection,\n      }\n\n      mutations.push(mutation)\n    })\n\n    // If an ambient transaction exists, use it\n    if (ambientTransaction) {\n      ambientTransaction.applyMutations(mutations)\n\n      state.transactions.set(ambientTransaction.id, ambientTransaction)\n      state.scheduleTransactionCleanup(ambientTransaction)\n      state.recomputeOptimisticState(true)\n\n      return ambientTransaction\n    } else {\n      // Create a new transaction with a mutation function that calls the onInsert handler\n      const directOpTransaction = createTransaction<TOutput>({\n        mutationFn: async (params) => {\n          // Call the onInsert handler with the transaction and collection\n          return await this.config.onInsert!({\n            transaction:\n              params.transaction as unknown as TransactionWithMutations<\n                TOutput,\n                `insert`\n              >,\n            collection: this.collection as unknown as Collection<TOutput, TKey>,\n          })\n        },\n      })\n\n      // Apply mutations to the new transaction\n      directOpTransaction.applyMutations(mutations)\n      // Errors still reject tx.isPersisted.promise; this catch only prevents global unhandled rejections\n      directOpTransaction.commit().catch(() => undefined)\n\n      // Add the transaction to the collection's transactions store\n      state.transactions.set(directOpTransaction.id, directOpTransaction)\n      state.scheduleTransactionCleanup(directOpTransaction)\n      state.recomputeOptimisticState(true)\n\n      return directOpTransaction\n    }\n  }\n\n  /**\n   * Updates one or more items in the collection using a callback function\n   */\n  update(\n    keys: (TKey | unknown) | Array<TKey | unknown>,\n    configOrCallback:\n      | ((draft: WritableDeep<TInput>) => void)\n      | ((drafts: Array<WritableDeep<TInput>>) => void)\n      | OperationConfig,\n    maybeCallback?:\n      | ((draft: WritableDeep<TInput>) => void)\n      | ((drafts: Array<WritableDeep<TInput>>) => void),\n  ) {\n    if (typeof keys === `undefined`) {\n      throw new MissingUpdateArgumentError()\n    }\n\n    const state = this.state\n    this.lifecycle.validateCollectionUsable(`update`)\n\n    const ambientTransaction = getActiveTransaction()\n\n    // If no ambient transaction exists, check for an onUpdate handler early\n    if (!ambientTransaction && !this.config.onUpdate) {\n      throw new MissingUpdateHandlerError()\n    }\n\n    const isArray = Array.isArray(keys)\n    const keysArray = isArray ? keys : [keys]\n\n    if (isArray && keysArray.length === 0) {\n      throw new NoKeysPassedToUpdateError()\n    }\n\n    const callback =\n      typeof configOrCallback === `function` ? configOrCallback : maybeCallback!\n    const config =\n      typeof configOrCallback === `function` ? {} : configOrCallback\n\n    // Get the current objects or empty objects if they don't exist\n    const currentObjects = keysArray.map((key) => {\n      const item = this.state.get(key)\n      if (!item) {\n        throw new UpdateKeyNotFoundError(key)\n      }\n\n      return item\n    }) as unknown as Array<TInput>\n\n    let changesArray\n    if (isArray) {\n      // Use the proxy to track changes for all objects\n      changesArray = withArrayChangeTracking(\n        currentObjects,\n        callback as (draft: Array<TInput>) => void,\n      )\n    } else {\n      const result = withChangeTracking(\n        currentObjects[0]!,\n        callback as (draft: TInput) => void,\n      )\n      changesArray = [result]\n    }\n\n    // Create mutations for each object that has changes\n    const mutations: Array<\n      PendingMutation<\n        TOutput,\n        `update`,\n        CollectionImpl<TOutput, TKey, TUtils, TSchema, TInput>\n      >\n    > = keysArray\n      .map((key, index) => {\n        const itemChanges = changesArray[index] // User-provided changes for this specific item\n\n        // Skip items with no changes\n        if (!itemChanges || Object.keys(itemChanges).length === 0) {\n          return null\n        }\n\n        const originalItem = currentObjects[index] as unknown as TOutput\n        // Validate the user-provided changes for this item\n        const validatedUpdatePayload = this.validateData(\n          itemChanges,\n          `update`,\n          key,\n        )\n\n        // Construct the full modified item by applying the validated update payload to the original item\n        const modifiedItem = Object.assign(\n          {},\n          originalItem,\n          validatedUpdatePayload,\n        )\n\n        // Check if the ID of the item is being changed\n        const originalItemId = this.config.getKey(originalItem)\n        const modifiedItemId = this.config.getKey(modifiedItem)\n\n        if (originalItemId !== modifiedItemId) {\n          throw new KeyUpdateNotAllowedError(originalItemId, modifiedItemId)\n        }\n\n        const globalKey = this.generateGlobalKey(modifiedItemId, modifiedItem)\n\n        return {\n          mutationId: crypto.randomUUID(),\n          original: originalItem,\n          modified: modifiedItem,\n          // Pick the values from modifiedItem based on what's passed in - this is for cases\n          // where a schema has default values or transforms. The modified data has the extra\n          // default or transformed values but for changes, we just want to show the data that\n          // was actually passed in.\n          changes: Object.fromEntries(\n            Object.keys(itemChanges).map((k) => [\n              k,\n              modifiedItem[k as keyof typeof modifiedItem],\n            ]),\n          ) as TInput,\n          globalKey,\n          key,\n          metadata: config.metadata as unknown,\n          syncMetadata: (state.syncedMetadata.get(key) || {}) as Record<\n            string,\n            unknown\n          >,\n          optimistic: config.optimistic ?? true,\n          type: `update`,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n          collection: this.collection,\n        }\n      })\n      .filter(Boolean) as Array<\n      PendingMutation<\n        TOutput,\n        `update`,\n        CollectionImpl<TOutput, TKey, TUtils, TSchema, TInput>\n      >\n    >\n\n    // If no changes were made, return an empty transaction early\n    if (mutations.length === 0) {\n      const emptyTransaction = createTransaction({\n        mutationFn: async () => {},\n      })\n      // Errors still propagate through tx.isPersisted.promise; suppress the background commit from warning\n      emptyTransaction.commit().catch(() => undefined)\n      // Schedule cleanup for empty transaction\n      state.scheduleTransactionCleanup(emptyTransaction)\n      return emptyTransaction\n    }\n\n    // If an ambient transaction exists, use it\n    if (ambientTransaction) {\n      ambientTransaction.applyMutations(mutations)\n\n      state.transactions.set(ambientTransaction.id, ambientTransaction)\n      state.scheduleTransactionCleanup(ambientTransaction)\n      state.recomputeOptimisticState(true)\n\n      return ambientTransaction\n    }\n\n    // No need to check for onUpdate handler here as we've already checked at the beginning\n\n    // Create a new transaction with a mutation function that calls the onUpdate handler\n    const directOpTransaction = createTransaction<TOutput>({\n      mutationFn: async (params) => {\n        // Call the onUpdate handler with the transaction and collection\n        return this.config.onUpdate!({\n          transaction:\n            params.transaction as unknown as TransactionWithMutations<\n              TOutput,\n              `update`\n            >,\n          collection: this.collection as unknown as Collection<TOutput, TKey>,\n        })\n      },\n    })\n\n    // Apply mutations to the new transaction\n    directOpTransaction.applyMutations(mutations)\n    // Errors still hit tx.isPersisted.promise; avoid leaking an unhandled rejection from the fire-and-forget commit\n    directOpTransaction.commit().catch(() => undefined)\n\n    // Add the transaction to the collection's transactions store\n\n    state.transactions.set(directOpTransaction.id, directOpTransaction)\n    state.scheduleTransactionCleanup(directOpTransaction)\n    state.recomputeOptimisticState(true)\n\n    return directOpTransaction\n  }\n\n  /**\n   * Deletes one or more items from the collection\n   */\n  delete = (\n    keys: Array<TKey> | TKey,\n    config?: OperationConfig,\n  ): TransactionType<any> => {\n    const state = this.state\n    this.lifecycle.validateCollectionUsable(`delete`)\n\n    const ambientTransaction = getActiveTransaction()\n\n    // If no ambient transaction exists, check for an onDelete handler early\n    if (!ambientTransaction && !this.config.onDelete) {\n      throw new MissingDeleteHandlerError()\n    }\n\n    if (Array.isArray(keys) && keys.length === 0) {\n      throw new NoKeysPassedToDeleteError()\n    }\n\n    const keysArray = Array.isArray(keys) ? keys : [keys]\n    const mutations: Array<\n      PendingMutation<\n        TOutput,\n        `delete`,\n        CollectionImpl<TOutput, TKey, TUtils, TSchema, TInput>\n      >\n    > = []\n\n    for (const key of keysArray) {\n      if (!this.state.has(key)) {\n        throw new DeleteKeyNotFoundError(key)\n      }\n      const globalKey = this.generateGlobalKey(key, this.state.get(key)!)\n      const mutation: PendingMutation<\n        TOutput,\n        `delete`,\n        CollectionImpl<TOutput, TKey, TUtils, TSchema, TInput>\n      > = {\n        mutationId: crypto.randomUUID(),\n        original: this.state.get(key)!,\n        modified: this.state.get(key)!,\n        changes: this.state.get(key)!,\n        globalKey,\n        key,\n        metadata: config?.metadata as unknown,\n        syncMetadata: (state.syncedMetadata.get(key) || {}) as Record<\n          string,\n          unknown\n        >,\n        optimistic: config?.optimistic ?? true,\n        type: `delete`,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        collection: this.collection,\n      }\n\n      mutations.push(mutation)\n    }\n\n    // If an ambient transaction exists, use it\n    if (ambientTransaction) {\n      ambientTransaction.applyMutations(mutations)\n\n      state.transactions.set(ambientTransaction.id, ambientTransaction)\n      state.scheduleTransactionCleanup(ambientTransaction)\n      state.recomputeOptimisticState(true)\n\n      return ambientTransaction\n    }\n\n    // Create a new transaction with a mutation function that calls the onDelete handler\n    const directOpTransaction = createTransaction<TOutput>({\n      autoCommit: true,\n      mutationFn: async (params) => {\n        // Call the onDelete handler with the transaction and collection\n        return this.config.onDelete!({\n          transaction:\n            params.transaction as unknown as TransactionWithMutations<\n              TOutput,\n              `delete`\n            >,\n          collection: this.collection as unknown as Collection<TOutput, TKey>,\n        })\n      },\n    })\n\n    // Apply mutations to the new transaction\n    directOpTransaction.applyMutations(mutations)\n    // Errors still reject tx.isPersisted.promise; silence the internal commit promise to prevent test noise\n    directOpTransaction.commit().catch(() => undefined)\n\n    state.transactions.set(directOpTransaction.id, directOpTransaction)\n    state.scheduleTransactionCleanup(directOpTransaction)\n    state.recomputeOptimisticState(true)\n\n    return directOpTransaction\n  }\n}\n"],"names":["config","result"],"mappings":"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"}