{"version":3,"file":"proxy.js","sources":["../../src/proxy.ts"],"sourcesContent":["/**\n * A utility for creating a proxy that captures changes to an object\n * and provides a way to retrieve those changes.\n */\n\nimport { deepEquals, isTemporal } from './utils'\n\n/**\n * Set of array methods that iterate with callbacks and may return elements.\n * Hoisted to module scope to avoid creating a new Set on every property access.\n */\nconst CALLBACK_ITERATION_METHODS = new Set([\n  `find`,\n  `findLast`,\n  `findIndex`,\n  `findLastIndex`,\n  `filter`,\n  `map`,\n  `flatMap`,\n  `forEach`,\n  `some`,\n  `every`,\n  `reduce`,\n  `reduceRight`,\n])\n\n/**\n * Set of array methods that modify the array in place.\n */\nconst ARRAY_MODIFYING_METHODS = new Set([\n  `pop`,\n  `push`,\n  `shift`,\n  `unshift`,\n  `splice`,\n  `sort`,\n  `reverse`,\n  `fill`,\n  `copyWithin`,\n])\n\n/**\n * Set of Map/Set methods that modify the collection in place.\n */\nconst MAP_SET_MODIFYING_METHODS = new Set([`set`, `delete`, `clear`, `add`])\n\n/**\n * Set of Map/Set iterator methods.\n */\nconst MAP_SET_ITERATOR_METHODS = new Set([\n  `entries`,\n  `keys`,\n  `values`,\n  `forEach`,\n])\n\n/**\n * Check if a value is a proxiable object (not Date, RegExp, or Temporal)\n */\nfunction isProxiableObject(\n  value: unknown,\n): value is Record<string | symbol, unknown> {\n  return (\n    value !== null &&\n    typeof value === `object` &&\n    !((value as any) instanceof Date) &&\n    !((value as any) instanceof RegExp) &&\n    !isTemporal(value)\n  )\n}\n\n/**\n * Creates a handler for array iteration methods that ensures proxied elements\n * are passed to callbacks and returned from methods like find/filter.\n */\nfunction createArrayIterationHandler<T extends object>(\n  methodName: string,\n  methodFn: (...args: Array<unknown>) => unknown,\n  changeTracker: ChangeTracker<T>,\n  memoizedCreateChangeProxy: (\n    obj: Record<string | symbol, unknown>,\n    parent?: {\n      tracker: ChangeTracker<Record<string | symbol, unknown>>\n      prop: string | symbol\n    },\n  ) => { proxy: Record<string | symbol, unknown> },\n): ((...args: Array<unknown>) => unknown) | undefined {\n  if (!CALLBACK_ITERATION_METHODS.has(methodName)) {\n    return undefined\n  }\n\n  return function (...args: Array<unknown>) {\n    const callback = args[0]\n    if (typeof callback !== `function`) {\n      return methodFn.apply(changeTracker.copy_, args)\n    }\n\n    // Create a helper to get proxied version of an array element\n    const getProxiedElement = (element: unknown, index: number): unknown => {\n      if (isProxiableObject(element)) {\n        const nestedParent = {\n          tracker: changeTracker as unknown as ChangeTracker<\n            Record<string | symbol, unknown>\n          >,\n          prop: String(index),\n        }\n        const { proxy: elementProxy } = memoizedCreateChangeProxy(\n          element,\n          nestedParent,\n        )\n        return elementProxy\n      }\n      return element\n    }\n\n    // Wrap the callback to pass proxied elements\n    const wrappedCallback = function (\n      this: unknown,\n      element: unknown,\n      index: number,\n      array: unknown,\n    ) {\n      const proxiedElement = getProxiedElement(element, index)\n      return callback.call(this, proxiedElement, index, array)\n    }\n\n    // For reduce/reduceRight, the callback signature is different\n    if (methodName === `reduce` || methodName === `reduceRight`) {\n      const reduceCallback = function (\n        this: unknown,\n        accumulator: unknown,\n        element: unknown,\n        index: number,\n        array: unknown,\n      ) {\n        const proxiedElement = getProxiedElement(element, index)\n        return callback.call(this, accumulator, proxiedElement, index, array)\n      }\n      return methodFn.apply(changeTracker.copy_, [\n        reduceCallback,\n        ...args.slice(1),\n      ])\n    }\n\n    const result = methodFn.apply(changeTracker.copy_, [\n      wrappedCallback,\n      ...args.slice(1),\n    ])\n\n    // For find/findLast, proxy the returned element if it's an object\n    if (\n      (methodName === `find` || methodName === `findLast`) &&\n      result &&\n      typeof result === `object`\n    ) {\n      const foundIndex = (\n        changeTracker.copy_ as unknown as Array<unknown>\n      ).indexOf(result)\n      if (foundIndex !== -1) {\n        return getProxiedElement(result, foundIndex)\n      }\n    }\n\n    // For filter, proxy each element in the result array\n    if (methodName === `filter` && Array.isArray(result)) {\n      return result.map((element) => {\n        const originalIndex = (\n          changeTracker.copy_ as unknown as Array<unknown>\n        ).indexOf(element)\n        if (originalIndex !== -1) {\n          return getProxiedElement(element, originalIndex)\n        }\n        return element\n      })\n    }\n\n    return result\n  }\n}\n\n/**\n * Creates a Symbol.iterator handler for arrays that yields proxied elements.\n */\nfunction createArrayIteratorHandler<T extends object>(\n  changeTracker: ChangeTracker<T>,\n  memoizedCreateChangeProxy: (\n    obj: Record<string | symbol, unknown>,\n    parent?: {\n      tracker: ChangeTracker<Record<string | symbol, unknown>>\n      prop: string | symbol\n    },\n  ) => { proxy: Record<string | symbol, unknown> },\n): () => Iterator<unknown> {\n  return function () {\n    const array = changeTracker.copy_ as unknown as Array<unknown>\n    let index = 0\n\n    return {\n      next() {\n        if (index >= array.length) {\n          return { done: true, value: undefined }\n        }\n\n        const element = array[index]\n        let proxiedElement = element\n\n        if (isProxiableObject(element)) {\n          const nestedParent = {\n            tracker: changeTracker as unknown as ChangeTracker<\n              Record<string | symbol, unknown>\n            >,\n            prop: String(index),\n          }\n          const { proxy: elementProxy } = memoizedCreateChangeProxy(\n            element,\n            nestedParent,\n          )\n          proxiedElement = elementProxy\n        }\n\n        index++\n        return { done: false, value: proxiedElement }\n      },\n      [Symbol.iterator]() {\n        return this\n      },\n    }\n  }\n}\n\n/**\n * Creates a wrapper for methods that modify a collection (array, Map, Set).\n * The wrapper calls the method and marks the change tracker as modified.\n */\nfunction createModifyingMethodHandler<T extends object>(\n  methodFn: (...args: Array<unknown>) => unknown,\n  changeTracker: ChangeTracker<T>,\n  markChanged: (tracker: ChangeTracker<T>) => void,\n): (...args: Array<unknown>) => unknown {\n  return function (...args: Array<unknown>) {\n    const result = methodFn.apply(changeTracker.copy_, args)\n    markChanged(changeTracker)\n    return result\n  }\n}\n\n/**\n * Creates handlers for Map/Set iterator methods (entries, keys, values, forEach).\n * Returns proxied values for iteration to enable change tracking.\n */\nfunction createMapSetIteratorHandler<T extends object>(\n  methodName: string,\n  prop: string | symbol,\n  methodFn: (...args: Array<unknown>) => unknown,\n  target: Map<unknown, unknown> | Set<unknown>,\n  changeTracker: ChangeTracker<T>,\n  memoizedCreateChangeProxy: (\n    obj: Record<string | symbol, unknown>,\n    parent?: {\n      tracker: ChangeTracker<Record<string | symbol, unknown>>\n      prop: string | symbol\n    },\n  ) => { proxy: Record<string | symbol, unknown> },\n  markChanged: (tracker: ChangeTracker<T>) => void,\n): ((...args: Array<unknown>) => unknown) | undefined {\n  const isIteratorMethod =\n    MAP_SET_ITERATOR_METHODS.has(methodName) || prop === Symbol.iterator\n\n  if (!isIteratorMethod) {\n    return undefined\n  }\n\n  return function (this: unknown, ...args: Array<unknown>) {\n    const result = methodFn.apply(changeTracker.copy_, args)\n\n    // For forEach, wrap the callback to track changes\n    if (methodName === `forEach`) {\n      const callback = args[0]\n      if (typeof callback === `function`) {\n        const wrappedCallback = function (\n          this: unknown,\n          value: unknown,\n          key: unknown,\n          collection: unknown,\n        ) {\n          const cbresult = callback.call(this, value, key, collection)\n          markChanged(changeTracker)\n          return cbresult\n        }\n        return methodFn.apply(target, [wrappedCallback, ...args.slice(1)])\n      }\n    }\n\n    // For iterators (entries, keys, values, Symbol.iterator)\n    const isValueIterator =\n      methodName === `entries` ||\n      methodName === `values` ||\n      methodName === Symbol.iterator.toString() ||\n      prop === Symbol.iterator\n\n    if (isValueIterator) {\n      const originalIterator = result as Iterator<unknown>\n\n      // For values() iterator on Maps, create a value-to-key mapping\n      const valueToKeyMap = new Map()\n      if (methodName === `values` && target instanceof Map) {\n        for (const [key, mapValue] of (\n          changeTracker.copy_ as unknown as Map<unknown, unknown>\n        ).entries()) {\n          valueToKeyMap.set(mapValue, key)\n        }\n      }\n\n      // For Set iterators, create an original-to-modified mapping\n      const originalToModifiedMap = new Map()\n      if (target instanceof Set) {\n        for (const setValue of (\n          changeTracker.copy_ as unknown as Set<unknown>\n        ).values()) {\n          originalToModifiedMap.set(setValue, setValue)\n        }\n      }\n\n      // Return a wrapped iterator that proxies values\n      return {\n        next() {\n          const nextResult = originalIterator.next()\n\n          if (\n            !nextResult.done &&\n            nextResult.value &&\n            typeof nextResult.value === `object`\n          ) {\n            // For entries, the value is a [key, value] pair\n            if (\n              methodName === `entries` &&\n              Array.isArray(nextResult.value) &&\n              nextResult.value.length === 2\n            ) {\n              if (\n                nextResult.value[1] &&\n                typeof nextResult.value[1] === `object`\n              ) {\n                const mapKey = nextResult.value[0]\n                const mapParent = {\n                  tracker: changeTracker as unknown as ChangeTracker<\n                    Record<string | symbol, unknown>\n                  >,\n                  prop: mapKey as string | symbol,\n                  updateMap: (newValue: unknown) => {\n                    if (changeTracker.copy_ instanceof Map) {\n                      ;(changeTracker.copy_ as Map<unknown, unknown>).set(\n                        mapKey,\n                        newValue,\n                      )\n                    }\n                  },\n                }\n                const { proxy: valueProxy } = memoizedCreateChangeProxy(\n                  nextResult.value[1] as Record<string | symbol, unknown>,\n                  mapParent as unknown as {\n                    tracker: ChangeTracker<Record<string | symbol, unknown>>\n                    prop: string | symbol\n                  },\n                )\n                nextResult.value[1] = valueProxy\n              }\n            } else if (\n              methodName === `values` ||\n              methodName === Symbol.iterator.toString() ||\n              prop === Symbol.iterator\n            ) {\n              // For Map values(), use the key mapping\n              if (methodName === `values` && target instanceof Map) {\n                const mapKey = valueToKeyMap.get(nextResult.value)\n                if (mapKey !== undefined) {\n                  const mapParent = {\n                    tracker: changeTracker as unknown as ChangeTracker<\n                      Record<string | symbol, unknown>\n                    >,\n                    prop: mapKey as string | symbol,\n                    updateMap: (newValue: unknown) => {\n                      if (changeTracker.copy_ instanceof Map) {\n                        ;(changeTracker.copy_ as Map<unknown, unknown>).set(\n                          mapKey,\n                          newValue,\n                        )\n                      }\n                    },\n                  }\n                  const { proxy: valueProxy } = memoizedCreateChangeProxy(\n                    nextResult.value as Record<string | symbol, unknown>,\n                    mapParent as unknown as {\n                      tracker: ChangeTracker<Record<string | symbol, unknown>>\n                      prop: string | symbol\n                    },\n                  )\n                  nextResult.value = valueProxy\n                }\n              } else if (target instanceof Set) {\n                // For Set, track modifications\n                const setOriginalValue = nextResult.value\n                const setParent = {\n                  tracker: changeTracker as unknown as ChangeTracker<\n                    Record<string | symbol, unknown>\n                  >,\n                  prop: setOriginalValue as unknown as string | symbol,\n                  updateSet: (newValue: unknown) => {\n                    if (changeTracker.copy_ instanceof Set) {\n                      ;(changeTracker.copy_ as Set<unknown>).delete(\n                        setOriginalValue,\n                      )\n                      ;(changeTracker.copy_ as Set<unknown>).add(newValue)\n                      originalToModifiedMap.set(setOriginalValue, newValue)\n                    }\n                  },\n                }\n                const { proxy: valueProxy } = memoizedCreateChangeProxy(\n                  nextResult.value as Record<string | symbol, unknown>,\n                  setParent as unknown as {\n                    tracker: ChangeTracker<Record<string | symbol, unknown>>\n                    prop: string | symbol\n                  },\n                )\n                nextResult.value = valueProxy\n              } else {\n                // For other cases, use a symbol placeholder\n                const tempKey = Symbol(`iterator-value`)\n                const { proxy: valueProxy } = memoizedCreateChangeProxy(\n                  nextResult.value as Record<string | symbol, unknown>,\n                  {\n                    tracker: changeTracker as unknown as ChangeTracker<\n                      Record<string | symbol, unknown>\n                    >,\n                    prop: tempKey,\n                  },\n                )\n                nextResult.value = valueProxy\n              }\n            }\n          }\n\n          return nextResult\n        },\n        [Symbol.iterator]() {\n          return this\n        },\n      }\n    }\n\n    return result\n  }\n}\n\n/**\n * Simple debug utility that only logs when debug mode is enabled\n * Set DEBUG to true in localStorage to enable debug logging\n */\nfunction debugLog(...args: Array<unknown>): void {\n  // Check if we're in a browser environment\n  const isBrowser =\n    typeof window !== `undefined` && typeof localStorage !== `undefined`\n\n  // In browser, check localStorage for debug flag\n  if (isBrowser && localStorage.getItem(`DEBUG`) === `true`) {\n    console.log(`[proxy]`, ...args)\n  }\n  // In Node.js environment, check for environment variable (though this is primarily for browser)\n  else if (\n    // true\n    !isBrowser &&\n    typeof process !== `undefined` &&\n    process.env.DEBUG === `true`\n  ) {\n    console.log(`[proxy]`, ...args)\n  }\n}\n\n// Add TypedArray interface with proper type\ninterface TypedArray {\n  length: number\n  [index: number]: number\n}\n\n// Update type for ChangeTracker\ninterface ChangeTracker<T extends object> {\n  originalObject: T\n  modified: boolean\n  copy_: T\n  proxyCount: number\n  assigned_: Record<string | symbol, boolean>\n  parent?:\n    | {\n        tracker: ChangeTracker<Record<string | symbol, unknown>>\n        prop: string | symbol\n      }\n    | {\n        tracker: ChangeTracker<Record<string | symbol, unknown>>\n        prop: string | symbol\n        updateMap: (newValue: unknown) => void\n      }\n    | {\n        tracker: ChangeTracker<Record<string | symbol, unknown>>\n        prop: unknown\n        updateSet: (newValue: unknown) => void\n      }\n  target: T\n}\n\n/**\n * Deep clones an object while preserving special types like Date and RegExp\n */\n\nfunction deepClone<T extends unknown>(\n  obj: T,\n  visited = new WeakMap<object, unknown>(),\n): T {\n  // Handle null and undefined\n  if (obj === null || obj === undefined) {\n    return obj\n  }\n\n  // Handle primitive types\n  if (typeof obj !== `object`) {\n    return obj\n  }\n\n  // If we've already cloned this object, return the cached clone\n  if (visited.has(obj as object)) {\n    return visited.get(obj as object) as T\n  }\n\n  if (obj instanceof Date) {\n    return new Date(obj.getTime()) as unknown as T\n  }\n\n  if (obj instanceof RegExp) {\n    return new RegExp(obj.source, obj.flags) as unknown as T\n  }\n\n  if (Array.isArray(obj)) {\n    const arrayClone = [] as Array<unknown>\n    visited.set(obj as object, arrayClone)\n    obj.forEach((item, index) => {\n      arrayClone[index] = deepClone(item, visited)\n    })\n    return arrayClone as unknown as T\n  }\n\n  // Handle TypedArrays\n  if (ArrayBuffer.isView(obj) && !(obj instanceof DataView)) {\n    // Get the constructor to create a new instance of the same type\n    const TypedArrayConstructor = Object.getPrototypeOf(obj).constructor\n    const clone = new TypedArrayConstructor(\n      (obj as unknown as TypedArray).length,\n    ) as unknown as TypedArray\n    visited.set(obj as object, clone)\n\n    // Copy the values\n    for (let i = 0; i < (obj as unknown as TypedArray).length; i++) {\n      clone[i] = (obj as unknown as TypedArray)[i]!\n    }\n\n    return clone as unknown as T\n  }\n\n  if (obj instanceof Map) {\n    const clone = new Map() as Map<unknown, unknown>\n    visited.set(obj as object, clone)\n    obj.forEach((value, key) => {\n      clone.set(key, deepClone(value, visited))\n    })\n    return clone as unknown as T\n  }\n\n  if (obj instanceof Set) {\n    const clone = new Set()\n    visited.set(obj as object, clone)\n    obj.forEach((value) => {\n      clone.add(deepClone(value, visited))\n    })\n    return clone as unknown as T\n  }\n\n  // Handle Temporal objects\n  if (isTemporal(obj)) {\n    // Temporal objects are immutable, so we can return them directly\n    // This preserves all their internal state correctly\n    return obj\n  }\n\n  const clone = {} as Record<string | symbol, unknown>\n  visited.set(obj as object, clone)\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      clone[key] = deepClone(\n        (obj as Record<string | symbol, unknown>)[key],\n        visited,\n      )\n    }\n  }\n\n  const symbolProps = Object.getOwnPropertySymbols(obj)\n  for (const sym of symbolProps) {\n    clone[sym] = deepClone(\n      (obj as Record<string | symbol, unknown>)[sym],\n      visited,\n    )\n  }\n\n  return clone as T\n}\n\nlet count = 0\nfunction getProxyCount() {\n  count += 1\n  return count\n}\n\n/**\n * Creates a proxy that tracks changes to the target object\n *\n * @param target The object to proxy\n * @param parent Optional parent information\n * @returns An object containing the proxy and a function to get the changes\n */\nexport function createChangeProxy<\n  T extends Record<string | symbol, any | undefined>,\n>(\n  target: T,\n  parent?: {\n    tracker: ChangeTracker<Record<string | symbol, unknown>>\n    prop: string | symbol\n  },\n): {\n  proxy: T\n\n  getChanges: () => Record<string | symbol, any>\n} {\n  const changeProxyCache = new Map<object, object>()\n\n  function memoizedCreateChangeProxy<\n    TInner extends Record<string | symbol, any | undefined>,\n  >(\n    innerTarget: TInner,\n    innerParent?: {\n      tracker: ChangeTracker<Record<string | symbol, unknown>>\n      prop: string | symbol\n    },\n  ): {\n    proxy: TInner\n    getChanges: () => Record<string | symbol, any>\n  } {\n    debugLog(`Object ID:`, innerTarget.constructor.name)\n    if (changeProxyCache.has(innerTarget)) {\n      return changeProxyCache.get(innerTarget) as {\n        proxy: TInner\n        getChanges: () => Record<string | symbol, any>\n      }\n    } else {\n      const changeProxy = createChangeProxy(innerTarget, innerParent)\n      changeProxyCache.set(innerTarget, changeProxy)\n      return changeProxy\n    }\n  }\n  // Create a WeakMap to cache proxies for nested objects\n  // This prevents creating multiple proxies for the same object\n  // and handles circular references\n  const proxyCache = new Map<object, object>()\n\n  // Create a change tracker to track changes to the object\n  const changeTracker: ChangeTracker<T> = {\n    copy_: deepClone(target),\n    originalObject: deepClone(target),\n    proxyCount: getProxyCount(),\n    modified: false,\n    assigned_: {},\n    parent,\n    target, // Store reference to the target object\n  }\n\n  debugLog(\n    `createChangeProxy called for target`,\n    target,\n    changeTracker.proxyCount,\n  )\n  // Mark this object and all its ancestors as modified\n  // Also propagate the actual changes up the chain\n  function markChanged(state: ChangeTracker<object>) {\n    if (!state.modified) {\n      state.modified = true\n    }\n\n    // Propagate the change up the parent chain\n    if (state.parent) {\n      debugLog(`propagating change to parent`)\n\n      // Check if this is a special Map parent with updateMap function\n      if (`updateMap` in state.parent) {\n        // Use the special updateMap function for Maps\n        state.parent.updateMap(state.copy_)\n      } else if (`updateSet` in state.parent) {\n        // Use the special updateSet function for Sets\n        state.parent.updateSet(state.copy_)\n      } else {\n        // Update parent's copy with this object's current state\n        state.parent.tracker.copy_[state.parent.prop] = state.copy_\n        state.parent.tracker.assigned_[state.parent.prop] = true\n      }\n\n      // Mark parent as changed\n      markChanged(state.parent.tracker)\n    }\n  }\n\n  // Check if all properties in the current state have reverted to original values\n  function checkIfReverted(\n    state: ChangeTracker<Record<string | symbol, unknown>>,\n  ): boolean {\n    debugLog(\n      `checkIfReverted called with assigned keys:`,\n      Object.keys(state.assigned_),\n    )\n\n    // If there are no assigned properties, object is unchanged\n    if (\n      Object.keys(state.assigned_).length === 0 &&\n      Object.getOwnPropertySymbols(state.assigned_).length === 0\n    ) {\n      debugLog(`No assigned properties, returning true`)\n      return true\n    }\n\n    // Check each assigned regular property\n    for (const prop in state.assigned_) {\n      // If this property is marked as assigned\n      if (state.assigned_[prop] === true) {\n        const currentValue = state.copy_[prop]\n        const originalValue = (state.originalObject as any)[prop]\n\n        debugLog(\n          `Checking property ${String(prop)}, current:`,\n          currentValue,\n          `original:`,\n          originalValue,\n        )\n\n        // If the value is not equal to original, something is still changed\n        if (!deepEquals(currentValue, originalValue)) {\n          debugLog(`Property ${String(prop)} is different, returning false`)\n          return false\n        }\n      } else if (state.assigned_[prop] === false) {\n        // Property was deleted, so it's different from original\n        debugLog(`Property ${String(prop)} was deleted, returning false`)\n        return false\n      }\n    }\n\n    // Check each assigned symbol property\n    const symbolProps = Object.getOwnPropertySymbols(state.assigned_)\n    for (const sym of symbolProps) {\n      if (state.assigned_[sym] === true) {\n        const currentValue = (state.copy_ as any)[sym]\n        const originalValue = (state.originalObject as any)[sym]\n\n        // If the value is not equal to original, something is still changed\n        if (!deepEquals(currentValue, originalValue)) {\n          debugLog(`Symbol property is different, returning false`)\n          return false\n        }\n      } else if (state.assigned_[sym] === false) {\n        // Property was deleted, so it's different from original\n        debugLog(`Symbol property was deleted, returning false`)\n        return false\n      }\n    }\n\n    debugLog(`All properties match original values, returning true`)\n    // All assigned properties match their original values\n    return true\n  }\n\n  // Update parent status based on child changes\n  function checkParentStatus(\n    parentState: ChangeTracker<Record<string | symbol, unknown>>,\n    childProp: string | symbol | unknown,\n  ) {\n    debugLog(`checkParentStatus called for child prop:`, childProp)\n\n    // Check if all properties of the parent are reverted\n    const isReverted = checkIfReverted(parentState)\n    debugLog(`Parent checkIfReverted returned:`, isReverted)\n\n    if (isReverted) {\n      debugLog(`Parent is fully reverted, clearing tracking`)\n      // If everything is reverted, clear the tracking\n      parentState.modified = false\n      parentState.assigned_ = {}\n\n      // Continue up the chain\n      if (parentState.parent) {\n        debugLog(`Continuing up the parent chain`)\n        checkParentStatus(parentState.parent.tracker, parentState.parent.prop)\n      }\n    }\n  }\n\n  // Create a proxy for the target object\n  function createObjectProxy<TObj extends object>(obj: TObj): TObj {\n    debugLog(`createObjectProxy`, obj)\n    // If we've already created a proxy for this object, return it\n    if (proxyCache.has(obj)) {\n      debugLog(`proxyCache found match`)\n      return proxyCache.get(obj) as TObj\n    }\n\n    // Create a proxy for the object\n    const proxy = new Proxy(obj, {\n      get(ptarget, prop) {\n        debugLog(`get`, ptarget, prop)\n        const value =\n          changeTracker.copy_[prop as keyof T] ??\n          changeTracker.originalObject[prop as keyof T]\n\n        const originalValue = changeTracker.originalObject[prop as keyof T]\n\n        debugLog(`value (at top of proxy get)`, value)\n\n        // If it's a getter, return the value directly\n        const desc = Object.getOwnPropertyDescriptor(ptarget, prop)\n        if (desc?.get) {\n          return value\n        }\n\n        // If the value is a function, bind it to the ptarget\n        if (typeof value === `function`) {\n          // For Array methods that modify the array\n          if (Array.isArray(ptarget)) {\n            const methodName = prop.toString()\n\n            if (ARRAY_MODIFYING_METHODS.has(methodName)) {\n              return createModifyingMethodHandler(\n                value,\n                changeTracker,\n                markChanged,\n              )\n            }\n\n            // Handle array iteration methods (find, filter, forEach, etc.)\n            const iterationHandler = createArrayIterationHandler(\n              methodName,\n              value,\n              changeTracker,\n              memoizedCreateChangeProxy,\n            )\n            if (iterationHandler) {\n              return iterationHandler\n            }\n\n            // Handle array Symbol.iterator for for...of loops\n            if (prop === Symbol.iterator) {\n              return createArrayIteratorHandler(\n                changeTracker,\n                memoizedCreateChangeProxy,\n              )\n            }\n          }\n\n          // For Map and Set methods that modify the collection\n          if (ptarget instanceof Map || ptarget instanceof Set) {\n            const methodName = prop.toString()\n\n            if (MAP_SET_MODIFYING_METHODS.has(methodName)) {\n              return createModifyingMethodHandler(\n                value,\n                changeTracker,\n                markChanged,\n              )\n            }\n\n            // Handle iterator methods for Map and Set\n            const iteratorHandler = createMapSetIteratorHandler(\n              methodName,\n              prop,\n              value,\n              ptarget,\n              changeTracker,\n              memoizedCreateChangeProxy,\n              markChanged,\n            )\n            if (iteratorHandler) {\n              return iteratorHandler\n            }\n          }\n          return value.bind(ptarget)\n        }\n\n        // If the value is an object (but not Date, RegExp, or Temporal), create a proxy for it\n        if (isProxiableObject(value)) {\n          // Create a parent reference for the nested object\n          const nestedParent = {\n            tracker: changeTracker,\n            prop: String(prop),\n          }\n\n          // Create a proxy for the nested object\n          const { proxy: nestedProxy } = memoizedCreateChangeProxy(\n            originalValue,\n            nestedParent,\n          )\n\n          // Cache the proxy\n          proxyCache.set(value, nestedProxy)\n\n          return nestedProxy\n        }\n\n        return value\n      },\n\n      set(_sobj, prop, value) {\n        const currentValue = changeTracker.copy_[prop as keyof T]\n        debugLog(\n          `set called for property ${String(prop)}, current:`,\n          currentValue,\n          `new:`,\n          value,\n        )\n\n        // Only track the change if the value is actually different\n        if (!deepEquals(currentValue, value)) {\n          // Check if the new value is equal to the original value\n          // Important: Use the originalObject to get the true original value\n          const originalValue = changeTracker.originalObject[prop as keyof T]\n          const isRevertToOriginal = deepEquals(value, originalValue)\n          debugLog(\n            `value:`,\n            value,\n            `original:`,\n            originalValue,\n            `isRevertToOriginal:`,\n            isRevertToOriginal,\n          )\n\n          if (isRevertToOriginal) {\n            debugLog(`Reverting property ${String(prop)} to original value`)\n            // If the value is reverted to its original state, remove it from changes\n            delete changeTracker.assigned_[prop.toString()]\n\n            // Make sure the copy is updated with the original value\n            debugLog(`Updating copy with original value for ${String(prop)}`)\n            changeTracker.copy_[prop as keyof T] = deepClone(originalValue)\n\n            // Check if all properties in this object have been reverted\n            debugLog(`Checking if all properties reverted`)\n            const allReverted = checkIfReverted(changeTracker)\n            debugLog(`All reverted:`, allReverted)\n\n            if (allReverted) {\n              debugLog(`All properties reverted, clearing tracking`)\n              // If all have been reverted, clear tracking\n              changeTracker.modified = false\n              changeTracker.assigned_ = {}\n\n              // If we're a nested object, check if the parent needs updating\n              if (parent) {\n                debugLog(`Updating parent for property:`, parent.prop)\n                checkParentStatus(parent.tracker, parent.prop)\n              }\n            } else {\n              // Some properties are still changed\n              debugLog(`Some properties still changed, keeping modified flag`)\n              changeTracker.modified = true\n            }\n          } else {\n            debugLog(`Setting new value for property ${String(prop)}`)\n\n            // Set the value on the copy\n            changeTracker.copy_[prop as keyof T] = value\n\n            // Track that this property was assigned - store using the actual property (symbol or string)\n            changeTracker.assigned_[prop.toString()] = true\n\n            // Mark this object and its ancestors as modified\n            debugLog(`Marking object and ancestors as modified`, changeTracker)\n            markChanged(changeTracker)\n          }\n        } else {\n          debugLog(`Value unchanged, not tracking`)\n        }\n\n        return true\n      },\n\n      defineProperty(ptarget, prop, descriptor) {\n        // Forward the defineProperty to the target to maintain Proxy invariants\n        // This allows Object.seal() and Object.freeze() to work on the proxy\n        const result = Reflect.defineProperty(ptarget, prop, descriptor)\n        if (result && `value` in descriptor) {\n          changeTracker.copy_[prop as keyof T] = deepClone(descriptor.value)\n          changeTracker.assigned_[prop.toString()] = true\n          markChanged(changeTracker)\n        }\n        return result\n      },\n\n      getOwnPropertyDescriptor(ptarget, prop) {\n        // Forward to target to maintain Proxy invariants for seal/freeze\n        return Reflect.getOwnPropertyDescriptor(ptarget, prop)\n      },\n\n      preventExtensions(ptarget) {\n        // Forward to target to allow Object.seal() and Object.preventExtensions()\n        return Reflect.preventExtensions(ptarget)\n      },\n\n      isExtensible(ptarget) {\n        // Forward to target to maintain consistency\n        return Reflect.isExtensible(ptarget)\n      },\n\n      deleteProperty(dobj, prop) {\n        debugLog(`deleteProperty`, dobj, prop)\n        const stringProp = typeof prop === `symbol` ? prop.toString() : prop\n\n        if (stringProp in dobj) {\n          // Check if the property exists in the original object\n          const hadPropertyInOriginal =\n            stringProp in changeTracker.originalObject\n\n          // Forward the delete to the target using Reflect\n          // This respects Object.seal/preventExtensions constraints\n          const result = Reflect.deleteProperty(dobj, prop)\n\n          if (result) {\n            // If the property didn't exist in the original object, removing it\n            // should revert to the original state\n            if (!hadPropertyInOriginal) {\n              delete changeTracker.assigned_[stringProp]\n\n              // If this is the last change and we're not a nested object,\n              // mark the object as unmodified\n              if (\n                Object.keys(changeTracker.assigned_).length === 0 &&\n                Object.getOwnPropertySymbols(changeTracker.assigned_).length ===\n                  0\n              ) {\n                changeTracker.modified = false\n              } else {\n                // We still have changes, keep as modified\n                changeTracker.modified = true\n              }\n            } else {\n              // Mark this property as deleted\n              changeTracker.assigned_[stringProp] = false\n              markChanged(changeTracker)\n            }\n          }\n\n          return result\n        }\n\n        return true\n      },\n    })\n\n    // Cache the proxy\n    proxyCache.set(obj, proxy)\n\n    return proxy\n  }\n\n  // Create a proxy for the target object\n  // Use the unfrozen copy_ as the proxy target to avoid Proxy invariant violations\n  // when the original target is frozen (e.g., from Immer)\n  const proxy = createObjectProxy(changeTracker.copy_ as unknown as T)\n\n  // Return the proxy and a function to get the changes\n  return {\n    proxy,\n    getChanges: () => {\n      debugLog(`getChanges called, modified:`, changeTracker.modified)\n      debugLog(changeTracker)\n\n      // First, check if the object is still considered modified\n      if (!changeTracker.modified) {\n        debugLog(`Object not modified, returning empty object`)\n        return {}\n      }\n\n      // If we have a copy, return it directly\n      // Check if valueObj is actually an object\n      if (\n        typeof changeTracker.copy_ !== `object` ||\n        Array.isArray(changeTracker.copy_)\n      ) {\n        return changeTracker.copy_\n      }\n\n      if (Object.keys(changeTracker.assigned_).length === 0) {\n        return changeTracker.copy_\n      }\n\n      const result: Record<string, any | undefined> = {}\n\n      // Iterate through keys in keyObj\n      for (const key in changeTracker.copy_) {\n        // If the key's value is true and the key exists in valueObj\n        if (\n          changeTracker.assigned_[key] === true &&\n          key in changeTracker.copy_\n        ) {\n          result[key] = changeTracker.copy_[key]\n        }\n      }\n      debugLog(`Returning copy:`, result)\n      return result as unknown as Record<string | symbol, unknown>\n    },\n  }\n}\n\n/**\n * Creates proxies for an array of objects and tracks changes to each\n *\n * @param targets Array of objects to proxy\n * @returns An object containing the array of proxies and a function to get all changes\n */\nexport function createArrayChangeProxy<T extends object>(\n  targets: Array<T>,\n): {\n  proxies: Array<T>\n  getChanges: () => Array<Record<string | symbol, unknown>>\n} {\n  const proxiesWithChanges = targets.map((target) => createChangeProxy(target))\n\n  return {\n    proxies: proxiesWithChanges.map((p) => p.proxy),\n    getChanges: () => proxiesWithChanges.map((p) => p.getChanges()),\n  }\n}\n\n/**\n * Creates a proxy for an object, passes it to a callback function,\n * and returns the changes made by the callback\n *\n * @param target The object to proxy\n * @param callback Function that receives the proxy and can make changes to it\n * @returns The changes made to the object\n */\nexport function withChangeTracking<T extends object>(\n  target: T,\n  callback: (proxy: T) => void,\n): Record<string | symbol, unknown> {\n  const { proxy, getChanges } = createChangeProxy(target)\n\n  callback(proxy)\n\n  return getChanges()\n}\n\n/**\n * Creates proxies for an array of objects, passes them to a callback function,\n * and returns the changes made by the callback for each object\n *\n * @param targets Array of objects to proxy\n * @param callback Function that receives the proxies and can make changes to them\n * @returns Array of changes made to each object\n */\nexport function withArrayChangeTracking<T extends object>(\n  targets: Array<T>,\n  callback: (proxies: Array<T>) => void,\n): Array<Record<string | symbol, unknown>> {\n  const { proxies, getChanges } = createArrayChangeProxy(targets)\n\n  callback(proxies)\n\n  return getChanges()\n}\n"],"names":["clone","proxy"],"mappings":"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"}