import { CompareOptions } from '../query/builder/types.js';
import { OrderByDirection } from '../query/ir.js';
import { IndexInterface, IndexOperation, IndexStats } from './base-index.js';
import { RangeQueryOptions } from './btree-index.js';
export declare class ReverseIndex<TKey extends string | number> implements IndexInterface<TKey> {
    private originalIndex;
    constructor(index: IndexInterface<TKey>);
    lookup(operation: IndexOperation, value: any): Set<TKey>;
    rangeQuery(options?: RangeQueryOptions): Set<TKey>;
    rangeQueryReversed(options?: RangeQueryOptions): Set<TKey>;
    take(n: number, from?: any, filterFn?: (key: TKey) => boolean): Array<TKey>;
    takeReversed(n: number, from?: any, filterFn?: (key: TKey) => boolean): Array<TKey>;
    get orderedEntriesArray(): Array<[any, Set<TKey>]>;
    get orderedEntriesArrayReversed(): Array<[any, Set<TKey>]>;
    supports(operation: IndexOperation): boolean;
    matchesField(fieldPath: Array<string>): boolean;
    matchesCompareOptions(compareOptions: CompareOptions): boolean;
    matchesDirection(direction: OrderByDirection): boolean;
    getStats(): IndexStats;
    add(key: TKey, item: any): void;
    remove(key: TKey, item: any): void;
    update(key: TKey, oldItem: any, newItem: any): void;
    build(entries: Iterable<[TKey, any]>): void;
    clear(): void;
    get keyCount(): number;
    equalityLookup(value: any): Set<TKey>;
    inArrayLookup(values: Array<any>): Set<TKey>;
    get indexedKeysSet(): Set<TKey>;
    get valueMapData(): Map<any, Set<TKey>>;
}
