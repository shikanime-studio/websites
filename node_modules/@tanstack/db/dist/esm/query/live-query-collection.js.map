{"version":3,"file":"live-query-collection.js","sources":["../../../src/query/live-query-collection.ts"],"sourcesContent":["import { createCollection } from '../collection/index.js'\nimport { CollectionConfigBuilder } from './live/collection-config-builder.js'\nimport {\n  getBuilderFromConfig,\n  registerCollectionBuilder,\n} from './live/collection-registry.js'\nimport type { LiveQueryCollectionUtils } from './live/collection-config-builder.js'\nimport type { LiveQueryCollectionConfig } from './live/types.js'\nimport type { InitialQueryBuilder, QueryBuilder } from './builder/index.js'\nimport type { Collection } from '../collection/index.js'\nimport type {\n  CollectionConfig,\n  CollectionConfigSingleRowOption,\n  NonSingleResult,\n  SingleResult,\n  UtilsRecord,\n} from '../types.js'\nimport type { Context, GetResult } from './builder/types.js'\n\ntype CollectionConfigForContext<\n  TContext extends Context,\n  TResult extends object,\n  TUtils extends UtilsRecord = {},\n> = TContext extends SingleResult\n  ? CollectionConfigSingleRowOption<TResult, string | number, never, TUtils> &\n      SingleResult\n  : CollectionConfigSingleRowOption<TResult, string | number, never, TUtils> &\n      NonSingleResult\n\ntype CollectionForContext<\n  TContext extends Context,\n  TResult extends object,\n  TUtils extends UtilsRecord = {},\n> = TContext extends SingleResult\n  ? Collection<TResult, string | number, TUtils> & SingleResult\n  : Collection<TResult, string | number, TUtils> & NonSingleResult\n\n/**\n * Creates live query collection options for use with createCollection\n *\n * @example\n * ```typescript\n * const options = liveQueryCollectionOptions({\n *   // id is optional - will auto-generate if not provided\n *   query: (q) => q\n *     .from({ post: postsCollection })\n *     .where(({ post }) => eq(post.published, true))\n *     .select(({ post }) => ({\n *       id: post.id,\n *       title: post.title,\n *       content: post.content,\n *     })),\n *   // getKey is optional - will use stream key if not provided\n * })\n *\n * const collection = createCollection(options)\n * ```\n *\n * @param config - Configuration options for the live query collection\n * @returns Collection options that can be passed to createCollection\n */\nexport function liveQueryCollectionOptions<\n  TContext extends Context,\n  TResult extends object = GetResult<TContext>,\n>(\n  config: LiveQueryCollectionConfig<TContext, TResult>,\n): CollectionConfigForContext<TContext, TResult> & {\n  utils: LiveQueryCollectionUtils\n} {\n  const collectionConfigBuilder = new CollectionConfigBuilder<\n    TContext,\n    TResult\n  >(config)\n  return collectionConfigBuilder.getConfig() as CollectionConfigForContext<\n    TContext,\n    TResult\n  > & { utils: LiveQueryCollectionUtils }\n}\n\n/**\n * Creates a live query collection directly\n *\n * @example\n * ```typescript\n * // Minimal usage - just pass a query function\n * const activeUsers = createLiveQueryCollection(\n *   (q) => q\n *     .from({ user: usersCollection })\n *     .where(({ user }) => eq(user.active, true))\n *     .select(({ user }) => ({ id: user.id, name: user.name }))\n * )\n *\n * // Full configuration with custom options\n * const searchResults = createLiveQueryCollection({\n *   id: \"search-results\", // Custom ID (auto-generated if omitted)\n *   query: (q) => q\n *     .from({ post: postsCollection })\n *     .where(({ post }) => like(post.title, `%${searchTerm}%`))\n *     .select(({ post }) => ({\n *       id: post.id,\n *       title: post.title,\n *       excerpt: post.excerpt,\n *     })),\n *   getKey: (item) => item.id, // Custom key function (uses stream key if omitted)\n *   utils: {\n *     updateSearchTerm: (newTerm: string) => {\n *       // Custom utility functions\n *     }\n *   }\n * })\n * ```\n */\n\n// Overload 1: Accept just the query function\nexport function createLiveQueryCollection<\n  TContext extends Context,\n  TResult extends object = GetResult<TContext>,\n>(\n  query: (q: InitialQueryBuilder) => QueryBuilder<TContext>,\n): CollectionForContext<TContext, TResult> & {\n  utils: LiveQueryCollectionUtils\n}\n\n// Overload 2: Accept full config object with optional utilities\nexport function createLiveQueryCollection<\n  TContext extends Context,\n  TResult extends object = GetResult<TContext>,\n  TUtils extends UtilsRecord = {},\n>(\n  config: LiveQueryCollectionConfig<TContext, TResult> & { utils?: TUtils },\n): CollectionForContext<TContext, TResult> & {\n  utils: LiveQueryCollectionUtils & TUtils\n}\n\n// Implementation\nexport function createLiveQueryCollection<\n  TContext extends Context,\n  TResult extends object = GetResult<TContext>,\n  TUtils extends UtilsRecord = {},\n>(\n  configOrQuery:\n    | (LiveQueryCollectionConfig<TContext, TResult> & { utils?: TUtils })\n    | ((q: InitialQueryBuilder) => QueryBuilder<TContext>),\n): CollectionForContext<TContext, TResult> & {\n  utils: LiveQueryCollectionUtils & TUtils\n} {\n  // Determine if the argument is a function (query) or a config object\n  if (typeof configOrQuery === `function`) {\n    // Simple query function case\n    const config: LiveQueryCollectionConfig<TContext, TResult> = {\n      query: configOrQuery as (\n        q: InitialQueryBuilder,\n      ) => QueryBuilder<TContext>,\n    }\n    const options = liveQueryCollectionOptions<TContext, TResult>(config)\n    return bridgeToCreateCollection(options) as CollectionForContext<\n      TContext,\n      TResult\n    > & { utils: LiveQueryCollectionUtils & TUtils }\n  } else {\n    // Config object case\n    const config = configOrQuery as LiveQueryCollectionConfig<\n      TContext,\n      TResult\n    > & { utils?: TUtils }\n    const options = liveQueryCollectionOptions<TContext, TResult>(config)\n\n    // Merge custom utils if provided, preserving the getBuilder() method for dependency tracking\n    if (config.utils) {\n      options.utils = { ...options.utils, ...config.utils }\n    }\n\n    return bridgeToCreateCollection(options) as CollectionForContext<\n      TContext,\n      TResult\n    > & { utils: LiveQueryCollectionUtils & TUtils }\n  }\n}\n\n/**\n * Bridge function that handles the type compatibility between query2's TResult\n * and core collection's output type without exposing ugly type assertions to users\n */\nfunction bridgeToCreateCollection<\n  TResult extends object,\n  TUtils extends UtilsRecord = {},\n>(\n  options: CollectionConfig<TResult> & { utils: TUtils },\n): Collection<TResult, string | number, TUtils> {\n  const collection = createCollection(options as any) as unknown as Collection<\n    TResult,\n    string | number,\n    LiveQueryCollectionUtils\n  >\n\n  const builder = getBuilderFromConfig(options)\n  if (builder) {\n    registerCollectionBuilder(collection, builder)\n  }\n\n  return collection as unknown as Collection<TResult, string | number, TUtils>\n}\n"],"names":[],"mappings":";;;AA6DO,SAAS,2BAId,QAGA;AACA,QAAM,0BAA0B,IAAI,wBAGlC,MAAM;AACR,SAAO,wBAAwB,UAAA;AAIjC;AA0DO,SAAS,0BAKd,eAKA;AAEA,MAAI,OAAO,kBAAkB,YAAY;AAEvC,UAAM,SAAuD;AAAA,MAC3D,OAAO;AAAA,IAAA;AAIT,UAAM,UAAU,2BAA8C,MAAM;AACpE,WAAO,yBAAyB,OAAO;AAAA,EAIzC,OAAO;AAEL,UAAM,SAAS;AAIf,UAAM,UAAU,2BAA8C,MAAM;AAGpE,QAAI,OAAO,OAAO;AAChB,cAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,GAAG,OAAO,MAAA;AAAA,IAChD;AAEA,WAAO,yBAAyB,OAAO;AAAA,EAIzC;AACF;AAMA,SAAS,yBAIP,SAC8C;AAC9C,QAAM,aAAa,iBAAiB,OAAc;AAMlD,QAAM,UAAU,qBAAqB,OAAO;AAC5C,MAAI,SAAS;AACX,8BAA0B,YAAY,OAAO;AAAA,EAC/C;AAEA,SAAO;AACT;"}