{"version":3,"file":"functions.js","sources":["../../../../src/query/builder/functions.ts"],"sourcesContent":["import { Aggregate, Func } from '../ir'\nimport { toExpression } from './ref-proxy.js'\nimport type { BasicExpression } from '../ir'\nimport type { RefProxy } from './ref-proxy.js'\nimport type { RefLeaf } from './types.js'\n\ntype StringRef =\n  | RefLeaf<string>\n  | RefLeaf<string | null>\n  | RefLeaf<string | undefined>\ntype StringRefProxy =\n  | RefProxy<string>\n  | RefProxy<string | null>\n  | RefProxy<string | undefined>\ntype StringBasicExpression =\n  | BasicExpression<string>\n  | BasicExpression<string | null>\n  | BasicExpression<string | undefined>\ntype StringLike =\n  | StringRef\n  | StringRefProxy\n  | StringBasicExpression\n  | string\n  | null\n  | undefined\n\ntype ComparisonOperand<T> =\n  | RefProxy<T>\n  | RefLeaf<T>\n  | T\n  | BasicExpression<T>\n  | undefined\n  | null\ntype ComparisonOperandPrimitive<T extends string | number | boolean> =\n  | T\n  | BasicExpression<T>\n  | undefined\n  | null\n\n// Helper type for any expression-like value\ntype ExpressionLike = BasicExpression | RefProxy<any> | RefLeaf<any> | any\n\n// Helper type to extract the underlying type from various expression types\ntype ExtractType<T> =\n  T extends RefProxy<infer U>\n    ? U\n    : T extends RefLeaf<infer U>\n      ? U\n      : T extends BasicExpression<infer U>\n        ? U\n        : T\n\n// Helper type to determine aggregate return type based on input nullability\ntype AggregateReturnType<T> =\n  ExtractType<T> extends infer U\n    ? U extends number | undefined | null | Date | bigint\n      ? Aggregate<U>\n      : Aggregate<number | undefined | null | Date | bigint>\n    : Aggregate<number | undefined | null | Date | bigint>\n\n// Helper type to determine string function return type based on input nullability\ntype StringFunctionReturnType<T> =\n  ExtractType<T> extends infer U\n    ? U extends string | undefined | null\n      ? BasicExpression<U>\n      : BasicExpression<string | undefined | null>\n    : BasicExpression<string | undefined | null>\n\n// Helper type to determine numeric function return type based on input nullability\n// This handles string, array, and number inputs for functions like length()\ntype NumericFunctionReturnType<T> =\n  ExtractType<T> extends infer U\n    ? U extends string | Array<any> | undefined | null | number\n      ? BasicExpression<MapToNumber<U>>\n      : BasicExpression<number | undefined | null>\n    : BasicExpression<number | undefined | null>\n\n// Transform string/array types to number while preserving nullability\ntype MapToNumber<T> = T extends string | Array<any>\n  ? number\n  : T extends undefined\n    ? undefined\n    : T extends null\n      ? null\n      : T\n\n// Helper type for binary numeric operations (combines nullability of both operands)\ntype BinaryNumericReturnType<T1, T2> =\n  ExtractType<T1> extends infer U1\n    ? ExtractType<T2> extends infer U2\n      ? U1 extends number\n        ? U2 extends number\n          ? BasicExpression<number>\n          : U2 extends number | undefined\n            ? BasicExpression<number | undefined>\n            : U2 extends number | null\n              ? BasicExpression<number | null>\n              : BasicExpression<number | undefined | null>\n        : U1 extends number | undefined\n          ? U2 extends number\n            ? BasicExpression<number | undefined>\n            : U2 extends number | undefined\n              ? BasicExpression<number | undefined>\n              : BasicExpression<number | undefined | null>\n          : U1 extends number | null\n            ? U2 extends number\n              ? BasicExpression<number | null>\n              : BasicExpression<number | undefined | null>\n            : BasicExpression<number | undefined | null>\n      : BasicExpression<number | undefined | null>\n    : BasicExpression<number | undefined | null>\n\n// Operators\n\nexport function eq<T>(\n  left: ComparisonOperand<T>,\n  right: ComparisonOperand<T>,\n): BasicExpression<boolean>\nexport function eq<T extends string | number | boolean>(\n  left: ComparisonOperandPrimitive<T>,\n  right: ComparisonOperandPrimitive<T>,\n): BasicExpression<boolean>\nexport function eq<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function eq(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`eq`, [toExpression(left), toExpression(right)])\n}\n\nexport function gt<T>(\n  left: ComparisonOperand<T>,\n  right: ComparisonOperand<T>,\n): BasicExpression<boolean>\nexport function gt<T extends string | number>(\n  left: ComparisonOperandPrimitive<T>,\n  right: ComparisonOperandPrimitive<T>,\n): BasicExpression<boolean>\nexport function gt<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function gt(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`gt`, [toExpression(left), toExpression(right)])\n}\n\nexport function gte<T>(\n  left: ComparisonOperand<T>,\n  right: ComparisonOperand<T>,\n): BasicExpression<boolean>\nexport function gte<T extends string | number>(\n  left: ComparisonOperandPrimitive<T>,\n  right: ComparisonOperandPrimitive<T>,\n): BasicExpression<boolean>\nexport function gte<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function gte(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`gte`, [toExpression(left), toExpression(right)])\n}\n\nexport function lt<T>(\n  left: ComparisonOperand<T>,\n  right: ComparisonOperand<T>,\n): BasicExpression<boolean>\nexport function lt<T extends string | number>(\n  left: ComparisonOperandPrimitive<T>,\n  right: ComparisonOperandPrimitive<T>,\n): BasicExpression<boolean>\nexport function lt<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function lt(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`lt`, [toExpression(left), toExpression(right)])\n}\n\nexport function lte<T>(\n  left: ComparisonOperand<T>,\n  right: ComparisonOperand<T>,\n): BasicExpression<boolean>\nexport function lte<T extends string | number>(\n  left: ComparisonOperandPrimitive<T>,\n  right: ComparisonOperandPrimitive<T>,\n): BasicExpression<boolean>\nexport function lte<T>(left: Aggregate<T>, right: any): BasicExpression<boolean>\nexport function lte(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`lte`, [toExpression(left), toExpression(right)])\n}\n\n// Overloads for and() - support 2 or more arguments\nexport function and(\n  left: ExpressionLike,\n  right: ExpressionLike,\n): BasicExpression<boolean>\nexport function and(\n  left: ExpressionLike,\n  right: ExpressionLike,\n  ...rest: Array<ExpressionLike>\n): BasicExpression<boolean>\nexport function and(\n  left: ExpressionLike,\n  right: ExpressionLike,\n  ...rest: Array<ExpressionLike>\n): BasicExpression<boolean> {\n  const allArgs = [left, right, ...rest]\n  return new Func(\n    `and`,\n    allArgs.map((arg) => toExpression(arg)),\n  )\n}\n\n// Overloads for or() - support 2 or more arguments\nexport function or(\n  left: ExpressionLike,\n  right: ExpressionLike,\n): BasicExpression<boolean>\nexport function or(\n  left: ExpressionLike,\n  right: ExpressionLike,\n  ...rest: Array<ExpressionLike>\n): BasicExpression<boolean>\nexport function or(\n  left: ExpressionLike,\n  right: ExpressionLike,\n  ...rest: Array<ExpressionLike>\n): BasicExpression<boolean> {\n  const allArgs = [left, right, ...rest]\n  return new Func(\n    `or`,\n    allArgs.map((arg) => toExpression(arg)),\n  )\n}\n\nexport function not(value: ExpressionLike): BasicExpression<boolean> {\n  return new Func(`not`, [toExpression(value)])\n}\n\n// Null/undefined checking functions\nexport function isUndefined(value: ExpressionLike): BasicExpression<boolean> {\n  return new Func(`isUndefined`, [toExpression(value)])\n}\n\nexport function isNull(value: ExpressionLike): BasicExpression<boolean> {\n  return new Func(`isNull`, [toExpression(value)])\n}\n\nexport function inArray(\n  value: ExpressionLike,\n  array: ExpressionLike,\n): BasicExpression<boolean> {\n  return new Func(`in`, [toExpression(value), toExpression(array)])\n}\n\nexport function like(\n  left: StringLike,\n  right: StringLike,\n): BasicExpression<boolean>\nexport function like(left: any, right: any): BasicExpression<boolean> {\n  return new Func(`like`, [toExpression(left), toExpression(right)])\n}\n\nexport function ilike(\n  left: StringLike,\n  right: StringLike,\n): BasicExpression<boolean> {\n  return new Func(`ilike`, [toExpression(left), toExpression(right)])\n}\n\n// Functions\n\nexport function upper<T extends ExpressionLike>(\n  arg: T,\n): StringFunctionReturnType<T> {\n  return new Func(`upper`, [toExpression(arg)]) as StringFunctionReturnType<T>\n}\n\nexport function lower<T extends ExpressionLike>(\n  arg: T,\n): StringFunctionReturnType<T> {\n  return new Func(`lower`, [toExpression(arg)]) as StringFunctionReturnType<T>\n}\n\nexport function length<T extends ExpressionLike>(\n  arg: T,\n): NumericFunctionReturnType<T> {\n  return new Func(`length`, [toExpression(arg)]) as NumericFunctionReturnType<T>\n}\n\nexport function concat(\n  ...args: Array<ExpressionLike>\n): BasicExpression<string> {\n  return new Func(\n    `concat`,\n    args.map((arg) => toExpression(arg)),\n  )\n}\n\nexport function coalesce(...args: Array<ExpressionLike>): BasicExpression<any> {\n  return new Func(\n    `coalesce`,\n    args.map((arg) => toExpression(arg)),\n  )\n}\n\nexport function add<T1 extends ExpressionLike, T2 extends ExpressionLike>(\n  left: T1,\n  right: T2,\n): BinaryNumericReturnType<T1, T2> {\n  return new Func(`add`, [\n    toExpression(left),\n    toExpression(right),\n  ]) as BinaryNumericReturnType<T1, T2>\n}\n\n// Aggregates\n\nexport function count(arg: ExpressionLike): Aggregate<number> {\n  return new Aggregate(`count`, [toExpression(arg)])\n}\n\nexport function avg<T extends ExpressionLike>(arg: T): AggregateReturnType<T> {\n  return new Aggregate(`avg`, [toExpression(arg)]) as AggregateReturnType<T>\n}\n\nexport function sum<T extends ExpressionLike>(arg: T): AggregateReturnType<T> {\n  return new Aggregate(`sum`, [toExpression(arg)]) as AggregateReturnType<T>\n}\n\nexport function min<T extends ExpressionLike>(arg: T): AggregateReturnType<T> {\n  return new Aggregate(`min`, [toExpression(arg)]) as AggregateReturnType<T>\n}\n\nexport function max<T extends ExpressionLike>(arg: T): AggregateReturnType<T> {\n  return new Aggregate(`max`, [toExpression(arg)]) as AggregateReturnType<T>\n}\n\n/**\n * List of comparison function names that can be used with indexes\n */\nexport const comparisonFunctions = [\n  `eq`,\n  `gt`,\n  `gte`,\n  `lt`,\n  `lte`,\n  `in`,\n  `like`,\n  `ilike`,\n] as const\n\n/**\n * All supported operator names in TanStack DB expressions\n */\nexport const operators = [\n  // Comparison operators\n  `eq`,\n  `gt`,\n  `gte`,\n  `lt`,\n  `lte`,\n  `in`,\n  `like`,\n  `ilike`,\n  // Logical operators\n  `and`,\n  `or`,\n  `not`,\n  // Null checking\n  `isNull`,\n  `isUndefined`,\n  // String functions\n  `upper`,\n  `lower`,\n  `length`,\n  `concat`,\n  // Numeric functions\n  `add`,\n  // Utility functions\n  `coalesce`,\n  // Aggregate functions\n  `count`,\n  `avg`,\n  `sum`,\n  `min`,\n  `max`,\n] as const\n\nexport type OperatorName = (typeof operators)[number]\n"],"names":[],"mappings":";;AA2HO,SAAS,GAAG,MAAW,OAAsC;AAClE,SAAO,IAAI,KAAK,MAAM,CAAC,aAAa,IAAI,GAAG,aAAa,KAAK,CAAC,CAAC;AACjE;AAWO,SAAS,GAAG,MAAW,OAAsC;AAClE,SAAO,IAAI,KAAK,MAAM,CAAC,aAAa,IAAI,GAAG,aAAa,KAAK,CAAC,CAAC;AACjE;AAWO,SAAS,IAAI,MAAW,OAAsC;AACnE,SAAO,IAAI,KAAK,OAAO,CAAC,aAAa,IAAI,GAAG,aAAa,KAAK,CAAC,CAAC;AAClE;AAWO,SAAS,GAAG,MAAW,OAAsC;AAClE,SAAO,IAAI,KAAK,MAAM,CAAC,aAAa,IAAI,GAAG,aAAa,KAAK,CAAC,CAAC;AACjE;AAWO,SAAS,IAAI,MAAW,OAAsC;AACnE,SAAO,IAAI,KAAK,OAAO,CAAC,aAAa,IAAI,GAAG,aAAa,KAAK,CAAC,CAAC;AAClE;AAYO,SAAS,IACd,MACA,UACG,MACuB;AAC1B,QAAM,UAAU,CAAC,MAAM,OAAO,GAAG,IAAI;AACrC,SAAO,IAAI;AAAA,IACT;AAAA,IACA,QAAQ,IAAI,CAAC,QAAQ,aAAa,GAAG,CAAC;AAAA,EAAA;AAE1C;AAYO,SAAS,GACd,MACA,UACG,MACuB;AAC1B,QAAM,UAAU,CAAC,MAAM,OAAO,GAAG,IAAI;AACrC,SAAO,IAAI;AAAA,IACT;AAAA,IACA,QAAQ,IAAI,CAAC,QAAQ,aAAa,GAAG,CAAC;AAAA,EAAA;AAE1C;AAEO,SAAS,IAAI,OAAiD;AACnE,SAAO,IAAI,KAAK,OAAO,CAAC,aAAa,KAAK,CAAC,CAAC;AAC9C;AAGO,SAAS,YAAY,OAAiD;AAC3E,SAAO,IAAI,KAAK,eAAe,CAAC,aAAa,KAAK,CAAC,CAAC;AACtD;AAEO,SAAS,OAAO,OAAiD;AACtE,SAAO,IAAI,KAAK,UAAU,CAAC,aAAa,KAAK,CAAC,CAAC;AACjD;AAEO,SAAS,QACd,OACA,OAC0B;AAC1B,SAAO,IAAI,KAAK,MAAM,CAAC,aAAa,KAAK,GAAG,aAAa,KAAK,CAAC,CAAC;AAClE;AAMO,SAAS,KAAK,MAAW,OAAsC;AACpE,SAAO,IAAI,KAAK,QAAQ,CAAC,aAAa,IAAI,GAAG,aAAa,KAAK,CAAC,CAAC;AACnE;AAEO,SAAS,MACd,MACA,OAC0B;AAC1B,SAAO,IAAI,KAAK,SAAS,CAAC,aAAa,IAAI,GAAG,aAAa,KAAK,CAAC,CAAC;AACpE;AAIO,SAAS,MACd,KAC6B;AAC7B,SAAO,IAAI,KAAK,SAAS,CAAC,aAAa,GAAG,CAAC,CAAC;AAC9C;AAEO,SAAS,MACd,KAC6B;AAC7B,SAAO,IAAI,KAAK,SAAS,CAAC,aAAa,GAAG,CAAC,CAAC;AAC9C;AAEO,SAAS,OACd,KAC8B;AAC9B,SAAO,IAAI,KAAK,UAAU,CAAC,aAAa,GAAG,CAAC,CAAC;AAC/C;AAEO,SAAS,UACX,MACsB;AACzB,SAAO,IAAI;AAAA,IACT;AAAA,IACA,KAAK,IAAI,CAAC,QAAQ,aAAa,GAAG,CAAC;AAAA,EAAA;AAEvC;AAEO,SAAS,YAAY,MAAmD;AAC7E,SAAO,IAAI;AAAA,IACT;AAAA,IACA,KAAK,IAAI,CAAC,QAAQ,aAAa,GAAG,CAAC;AAAA,EAAA;AAEvC;AAEO,SAAS,IACd,MACA,OACiC;AACjC,SAAO,IAAI,KAAK,OAAO;AAAA,IACrB,aAAa,IAAI;AAAA,IACjB,aAAa,KAAK;AAAA,EAAA,CACnB;AACH;AAIO,SAAS,MAAM,KAAwC;AAC5D,SAAO,IAAI,UAAU,SAAS,CAAC,aAAa,GAAG,CAAC,CAAC;AACnD;AAEO,SAAS,IAA8B,KAAgC;AAC5E,SAAO,IAAI,UAAU,OAAO,CAAC,aAAa,GAAG,CAAC,CAAC;AACjD;AAEO,SAAS,IAA8B,KAAgC;AAC5E,SAAO,IAAI,UAAU,OAAO,CAAC,aAAa,GAAG,CAAC,CAAC;AACjD;AAEO,SAAS,IAA8B,KAAgC;AAC5E,SAAO,IAAI,UAAU,OAAO,CAAC,aAAa,GAAG,CAAC,CAAC;AACjD;AAEO,SAAS,IAA8B,KAAgC;AAC5E,SAAO,IAAI,UAAU,OAAO,CAAC,aAAa,GAAG,CAAC,CAAC;AACjD;AAKO,MAAM,sBAAsB;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAKO,MAAM,YAAY;AAAA;AAAA,EAEvB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;"}