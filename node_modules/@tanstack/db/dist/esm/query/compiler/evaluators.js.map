{"version":3,"file":"evaluators.js","sources":["../../../../src/query/compiler/evaluators.ts"],"sourcesContent":["import {\n  EmptyReferencePathError,\n  UnknownExpressionTypeError,\n  UnknownFunctionError,\n} from '../../errors.js'\nimport { areValuesEqual, normalizeValue } from '../../utils/comparison.js'\nimport type { BasicExpression, Func, PropRef } from '../ir.js'\nimport type { NamespacedRow } from '../../types.js'\n\n/**\n * Helper function to check if a value is null or undefined (represents UNKNOWN in 3-valued logic)\n */\nfunction isUnknown(value: any): boolean {\n  return value === null || value === undefined\n}\n\n/**\n * Converts a 3-valued logic result to a boolean for use in WHERE/HAVING filters.\n * In SQL, UNKNOWN (null) values in WHERE clauses exclude rows, matching false behavior.\n *\n * @param result - The 3-valued logic result: true, false, or null (UNKNOWN)\n * @returns true only if result is explicitly true, false otherwise\n *\n * Truth table:\n * - true → true (include row)\n * - false → false (exclude row)\n * - null (UNKNOWN) → false (exclude row, matching SQL behavior)\n */\nexport function toBooleanPredicate(result: boolean | null): boolean {\n  return result === true\n}\n\n/**\n * Compiled expression evaluator function type\n */\nexport type CompiledExpression = (namespacedRow: NamespacedRow) => any\n\n/**\n * Compiled single-row expression evaluator function type\n */\nexport type CompiledSingleRowExpression = (item: Record<string, unknown>) => any\n\n/**\n * Compiles an expression into an optimized evaluator function.\n * This eliminates branching during evaluation by pre-compiling the expression structure.\n */\nexport function compileExpression(\n  expr: BasicExpression,\n  isSingleRow: boolean = false,\n): CompiledExpression | CompiledSingleRowExpression {\n  const compiledFn = compileExpressionInternal(expr, isSingleRow)\n  return compiledFn\n}\n\n/**\n * Compiles a single-row expression into an optimized evaluator function.\n */\nexport function compileSingleRowExpression(\n  expr: BasicExpression,\n): CompiledSingleRowExpression {\n  const compiledFn = compileExpressionInternal(expr, true)\n  return compiledFn as CompiledSingleRowExpression\n}\n\n/**\n * Internal unified expression compiler that handles both namespaced and single-row evaluation\n */\nfunction compileExpressionInternal(\n  expr: BasicExpression,\n  isSingleRow: boolean,\n): (data: any) => any {\n  switch (expr.type) {\n    case `val`: {\n      // For constant values, return a function that just returns the value\n      const value = expr.value\n      return () => value\n    }\n\n    case `ref`: {\n      // For references, compile based on evaluation mode\n      return isSingleRow ? compileSingleRowRef(expr) : compileRef(expr)\n    }\n\n    case `func`: {\n      // For functions, use the unified compiler\n      return compileFunction(expr, isSingleRow)\n    }\n\n    default:\n      throw new UnknownExpressionTypeError((expr as any).type)\n  }\n}\n\n/**\n * Compiles a reference expression into an optimized evaluator\n */\nfunction compileRef(ref: PropRef): CompiledExpression {\n  const [tableAlias, ...propertyPath] = ref.path\n\n  if (!tableAlias) {\n    throw new EmptyReferencePathError()\n  }\n\n  // Pre-compile the property path navigation\n  if (propertyPath.length === 0) {\n    // Simple table reference\n    return (namespacedRow) => namespacedRow[tableAlias]\n  } else if (propertyPath.length === 1) {\n    // Single property access - most common case\n    const prop = propertyPath[0]!\n    return (namespacedRow) => {\n      const tableData = namespacedRow[tableAlias]\n      return tableData?.[prop]\n    }\n  } else {\n    // Multiple property navigation\n    return (namespacedRow) => {\n      const tableData = namespacedRow[tableAlias]\n      if (tableData === undefined) {\n        return undefined\n      }\n\n      let value: any = tableData\n      for (const prop of propertyPath) {\n        if (value == null) {\n          return value\n        }\n        value = value[prop]\n      }\n      return value\n    }\n  }\n}\n\n/**\n * Compiles a reference expression for single-row evaluation\n */\nfunction compileSingleRowRef(ref: PropRef): CompiledSingleRowExpression {\n  const propertyPath = ref.path\n\n  // This function works for all path lengths including empty path\n  return (item) => {\n    let value: any = item\n    for (const prop of propertyPath) {\n      if (value == null) {\n        return value\n      }\n      value = value[prop]\n    }\n    return value\n  }\n}\n\n/**\n * Compiles a function expression for both namespaced and single-row evaluation\n */\nfunction compileFunction(func: Func, isSingleRow: boolean): (data: any) => any {\n  // Pre-compile all arguments using the appropriate compiler\n  const compiledArgs = func.args.map((arg) =>\n    compileExpressionInternal(arg, isSingleRow),\n  )\n\n  switch (func.name) {\n    // Comparison operators\n    case `eq`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = normalizeValue(argA(data))\n        const b = normalizeValue(argB(data))\n        // In 3-valued logic, any comparison with null/undefined returns UNKNOWN\n        if (isUnknown(a) || isUnknown(b)) {\n          return null\n        }\n        // Use areValuesEqual for proper Uint8Array/Buffer comparison\n        return areValuesEqual(a, b)\n      }\n    }\n    case `gt`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        // In 3-valued logic, any comparison with null/undefined returns UNKNOWN\n        if (isUnknown(a) || isUnknown(b)) {\n          return null\n        }\n        return a > b\n      }\n    }\n    case `gte`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        // In 3-valued logic, any comparison with null/undefined returns UNKNOWN\n        if (isUnknown(a) || isUnknown(b)) {\n          return null\n        }\n        return a >= b\n      }\n    }\n    case `lt`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        // In 3-valued logic, any comparison with null/undefined returns UNKNOWN\n        if (isUnknown(a) || isUnknown(b)) {\n          return null\n        }\n        return a < b\n      }\n    }\n    case `lte`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        // In 3-valued logic, any comparison with null/undefined returns UNKNOWN\n        if (isUnknown(a) || isUnknown(b)) {\n          return null\n        }\n        return a <= b\n      }\n    }\n\n    // Boolean operators\n    case `and`:\n      return (data) => {\n        // 3-valued logic for AND:\n        // - false AND anything = false (short-circuit)\n        // - null AND false = false\n        // - null AND anything (except false) = null\n        // - anything (except false) AND null = null\n        // - true AND true = true\n        let hasUnknown = false\n        for (const compiledArg of compiledArgs) {\n          const result = compiledArg(data)\n          if (result === false) {\n            return false\n          }\n          if (isUnknown(result)) {\n            hasUnknown = true\n          }\n        }\n        // If we got here, no operand was false\n        // If any operand was null, return null (UNKNOWN)\n        if (hasUnknown) {\n          return null\n        }\n\n        return true\n      }\n    case `or`:\n      return (data) => {\n        // 3-valued logic for OR:\n        // - true OR anything = true (short-circuit)\n        // - null OR anything (except true) = null\n        // - false OR false = false\n        let hasUnknown = false\n        for (const compiledArg of compiledArgs) {\n          const result = compiledArg(data)\n          if (result === true) {\n            return true\n          }\n          if (isUnknown(result)) {\n            hasUnknown = true\n          }\n        }\n        // If we got here, no operand was true\n        // If any operand was null, return null (UNKNOWN)\n        if (hasUnknown) {\n          return null\n        }\n\n        return false\n      }\n    case `not`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        // 3-valued logic for NOT:\n        // - NOT null = null\n        // - NOT true = false\n        // - NOT false = true\n        const result = arg(data)\n        if (isUnknown(result)) {\n          return null\n        }\n        return !result\n      }\n    }\n\n    // Array operators\n    case `in`: {\n      const valueEvaluator = compiledArgs[0]!\n      const arrayEvaluator = compiledArgs[1]!\n      return (data) => {\n        const value = valueEvaluator(data)\n        const array = arrayEvaluator(data)\n        // In 3-valued logic, if the value is null/undefined, return UNKNOWN\n        if (isUnknown(value)) {\n          return null\n        }\n        if (!Array.isArray(array)) {\n          return false\n        }\n        return array.includes(value)\n      }\n    }\n\n    // String operators\n    case `like`: {\n      const valueEvaluator = compiledArgs[0]!\n      const patternEvaluator = compiledArgs[1]!\n      return (data) => {\n        const value = valueEvaluator(data)\n        const pattern = patternEvaluator(data)\n        // In 3-valued logic, if value or pattern is null/undefined, return UNKNOWN\n        if (isUnknown(value) || isUnknown(pattern)) {\n          return null\n        }\n        return evaluateLike(value, pattern, false)\n      }\n    }\n    case `ilike`: {\n      const valueEvaluator = compiledArgs[0]!\n      const patternEvaluator = compiledArgs[1]!\n      return (data) => {\n        const value = valueEvaluator(data)\n        const pattern = patternEvaluator(data)\n        // In 3-valued logic, if value or pattern is null/undefined, return UNKNOWN\n        if (isUnknown(value) || isUnknown(pattern)) {\n          return null\n        }\n        return evaluateLike(value, pattern, true)\n      }\n    }\n\n    // String functions\n    case `upper`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        const value = arg(data)\n        return typeof value === `string` ? value.toUpperCase() : value\n      }\n    }\n    case `lower`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        const value = arg(data)\n        return typeof value === `string` ? value.toLowerCase() : value\n      }\n    }\n    case `length`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        const value = arg(data)\n        if (typeof value === `string`) {\n          return value.length\n        }\n        if (Array.isArray(value)) {\n          return value.length\n        }\n        return 0\n      }\n    }\n    case `concat`:\n      return (data) => {\n        return compiledArgs\n          .map((evaluator) => {\n            const arg = evaluator(data)\n            try {\n              return String(arg ?? ``)\n            } catch {\n              try {\n                return JSON.stringify(arg) || ``\n              } catch {\n                return `[object]`\n              }\n            }\n          })\n          .join(``)\n      }\n    case `coalesce`:\n      return (data) => {\n        for (const evaluator of compiledArgs) {\n          const value = evaluator(data)\n          if (value !== null && value !== undefined) {\n            return value\n          }\n        }\n        return null\n      }\n\n    // Math functions\n    case `add`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return (a ?? 0) + (b ?? 0)\n      }\n    }\n    case `subtract`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return (a ?? 0) - (b ?? 0)\n      }\n    }\n    case `multiply`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        return (a ?? 0) * (b ?? 0)\n      }\n    }\n    case `divide`: {\n      const argA = compiledArgs[0]!\n      const argB = compiledArgs[1]!\n      return (data) => {\n        const a = argA(data)\n        const b = argB(data)\n        const divisor = b ?? 0\n        return divisor !== 0 ? (a ?? 0) / divisor : null\n      }\n    }\n\n    // Null/undefined checking functions\n    case `isUndefined`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        const value = arg(data)\n        return value === undefined\n      }\n    }\n    case `isNull`: {\n      const arg = compiledArgs[0]!\n      return (data) => {\n        const value = arg(data)\n        return value === null\n      }\n    }\n\n    default:\n      throw new UnknownFunctionError(func.name)\n  }\n}\n\n/**\n * Evaluates LIKE/ILIKE patterns\n */\nfunction evaluateLike(\n  value: any,\n  pattern: any,\n  caseInsensitive: boolean,\n): boolean {\n  if (typeof value !== `string` || typeof pattern !== `string`) {\n    return false\n  }\n\n  const searchValue = caseInsensitive ? value.toLowerCase() : value\n  const searchPattern = caseInsensitive ? pattern.toLowerCase() : pattern\n\n  // Convert SQL LIKE pattern to regex\n  // First escape all regex special chars except % and _\n  let regexPattern = searchPattern.replace(/[.*+?^${}()|[\\]\\\\]/g, `\\\\$&`)\n\n  // Then convert SQL wildcards to regex\n  regexPattern = regexPattern.replace(/%/g, `.*`) // % matches any sequence\n  regexPattern = regexPattern.replace(/_/g, `.`) // _ matches any single char\n\n  const regex = new RegExp(`^${regexPattern}$`)\n  return regex.test(searchValue)\n}\n"],"names":[],"mappings":"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"}