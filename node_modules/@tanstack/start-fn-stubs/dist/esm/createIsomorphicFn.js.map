{"version":3,"file":"createIsomorphicFn.js","sources":["../../src/createIsomorphicFn.ts"],"sourcesContent":["// a function that can have different implementations on the client and server.\n// implementations not provided will default to a no-op function.\n\nexport type IsomorphicFn<\n  TArgs extends Array<any> = [],\n  TServer = undefined,\n  TClient = undefined,\n> = (...args: TArgs) => TServer | TClient\n\nexport interface ServerOnlyFn<TArgs extends Array<any>, TServer>\n  extends IsomorphicFn<TArgs, TServer> {\n  client: <TClient>(\n    clientImpl: (...args: TArgs) => TClient,\n  ) => IsomorphicFn<TArgs, TServer, TClient>\n}\n\nexport interface ClientOnlyFn<TArgs extends Array<any>, TClient>\n  extends IsomorphicFn<TArgs, undefined, TClient> {\n  server: <TServer>(\n    serverImpl: (...args: TArgs) => TServer,\n  ) => IsomorphicFn<TArgs, TServer, TClient>\n}\n\nexport interface IsomorphicFnBase {\n  server: <TArgs extends Array<any>, TServer>(\n    serverImpl: (...args: TArgs) => TServer,\n  ) => ServerOnlyFn<TArgs, TServer>\n  client: <TArgs extends Array<any>, TClient>(\n    clientImpl: (...args: TArgs) => TClient,\n  ) => ClientOnlyFn<TArgs, TClient>\n}\n\n// this is a dummy function, it will be replaced by the transformer\n// if we use `createIsomorphicFn` in this library itself, vite tries to execute it before the transformer runs\n// therefore we must return a dummy function that allows calling `server` and `client` method chains.\nexport function createIsomorphicFn(): IsomorphicFnBase {\n  const fn = () => undefined\n  return Object.assign(fn, {\n    server: () => ({ client: () => () => {} }),\n    client: () => ({ server: () => () => {} }),\n  }) as any\n}\n"],"names":[],"mappings":"AAmCO,SAAS,qBAAuC;AACrD,QAAM,KAAK,MAAM;AACjB,SAAO,OAAO,OAAO,IAAI;AAAA,IACvB,QAAQ,OAAO,EAAE,QAAQ,MAAM,MAAM;AAAA,IAAC;IACtC,QAAQ,OAAO,EAAE,QAAQ,MAAM,MAAM;AAAA,IAAC,EAAA;AAAA,EAAE,CACzC;AACH;"}