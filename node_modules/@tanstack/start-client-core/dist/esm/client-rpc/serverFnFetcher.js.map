{"version":3,"file":"serverFnFetcher.js","sources":["../../../src/client-rpc/serverFnFetcher.ts"],"sourcesContent":["import {\n  createRawStreamDeserializePlugin,\n  encode,\n  isNotFound,\n  parseRedirect,\n} from '@tanstack/router-core'\nimport { fromCrossJSON, toJSONAsync } from 'seroval'\nimport invariant from 'tiny-invariant'\nimport { getDefaultSerovalPlugins } from '../getDefaultSerovalPlugins'\nimport {\n  TSS_CONTENT_TYPE_FRAMED,\n  TSS_FORMDATA_CONTEXT,\n  X_TSS_RAW_RESPONSE,\n  X_TSS_SERIALIZED,\n  validateFramedProtocolVersion,\n} from '../constants'\nimport { createFrameDecoder } from './frame-decoder'\nimport type { FunctionMiddlewareClientFnOptions } from '../createMiddleware'\nimport type { Plugin as SerovalPlugin } from 'seroval'\n\nlet serovalPlugins: Array<SerovalPlugin<any, any>> | null = null\n\n/**\n * Checks if an object has at least one own enumerable property.\n * More efficient than Object.keys(obj).length > 0 as it short-circuits on first property.\n */\nconst hop = Object.prototype.hasOwnProperty\nfunction hasOwnProperties(obj: object): boolean {\n  for (const _ in obj) {\n    if (hop.call(obj, _)) {\n      return true\n    }\n  }\n  return false\n}\n// caller =>\n//   serverFnFetcher =>\n//     client =>\n//       server =>\n//         fn =>\n//       seroval =>\n//     client middleware =>\n//   serverFnFetcher =>\n// caller\n\nexport async function serverFnFetcher(\n  url: string,\n  args: Array<any>,\n  handler: (url: string, requestInit: RequestInit) => Promise<Response>,\n) {\n  if (!serovalPlugins) {\n    serovalPlugins = getDefaultSerovalPlugins()\n  }\n  const _first = args[0]\n\n  const first = _first as FunctionMiddlewareClientFnOptions<any, any, any> & {\n    headers?: HeadersInit\n  }\n  const type = first.data instanceof FormData ? 'formData' : 'payload'\n\n  // Arrange the headers\n  const headers = first.headers ? new Headers(first.headers) : new Headers()\n  headers.set('x-tsr-serverFn', 'true')\n\n  if (type === 'payload') {\n    headers.set(\n      'accept',\n      `${TSS_CONTENT_TYPE_FRAMED}, application/x-ndjson, application/json`,\n    )\n  }\n\n  // If the method is GET, we need to move the payload to the query string\n  if (first.method === 'GET') {\n    if (type === 'formData') {\n      throw new Error('FormData is not supported with GET requests')\n    }\n    const serializedPayload = await serializePayload(first)\n    if (serializedPayload !== undefined) {\n      const encodedPayload = encode({\n        payload: serializedPayload,\n      })\n      if (url.includes('?')) {\n        url += `&${encodedPayload}`\n      } else {\n        url += `?${encodedPayload}`\n      }\n    }\n  }\n\n  let body = undefined\n  if (first.method === 'POST') {\n    const fetchBody = await getFetchBody(first)\n    if (fetchBody?.contentType) {\n      headers.set('content-type', fetchBody.contentType)\n    }\n    body = fetchBody?.body\n  }\n\n  return await getResponse(async () =>\n    handler(url, {\n      method: first.method,\n      headers,\n      signal: first.signal,\n      body,\n    }),\n  )\n}\n\nasync function serializePayload(\n  opts: FunctionMiddlewareClientFnOptions<any, any, any>,\n): Promise<string | undefined> {\n  let payloadAvailable = false\n  const payloadToSerialize: any = {}\n  if (opts.data !== undefined) {\n    payloadAvailable = true\n    payloadToSerialize['data'] = opts.data\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (opts.context && hasOwnProperties(opts.context)) {\n    payloadAvailable = true\n    payloadToSerialize['context'] = opts.context\n  }\n\n  if (payloadAvailable) {\n    return serialize(payloadToSerialize)\n  }\n  return undefined\n}\n\nasync function serialize(data: any) {\n  return JSON.stringify(\n    await Promise.resolve(toJSONAsync(data, { plugins: serovalPlugins! })),\n  )\n}\n\nasync function getFetchBody(\n  opts: FunctionMiddlewareClientFnOptions<any, any, any>,\n): Promise<{ body: FormData | string; contentType?: string } | undefined> {\n  if (opts.data instanceof FormData) {\n    let serializedContext = undefined\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (opts.context && hasOwnProperties(opts.context)) {\n      serializedContext = await serialize(opts.context)\n    }\n    if (serializedContext !== undefined) {\n      opts.data.set(TSS_FORMDATA_CONTEXT, serializedContext)\n    }\n    return { body: opts.data }\n  }\n  const serializedBody = await serializePayload(opts)\n  if (serializedBody) {\n    return { body: serializedBody, contentType: 'application/json' }\n  }\n  return undefined\n}\n\n/**\n * Retrieves a response from a given function and manages potential errors\n * and special response types including redirects and not found errors.\n *\n * @param fn - The function to execute for obtaining the response.\n * @returns The processed response from the function.\n * @throws If the response is invalid or an error occurs during processing.\n */\nasync function getResponse(fn: () => Promise<Response>) {\n  let response: Response\n  try {\n    response = await fn() // client => server => fn => server => client\n  } catch (error) {\n    if (error instanceof Response) {\n      response = error\n    } else {\n      console.log(error)\n      throw error\n    }\n  }\n\n  if (response.headers.get(X_TSS_RAW_RESPONSE) === 'true') {\n    return response\n  }\n\n  const contentType = response.headers.get('content-type')\n  invariant(contentType, 'expected content-type header to be set')\n  const serializedByStart = !!response.headers.get(X_TSS_SERIALIZED)\n\n  // If the response is serialized by the start server, we need to process it\n  // differently than a normal response.\n  if (serializedByStart) {\n    let result\n\n    // If it's a framed response (contains RawStream), use frame decoder\n    if (contentType.includes(TSS_CONTENT_TYPE_FRAMED)) {\n      // Validate protocol version compatibility\n      validateFramedProtocolVersion(contentType)\n\n      if (!response.body) {\n        throw new Error('No response body for framed response')\n      }\n\n      const { getOrCreateStream, jsonChunks } = createFrameDecoder(\n        response.body,\n      )\n\n      // Create deserialize plugin that wires up the raw streams\n      const rawStreamPlugin =\n        createRawStreamDeserializePlugin(getOrCreateStream)\n      const plugins = [rawStreamPlugin, ...(serovalPlugins || [])]\n\n      const refs = new Map()\n      result = await processFramedResponse({\n        jsonStream: jsonChunks,\n        onMessage: (msg: any) => fromCrossJSON(msg, { refs, plugins }),\n        onError(msg, error) {\n          console.error(msg, error)\n        },\n      })\n    }\n    // If it's a stream from the start serializer, process it as such\n    else if (contentType.includes('application/x-ndjson')) {\n      const refs = new Map()\n      result = await processServerFnResponse({\n        response,\n        onMessage: (msg) =>\n          fromCrossJSON(msg, { refs, plugins: serovalPlugins! }),\n        onError(msg, error) {\n          // TODO how could we notify consumer that an error occurred?\n          console.error(msg, error)\n        },\n      })\n    }\n    // If it's a JSON response, it can be simpler\n    else if (contentType.includes('application/json')) {\n      const jsonPayload = await response.json()\n      result = fromCrossJSON(jsonPayload, { plugins: serovalPlugins! })\n    }\n\n    invariant(result, 'expected result to be resolved')\n    if (result instanceof Error) {\n      throw result\n    }\n\n    return result\n  }\n\n  // If it wasn't processed by the start serializer, check\n  // if it's JSON\n  if (contentType.includes('application/json')) {\n    const jsonPayload = await response.json()\n    const redirect = parseRedirect(jsonPayload)\n    if (redirect) {\n      throw redirect\n    }\n    if (isNotFound(jsonPayload)) {\n      throw jsonPayload\n    }\n    return jsonPayload\n  }\n\n  // Otherwise, if it's not OK, throw the content\n  if (!response.ok) {\n    throw new Error(await response.text())\n  }\n\n  // Or return the response itself\n  return response\n}\n\nasync function processServerFnResponse({\n  response,\n  onMessage,\n  onError,\n}: {\n  response: Response\n  onMessage: (msg: any) => any\n  onError?: (msg: string, error?: any) => void\n}) {\n  if (!response.body) {\n    throw new Error('No response body')\n  }\n\n  const reader = response.body.pipeThrough(new TextDecoderStream()).getReader()\n\n  let buffer = ''\n  let firstRead = false\n  let firstObject\n\n  while (!firstRead) {\n    const { value, done } = await reader.read()\n    if (value) buffer += value\n\n    if (buffer.length === 0 && done) {\n      throw new Error('Stream ended before first object')\n    }\n\n    // common case: buffer ends with newline\n    if (buffer.endsWith('\\n')) {\n      const lines = buffer.split('\\n').filter(Boolean)\n      const firstLine = lines[0]\n      if (!firstLine) throw new Error('No JSON line in the first chunk')\n      firstObject = JSON.parse(firstLine)\n      firstRead = true\n      buffer = lines.slice(1).join('\\n')\n    } else {\n      // fallback: wait for a newline to parse first object safely\n      const newlineIndex = buffer.indexOf('\\n')\n      if (newlineIndex >= 0) {\n        const line = buffer.slice(0, newlineIndex).trim()\n        buffer = buffer.slice(newlineIndex + 1)\n        if (line.length > 0) {\n          firstObject = JSON.parse(line)\n          firstRead = true\n        }\n      }\n    }\n  }\n\n  // process rest of the stream asynchronously\n  ;(async () => {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      while (true) {\n        const { value, done } = await reader.read()\n        if (value) buffer += value\n\n        const lastNewline = buffer.lastIndexOf('\\n')\n        if (lastNewline >= 0) {\n          const chunk = buffer.slice(0, lastNewline)\n          buffer = buffer.slice(lastNewline + 1)\n          const lines = chunk.split('\\n').filter(Boolean)\n\n          for (const line of lines) {\n            try {\n              onMessage(JSON.parse(line))\n            } catch (e) {\n              onError?.(`Invalid JSON line: ${line}`, e)\n            }\n          }\n        }\n\n        if (done) {\n          break\n        }\n      }\n    } catch (err) {\n      onError?.('Stream processing error:', err)\n    }\n  })()\n\n  return onMessage(firstObject)\n}\n\n/**\n * Processes a framed response where each JSON chunk is a complete JSON string\n * (already decoded by frame decoder).\n */\nasync function processFramedResponse({\n  jsonStream,\n  onMessage,\n  onError,\n}: {\n  jsonStream: ReadableStream<string>\n  onMessage: (msg: any) => any\n  onError?: (msg: string, error?: any) => void\n}) {\n  const reader = jsonStream.getReader()\n\n  // Read first JSON frame - this is the main result\n  const { value: firstValue, done: firstDone } = await reader.read()\n  if (firstDone || !firstValue) {\n    throw new Error('Stream ended before first object')\n  }\n\n  // Each frame is a complete JSON string\n  const firstObject = JSON.parse(firstValue)\n\n  // Process remaining frames asynchronously (for streaming refs like RawStream)\n  ;(async () => {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      while (true) {\n        const { value, done } = await reader.read()\n        if (done) break\n        if (value) {\n          try {\n            onMessage(JSON.parse(value))\n          } catch (e) {\n            onError?.(`Invalid JSON: ${value}`, e)\n          }\n        }\n      }\n    } catch (err) {\n      onError?.('Stream processing error:', err)\n    }\n  })()\n\n  return onMessage(firstObject)\n}\n"],"names":[],"mappings":"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"}