{"version":3,"file":"frame-decoder.js","sources":["../../../src/client-rpc/frame-decoder.ts"],"sourcesContent":["/**\n * Client-side frame decoder for multiplexed responses.\n *\n * Decodes binary frame protocol and reconstructs:\n * - JSON stream (NDJSON lines for seroval)\n * - Raw streams (binary data as ReadableStream<Uint8Array>)\n */\n\nimport { FRAME_HEADER_SIZE, FrameType } from '../constants'\n\n/** Cached TextDecoder for frame decoding */\nconst textDecoder = new TextDecoder()\n\n/** Shared empty buffer for empty buffer case - avoids allocation */\nconst EMPTY_BUFFER = new Uint8Array(0)\n\n/** Hardening limits to prevent memory/CPU DoS */\nconst MAX_FRAME_PAYLOAD_SIZE = 16 * 1024 * 1024 // 16MiB\nconst MAX_BUFFERED_BYTES = 32 * 1024 * 1024 // 32MiB\nconst MAX_STREAMS = 1024\nconst MAX_FRAMES = 100_000 // Limit total frames to prevent CPU DoS\n\n/**\n * Result of frame decoding.\n */\nexport interface FrameDecoderResult {\n  /** Gets or creates a raw stream by ID (for use by deserialize plugin) */\n  getOrCreateStream: (id: number) => ReadableStream<Uint8Array>\n  /** Stream of JSON strings (NDJSON lines) */\n  jsonChunks: ReadableStream<string>\n}\n\n/**\n * Creates a frame decoder that processes a multiplexed response stream.\n *\n * @param input The raw response body stream\n * @returns Decoded JSON stream and stream getter function\n */\nexport function createFrameDecoder(\n  input: ReadableStream<Uint8Array>,\n): FrameDecoderResult {\n  const streamControllers = new Map<\n    number,\n    ReadableStreamDefaultController<Uint8Array>\n  >()\n  const streams = new Map<number, ReadableStream<Uint8Array>>()\n  const cancelledStreamIds = new Set<number>()\n\n  let cancelled = false as boolean\n  let inputReader: ReadableStreamReader<Uint8Array> | null = null\n  let frameCount = 0\n\n  let jsonController!: ReadableStreamDefaultController<string>\n  const jsonChunks = new ReadableStream<string>({\n    start(controller) {\n      jsonController = controller\n    },\n    cancel() {\n      cancelled = true\n      try {\n        inputReader?.cancel()\n      } catch {\n        // Ignore\n      }\n\n      streamControllers.forEach((ctrl) => {\n        try {\n          ctrl.error(new Error('Framed response cancelled'))\n        } catch {\n          // Ignore\n        }\n      })\n      streamControllers.clear()\n      streams.clear()\n      cancelledStreamIds.clear()\n    },\n  })\n\n  /**\n   * Gets or creates a stream for a given stream ID.\n   * Called by deserialize plugin when it encounters a RawStream reference.\n   */\n  function getOrCreateStream(id: number): ReadableStream<Uint8Array> {\n    const existing = streams.get(id)\n    if (existing) {\n      return existing\n    }\n\n    // If we already received an END/ERROR for this streamId, returning a fresh stream\n    // would hang consumers. Return an already-closed stream instead.\n    if (cancelledStreamIds.has(id)) {\n      return new ReadableStream<Uint8Array>({\n        start(controller) {\n          controller.close()\n        },\n      })\n    }\n\n    if (streams.size >= MAX_STREAMS) {\n      throw new Error(\n        `Too many raw streams in framed response (max ${MAX_STREAMS})`,\n      )\n    }\n\n    const stream = new ReadableStream<Uint8Array>({\n      start(ctrl) {\n        streamControllers.set(id, ctrl)\n      },\n      cancel() {\n        cancelledStreamIds.add(id)\n        streamControllers.delete(id)\n        streams.delete(id)\n      },\n    })\n    streams.set(id, stream)\n    return stream\n  }\n\n  /**\n   * Ensures stream exists and returns its controller for enqueuing data.\n   * Used for CHUNK frames where we need to ensure stream is created.\n   */\n  function ensureController(\n    id: number,\n  ): ReadableStreamDefaultController<Uint8Array> | undefined {\n    getOrCreateStream(id)\n    return streamControllers.get(id)\n  }\n\n  // Process frames asynchronously\n  ;(async () => {\n    const reader = input.getReader()\n    inputReader = reader\n\n    const bufferList: Array<Uint8Array> = []\n    let totalLength = 0\n\n    /**\n     * Reads header bytes from buffer chunks without flattening.\n     * Returns header data or null if not enough bytes available.\n     */\n    function readHeader(): {\n      type: number\n      streamId: number\n      length: number\n    } | null {\n      if (totalLength < FRAME_HEADER_SIZE) return null\n\n      const first = bufferList[0]!\n\n      // Fast path: header fits entirely in first chunk (common case)\n      if (first.length >= FRAME_HEADER_SIZE) {\n        const type = first[0]!\n        const streamId =\n          ((first[1]! << 24) |\n            (first[2]! << 16) |\n            (first[3]! << 8) |\n            first[4]!) >>>\n          0\n        const length =\n          ((first[5]! << 24) |\n            (first[6]! << 16) |\n            (first[7]! << 8) |\n            first[8]!) >>>\n          0\n        return { type, streamId, length }\n      }\n\n      // Slow path: header spans multiple chunks - flatten header bytes only\n      const headerBytes = new Uint8Array(FRAME_HEADER_SIZE)\n      let offset = 0\n      let remaining = FRAME_HEADER_SIZE\n      for (let i = 0; i < bufferList.length && remaining > 0; i++) {\n        const chunk = bufferList[i]!\n        const toCopy = Math.min(chunk.length, remaining)\n        headerBytes.set(chunk.subarray(0, toCopy), offset)\n        offset += toCopy\n        remaining -= toCopy\n      }\n\n      const type = headerBytes[0]!\n      const streamId =\n        ((headerBytes[1]! << 24) |\n          (headerBytes[2]! << 16) |\n          (headerBytes[3]! << 8) |\n          headerBytes[4]!) >>>\n        0\n      const length =\n        ((headerBytes[5]! << 24) |\n          (headerBytes[6]! << 16) |\n          (headerBytes[7]! << 8) |\n          headerBytes[8]!) >>>\n        0\n\n      return { type, streamId, length }\n    }\n\n    /**\n     * Flattens buffer list into single Uint8Array and removes from list.\n     */\n    function extractFlattened(count: number): Uint8Array {\n      if (count === 0) return EMPTY_BUFFER\n\n      const result = new Uint8Array(count)\n      let offset = 0\n      let remaining = count\n\n      while (remaining > 0 && bufferList.length > 0) {\n        const chunk = bufferList[0]\n        if (!chunk) break\n        const toCopy = Math.min(chunk.length, remaining)\n        result.set(chunk.subarray(0, toCopy), offset)\n\n        offset += toCopy\n        remaining -= toCopy\n\n        if (toCopy === chunk.length) {\n          bufferList.shift()\n        } else {\n          bufferList[0] = chunk.subarray(toCopy)\n        }\n      }\n\n      totalLength -= count\n      return result\n    }\n\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      while (true) {\n        const { done, value } = await reader.read()\n        if (cancelled) break\n        if (done) break\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!value) continue\n\n        // Append incoming chunk to buffer list\n        if (totalLength + value.length > MAX_BUFFERED_BYTES) {\n          throw new Error(\n            `Framed response buffer exceeded ${MAX_BUFFERED_BYTES} bytes`,\n          )\n        }\n        bufferList.push(value)\n        totalLength += value.length\n\n        // Parse complete frames from buffer\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while (true) {\n          const header = readHeader()\n          if (!header) break // Not enough bytes for header\n\n          const { type, streamId, length } = header\n\n          if (\n            type !== FrameType.JSON &&\n            type !== FrameType.CHUNK &&\n            type !== FrameType.END &&\n            type !== FrameType.ERROR\n          ) {\n            throw new Error(`Unknown frame type: ${type}`)\n          }\n\n          // Enforce stream id conventions: JSON uses streamId 0, raw streams use non-zero ids\n          if (type === FrameType.JSON) {\n            if (streamId !== 0) {\n              throw new Error('Invalid JSON frame streamId (expected 0)')\n            }\n          } else {\n            if (streamId === 0) {\n              throw new Error('Invalid raw frame streamId (expected non-zero)')\n            }\n          }\n\n          if (length > MAX_FRAME_PAYLOAD_SIZE) {\n            throw new Error(\n              `Frame payload too large: ${length} bytes (max ${MAX_FRAME_PAYLOAD_SIZE})`,\n            )\n          }\n\n          const frameSize = FRAME_HEADER_SIZE + length\n          if (totalLength < frameSize) break // Wait for more data\n\n          if (++frameCount > MAX_FRAMES) {\n            throw new Error(\n              `Too many frames in framed response (max ${MAX_FRAMES})`,\n            )\n          }\n\n          // Extract and consume header bytes\n          extractFlattened(FRAME_HEADER_SIZE)\n\n          // Extract payload\n          const payload = extractFlattened(length)\n\n          // Process frame by type\n          switch (type) {\n            case FrameType.JSON: {\n              try {\n                jsonController.enqueue(textDecoder.decode(payload))\n              } catch {\n                // JSON stream may be cancelled/closed\n              }\n              break\n            }\n\n            case FrameType.CHUNK: {\n              const ctrl = ensureController(streamId)\n              if (ctrl) {\n                ctrl.enqueue(payload)\n              }\n              break\n            }\n\n            case FrameType.END: {\n              const ctrl = ensureController(streamId)\n              cancelledStreamIds.add(streamId)\n              if (ctrl) {\n                try {\n                  ctrl.close()\n                } catch {\n                  // Already closed\n                }\n                streamControllers.delete(streamId)\n              }\n              break\n            }\n\n            case FrameType.ERROR: {\n              const ctrl = ensureController(streamId)\n              cancelledStreamIds.add(streamId)\n              if (ctrl) {\n                const message = textDecoder.decode(payload)\n                ctrl.error(new Error(message))\n                streamControllers.delete(streamId)\n              }\n              break\n            }\n          }\n        }\n      }\n\n      if (totalLength !== 0) {\n        throw new Error('Incomplete frame at end of framed response')\n      }\n\n      // Close JSON stream when done\n      try {\n        jsonController.close()\n      } catch {\n        // JSON stream may be cancelled/closed\n      }\n\n      // Close any remaining streams (shouldn't happen in normal operation)\n      streamControllers.forEach((ctrl) => {\n        try {\n          ctrl.close()\n        } catch {\n          // Already closed\n        }\n      })\n      streamControllers.clear()\n    } catch (error) {\n      // Error reading - propagate to all streams\n      try {\n        jsonController.error(error)\n      } catch {\n        // Already errored/closed\n      }\n      streamControllers.forEach((ctrl) => {\n        try {\n          ctrl.error(error)\n        } catch {\n          // Already errored/closed\n        }\n      })\n      streamControllers.clear()\n    } finally {\n      try {\n        reader.releaseLock()\n      } catch {\n        // Ignore\n      }\n      inputReader = null\n    }\n  })()\n\n  return { getOrCreateStream, jsonChunks }\n}\n"],"names":["type","streamId","length"],"mappings":";AAWA,MAAM,cAAc,IAAI,YAAA;AAGxB,MAAM,eAAe,IAAI,WAAW,CAAC;AAGrC,MAAM,yBAAyB,KAAK,OAAO;AAC3C,MAAM,qBAAqB,KAAK,OAAO;AACvC,MAAM,cAAc;AACpB,MAAM,aAAa;AAkBZ,SAAS,mBACd,OACoB;AACpB,QAAM,wCAAwB,IAAA;AAI9B,QAAM,8BAAc,IAAA;AACpB,QAAM,yCAAyB,IAAA;AAE/B,MAAI,YAAY;AAChB,MAAI,cAAuD;AAC3D,MAAI,aAAa;AAEjB,MAAI;AACJ,QAAM,aAAa,IAAI,eAAuB;AAAA,IAC5C,MAAM,YAAY;AAChB,uBAAiB;AAAA,IACnB;AAAA,IACA,SAAS;AACP,kBAAY;AACZ,UAAI;AACF,qBAAa,OAAA;AAAA,MACf,QAAQ;AAAA,MAER;AAEA,wBAAkB,QAAQ,CAAC,SAAS;AAClC,YAAI;AACF,eAAK,MAAM,IAAI,MAAM,2BAA2B,CAAC;AAAA,QACnD,QAAQ;AAAA,QAER;AAAA,MACF,CAAC;AACD,wBAAkB,MAAA;AAClB,cAAQ,MAAA;AACR,yBAAmB,MAAA;AAAA,IACrB;AAAA,EAAA,CACD;AAMD,WAAS,kBAAkB,IAAwC;AACjE,UAAM,WAAW,QAAQ,IAAI,EAAE;AAC/B,QAAI,UAAU;AACZ,aAAO;AAAA,IACT;AAIA,QAAI,mBAAmB,IAAI,EAAE,GAAG;AAC9B,aAAO,IAAI,eAA2B;AAAA,QACpC,MAAM,YAAY;AAChB,qBAAW,MAAA;AAAA,QACb;AAAA,MAAA,CACD;AAAA,IACH;AAEA,QAAI,QAAQ,QAAQ,aAAa;AAC/B,YAAM,IAAI;AAAA,QACR,gDAAgD,WAAW;AAAA,MAAA;AAAA,IAE/D;AAEA,UAAM,SAAS,IAAI,eAA2B;AAAA,MAC5C,MAAM,MAAM;AACV,0BAAkB,IAAI,IAAI,IAAI;AAAA,MAChC;AAAA,MACA,SAAS;AACP,2BAAmB,IAAI,EAAE;AACzB,0BAAkB,OAAO,EAAE;AAC3B,gBAAQ,OAAO,EAAE;AAAA,MACnB;AAAA,IAAA,CACD;AACD,YAAQ,IAAI,IAAI,MAAM;AACtB,WAAO;AAAA,EACT;AAMA,WAAS,iBACP,IACyD;AACzD,sBAAkB,EAAE;AACpB,WAAO,kBAAkB,IAAI,EAAE;AAAA,EACjC;AAGC,GAAC,YAAY;AACZ,UAAM,SAAS,MAAM,UAAA;AACrB,kBAAc;AAEd,UAAM,aAAgC,CAAA;AACtC,QAAI,cAAc;AAMlB,aAAS,aAIA;AACP,UAAI,cAAc,kBAAmB,QAAO;AAE5C,YAAM,QAAQ,WAAW,CAAC;AAG1B,UAAI,MAAM,UAAU,mBAAmB;AACrC,cAAMA,QAAO,MAAM,CAAC;AACpB,cAAMC,aACF,MAAM,CAAC,KAAM,KACZ,MAAM,CAAC,KAAM,KACb,MAAM,CAAC,KAAM,IACd,MAAM,CAAC,OACT;AACF,cAAMC,WACF,MAAM,CAAC,KAAM,KACZ,MAAM,CAAC,KAAM,KACb,MAAM,CAAC,KAAM,IACd,MAAM,CAAC,OACT;AACF,eAAO,EAAE,MAAAF,OAAM,UAAAC,WAAU,QAAAC,QAAAA;AAAAA,MAC3B;AAGA,YAAM,cAAc,IAAI,WAAW,iBAAiB;AACpD,UAAI,SAAS;AACb,UAAI,YAAY;AAChB,eAAS,IAAI,GAAG,IAAI,WAAW,UAAU,YAAY,GAAG,KAAK;AAC3D,cAAM,QAAQ,WAAW,CAAC;AAC1B,cAAM,SAAS,KAAK,IAAI,MAAM,QAAQ,SAAS;AAC/C,oBAAY,IAAI,MAAM,SAAS,GAAG,MAAM,GAAG,MAAM;AACjD,kBAAU;AACV,qBAAa;AAAA,MACf;AAEA,YAAM,OAAO,YAAY,CAAC;AAC1B,YAAM,YACF,YAAY,CAAC,KAAM,KAClB,YAAY,CAAC,KAAM,KACnB,YAAY,CAAC,KAAM,IACpB,YAAY,CAAC,OACf;AACF,YAAM,UACF,YAAY,CAAC,KAAM,KAClB,YAAY,CAAC,KAAM,KACnB,YAAY,CAAC,KAAM,IACpB,YAAY,CAAC,OACf;AAEF,aAAO,EAAE,MAAM,UAAU,OAAA;AAAA,IAC3B;AAKA,aAAS,iBAAiB,OAA2B;AACnD,UAAI,UAAU,EAAG,QAAO;AAExB,YAAM,SAAS,IAAI,WAAW,KAAK;AACnC,UAAI,SAAS;AACb,UAAI,YAAY;AAEhB,aAAO,YAAY,KAAK,WAAW,SAAS,GAAG;AAC7C,cAAM,QAAQ,WAAW,CAAC;AAC1B,YAAI,CAAC,MAAO;AACZ,cAAM,SAAS,KAAK,IAAI,MAAM,QAAQ,SAAS;AAC/C,eAAO,IAAI,MAAM,SAAS,GAAG,MAAM,GAAG,MAAM;AAE5C,kBAAU;AACV,qBAAa;AAEb,YAAI,WAAW,MAAM,QAAQ;AAC3B,qBAAW,MAAA;AAAA,QACb,OAAO;AACL,qBAAW,CAAC,IAAI,MAAM,SAAS,MAAM;AAAA,QACvC;AAAA,MACF;AAEA,qBAAe;AACf,aAAO;AAAA,IACT;AAEA,QAAI;AAEF,aAAO,MAAM;AACX,cAAM,EAAE,MAAM,MAAA,IAAU,MAAM,OAAO,KAAA;AACrC,YAAI,UAAW;AACf,YAAI,KAAM;AAGV,YAAI,CAAC,MAAO;AAGZ,YAAI,cAAc,MAAM,SAAS,oBAAoB;AACnD,gBAAM,IAAI;AAAA,YACR,mCAAmC,kBAAkB;AAAA,UAAA;AAAA,QAEzD;AACA,mBAAW,KAAK,KAAK;AACrB,uBAAe,MAAM;AAIrB,eAAO,MAAM;AACX,gBAAM,SAAS,WAAA;AACf,cAAI,CAAC,OAAQ;AAEb,gBAAM,EAAE,MAAM,UAAU,OAAA,IAAW;AAEnC,cACE,SAAS,UAAU,QACnB,SAAS,UAAU,SACnB,SAAS,UAAU,OACnB,SAAS,UAAU,OACnB;AACA,kBAAM,IAAI,MAAM,uBAAuB,IAAI,EAAE;AAAA,UAC/C;AAGA,cAAI,SAAS,UAAU,MAAM;AAC3B,gBAAI,aAAa,GAAG;AAClB,oBAAM,IAAI,MAAM,0CAA0C;AAAA,YAC5D;AAAA,UACF,OAAO;AACL,gBAAI,aAAa,GAAG;AAClB,oBAAM,IAAI,MAAM,gDAAgD;AAAA,YAClE;AAAA,UACF;AAEA,cAAI,SAAS,wBAAwB;AACnC,kBAAM,IAAI;AAAA,cACR,4BAA4B,MAAM,eAAe,sBAAsB;AAAA,YAAA;AAAA,UAE3E;AAEA,gBAAM,YAAY,oBAAoB;AACtC,cAAI,cAAc,UAAW;AAE7B,cAAI,EAAE,aAAa,YAAY;AAC7B,kBAAM,IAAI;AAAA,cACR,2CAA2C,UAAU;AAAA,YAAA;AAAA,UAEzD;AAGA,2BAAiB,iBAAiB;AAGlC,gBAAM,UAAU,iBAAiB,MAAM;AAGvC,kBAAQ,MAAA;AAAA,YACN,KAAK,UAAU,MAAM;AACnB,kBAAI;AACF,+BAAe,QAAQ,YAAY,OAAO,OAAO,CAAC;AAAA,cACpD,QAAQ;AAAA,cAER;AACA;AAAA,YACF;AAAA,YAEA,KAAK,UAAU,OAAO;AACpB,oBAAM,OAAO,iBAAiB,QAAQ;AACtC,kBAAI,MAAM;AACR,qBAAK,QAAQ,OAAO;AAAA,cACtB;AACA;AAAA,YACF;AAAA,YAEA,KAAK,UAAU,KAAK;AAClB,oBAAM,OAAO,iBAAiB,QAAQ;AACtC,iCAAmB,IAAI,QAAQ;AAC/B,kBAAI,MAAM;AACR,oBAAI;AACF,uBAAK,MAAA;AAAA,gBACP,QAAQ;AAAA,gBAER;AACA,kCAAkB,OAAO,QAAQ;AAAA,cACnC;AACA;AAAA,YACF;AAAA,YAEA,KAAK,UAAU,OAAO;AACpB,oBAAM,OAAO,iBAAiB,QAAQ;AACtC,iCAAmB,IAAI,QAAQ;AAC/B,kBAAI,MAAM;AACR,sBAAM,UAAU,YAAY,OAAO,OAAO;AAC1C,qBAAK,MAAM,IAAI,MAAM,OAAO,CAAC;AAC7B,kCAAkB,OAAO,QAAQ;AAAA,cACnC;AACA;AAAA,YACF;AAAA,UAAA;AAAA,QAEJ;AAAA,MACF;AAEA,UAAI,gBAAgB,GAAG;AACrB,cAAM,IAAI,MAAM,4CAA4C;AAAA,MAC9D;AAGA,UAAI;AACF,uBAAe,MAAA;AAAA,MACjB,QAAQ;AAAA,MAER;AAGA,wBAAkB,QAAQ,CAAC,SAAS;AAClC,YAAI;AACF,eAAK,MAAA;AAAA,QACP,QAAQ;AAAA,QAER;AAAA,MACF,CAAC;AACD,wBAAkB,MAAA;AAAA,IACpB,SAAS,OAAO;AAEd,UAAI;AACF,uBAAe,MAAM,KAAK;AAAA,MAC5B,QAAQ;AAAA,MAER;AACA,wBAAkB,QAAQ,CAAC,SAAS;AAClC,YAAI;AACF,eAAK,MAAM,KAAK;AAAA,QAClB,QAAQ;AAAA,QAER;AAAA,MACF,CAAC;AACD,wBAAkB,MAAA;AAAA,IACpB,UAAA;AACE,UAAI;AACF,eAAO,YAAA;AAAA,MACT,QAAQ;AAAA,MAER;AACA,oBAAc;AAAA,IAChB;AAAA,EACF,GAAA;AAEA,SAAO,EAAE,mBAAmB,WAAA;AAC9B;"}