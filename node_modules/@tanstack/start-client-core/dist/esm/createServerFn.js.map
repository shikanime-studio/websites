{"version":3,"file":"createServerFn.js","sources":["../../src/createServerFn.ts"],"sourcesContent":["import { mergeHeaders } from '@tanstack/router-core/ssr/client'\n\nimport { isRedirect, parseRedirect } from '@tanstack/router-core'\nimport { TSS_SERVER_FUNCTION_FACTORY } from './constants'\nimport { getStartOptions } from './getStartOptions'\nimport { getStartContextServerOnly } from './getStartContextServerOnly'\nimport { createNullProtoObject, safeObjectMerge } from './safeObjectMerge'\nimport type {\n  AnyValidator,\n  Constrain,\n  Expand,\n  Register,\n  RegisteredSerializableInput,\n  ResolveValidatorInput,\n  ValidateSerializable,\n  ValidateSerializableInput,\n  Validator,\n} from '@tanstack/router-core'\nimport type { TSS_SERVER_FUNCTION } from './constants'\nimport type {\n  AnyFunctionMiddleware,\n  AnyRequestMiddleware,\n  AssignAllServerFnContext,\n  FunctionMiddlewareClientFnResult,\n  FunctionMiddlewareServerFnResult,\n  IntersectAllValidatorInputs,\n  IntersectAllValidatorOutputs,\n} from './createMiddleware'\n\ntype TODO = any\n\nexport type CreateServerFn<TRegister> = <\n  TMethod extends Method,\n  TResponse = unknown,\n  TMiddlewares = undefined,\n  TInputValidator = undefined,\n>(\n  options?: {\n    method?: TMethod\n  },\n  __opts?: ServerFnBaseOptions<\n    TRegister,\n    TMethod,\n    TResponse,\n    TMiddlewares,\n    TInputValidator\n  >,\n) => ServerFnBuilder<TRegister, TMethod>\n\nexport const createServerFn: CreateServerFn<Register> = (options, __opts) => {\n  const resolvedOptions = (__opts || options || {}) as ServerFnBaseOptions<\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n\n  if (typeof resolvedOptions.method === 'undefined') {\n    resolvedOptions.method = 'GET' as Method\n  }\n\n  const res: ServerFnBuilder<Register, Method> = {\n    options: resolvedOptions as any,\n    middleware: (middleware) => {\n      // multiple calls to `middleware()` merge the middlewares with the previously supplied ones\n      // this is primarily useful for letting users create their own abstractions on top of `createServerFn`\n\n      const newMiddleware = [...(resolvedOptions.middleware || [])]\n      middleware.map((m) => {\n        if (TSS_SERVER_FUNCTION_FACTORY in m) {\n          if (m.options.middleware) {\n            newMiddleware.push(...m.options.middleware)\n          }\n        } else {\n          newMiddleware.push(m)\n        }\n      })\n\n      const newOptions = {\n        ...resolvedOptions,\n        middleware: newMiddleware,\n      }\n      const res = createServerFn(undefined, newOptions) as any\n      res[TSS_SERVER_FUNCTION_FACTORY] = true\n      return res\n    },\n    inputValidator: (inputValidator) => {\n      const newOptions = { ...resolvedOptions, inputValidator }\n      return createServerFn(undefined, newOptions) as any\n    },\n    handler: (...args) => {\n      // This function signature changes due to AST transformations\n      // in the babel plugin. We need to cast it to the correct\n      // function signature post-transformation\n      const [extractedFn, serverFn] = args as unknown as [\n        CompiledFetcherFn<Register, any>,\n        ServerFn<Register, Method, any, any, any>,\n      ]\n\n      // Keep the original function around so we can use it\n      // in the server environment\n      const newOptions = { ...resolvedOptions, extractedFn, serverFn }\n\n      const resolvedMiddleware = [\n        ...(newOptions.middleware || []),\n        serverFnBaseToMiddleware(newOptions),\n      ]\n\n      // We want to make sure the new function has the same\n      // properties as the original function\n\n      return Object.assign(\n        async (opts?: CompiledFetcherFnOptions) => {\n          // Start by executing the client-side middleware chain\n          const result = await executeMiddleware(resolvedMiddleware, 'client', {\n            ...extractedFn,\n            ...newOptions,\n            data: opts?.data as any,\n            headers: opts?.headers,\n            signal: opts?.signal,\n            context: createNullProtoObject(),\n          })\n\n          const redirect = parseRedirect(result.error)\n          if (redirect) {\n            throw redirect\n          }\n\n          if (result.error) throw result.error\n          return result.result\n        },\n        {\n          // This copies over the URL, function ID\n          ...extractedFn,\n          // The extracted function on the server-side calls\n          // this function\n          __executeServer: async (opts: any, signal: AbortSignal) => {\n            const startContext = getStartContextServerOnly()\n            const serverContextAfterGlobalMiddlewares =\n              startContext.contextAfterGlobalMiddlewares\n            // Use safeObjectMerge for opts.context which comes from client\n            const ctx = {\n              ...extractedFn,\n              ...opts,\n              context: safeObjectMerge(\n                serverContextAfterGlobalMiddlewares,\n                opts.context,\n              ),\n              signal,\n              request: startContext.request,\n            }\n\n            const result = await executeMiddleware(\n              resolvedMiddleware,\n              'server',\n              ctx,\n            ).then((d) => ({\n              // Only send the result and sendContext back to the client\n              result: d.result,\n              error: d.error,\n              context: d.sendContext,\n            }))\n\n            return result\n          },\n        },\n      ) as any\n    },\n  } as ServerFnBuilder<Register, Method>\n  const fun = (options?: { method?: Method }) => {\n    const newOptions = {\n      ...resolvedOptions,\n      ...options,\n    }\n    return createServerFn(undefined, newOptions) as any\n  }\n  return Object.assign(fun, res) as any\n}\n\nexport async function executeMiddleware(\n  middlewares: Array<AnyFunctionMiddleware | AnyRequestMiddleware>,\n  env: 'client' | 'server',\n  opts: ServerFnMiddlewareOptions,\n): Promise<ServerFnMiddlewareResult> {\n  const globalMiddlewares = getStartOptions()?.functionMiddleware || []\n  let flattenedMiddlewares = flattenMiddlewares([\n    ...globalMiddlewares,\n    ...middlewares,\n  ])\n\n  // On server, filter out middlewares that already executed in the request phase\n  // to prevent duplicate execution (issue #5239)\n  if (env === 'server') {\n    const startContext = getStartContextServerOnly({ throwIfNotFound: false })\n    if (startContext?.executedRequestMiddlewares) {\n      flattenedMiddlewares = flattenedMiddlewares.filter(\n        (m) => !startContext.executedRequestMiddlewares.has(m),\n      )\n    }\n  }\n\n  const callNextMiddleware: NextFn = async (ctx) => {\n    // Get the next middleware\n    const nextMiddleware = flattenedMiddlewares.shift()\n\n    // If there are no more middlewares, return the context\n    if (!nextMiddleware) {\n      return ctx\n    }\n\n    // Execute the middleware\n    try {\n      if (\n        'inputValidator' in nextMiddleware.options &&\n        nextMiddleware.options.inputValidator &&\n        env === 'server'\n      ) {\n        // Execute the middleware's input function\n        ctx.data = await execValidator(\n          nextMiddleware.options.inputValidator,\n          ctx.data,\n        )\n      }\n\n      let middlewareFn: MiddlewareFn | undefined = undefined\n      if (env === 'client') {\n        if ('client' in nextMiddleware.options) {\n          middlewareFn = nextMiddleware.options.client as\n            | MiddlewareFn\n            | undefined\n        }\n      }\n      // env === 'server'\n      else if ('server' in nextMiddleware.options) {\n        middlewareFn = nextMiddleware.options.server as MiddlewareFn | undefined\n      }\n\n      if (middlewareFn) {\n        const userNext = async (\n          userCtx: ServerFnMiddlewareResult | undefined = {} as any,\n        ) => {\n          // Return the next middleware\n          // Use safeObjectMerge for context objects to prevent prototype pollution\n          const nextCtx = {\n            ...ctx,\n            ...userCtx,\n            context: safeObjectMerge(ctx.context, userCtx.context),\n            sendContext: safeObjectMerge(ctx.sendContext, userCtx.sendContext),\n            headers: mergeHeaders(ctx.headers, userCtx.headers),\n            result:\n              userCtx.result !== undefined\n                ? userCtx.result\n                : userCtx instanceof Response\n                  ? userCtx\n                  : (ctx as any).result,\n            error: userCtx.error ?? (ctx as any).error,\n          }\n\n          try {\n            return await callNextMiddleware(nextCtx)\n          } catch (error: any) {\n            return {\n              ...nextCtx,\n              error,\n            }\n          }\n        }\n\n        // Execute the middleware\n        const result = await middlewareFn({\n          ...ctx,\n          next: userNext as any,\n        } as any)\n\n        // If result is NOT a ctx object, we need to return it as\n        // the { result }\n        if (isRedirect(result)) {\n          return {\n            ...ctx,\n            error: result,\n          }\n        }\n\n        if (result instanceof Response) {\n          return {\n            ...ctx,\n            result,\n          }\n        }\n\n        if (!(result as any)) {\n          throw new Error(\n            'User middleware returned undefined. You must call next() or return a result in your middlewares.',\n          )\n        }\n\n        return result\n      }\n\n      return callNextMiddleware(ctx)\n    } catch (error: any) {\n      return {\n        ...ctx,\n        error,\n      }\n    }\n  }\n\n  // Start the middleware chain\n  return callNextMiddleware({\n    ...opts,\n    headers: opts.headers || {},\n    sendContext: opts.sendContext || {},\n    context: opts.context || createNullProtoObject(),\n  })\n}\n\nexport type CompiledFetcherFnOptions = {\n  method: Method\n  data: unknown\n  headers?: HeadersInit\n  signal?: AbortSignal\n  context?: any\n}\n\nexport type Fetcher<TMiddlewares, TInputValidator, TResponse> =\n  undefined extends IntersectAllValidatorInputs<TMiddlewares, TInputValidator>\n    ? OptionalFetcher<TMiddlewares, TInputValidator, TResponse>\n    : RequiredFetcher<TMiddlewares, TInputValidator, TResponse>\n\nexport interface FetcherBase {\n  [TSS_SERVER_FUNCTION]: true\n  url: string\n  __executeServer: (opts: {\n    method: Method\n    data: unknown\n    headers?: HeadersInit\n    context?: any\n    signal: AbortSignal\n  }) => Promise<unknown>\n}\n\nexport interface OptionalFetcher<TMiddlewares, TInputValidator, TResponse>\n  extends FetcherBase {\n  (\n    options?: OptionalFetcherDataOptions<TMiddlewares, TInputValidator>,\n  ): Promise<Awaited<TResponse>>\n}\n\nexport interface RequiredFetcher<TMiddlewares, TInputValidator, TResponse>\n  extends FetcherBase {\n  (\n    opts: RequiredFetcherDataOptions<TMiddlewares, TInputValidator>,\n  ): Promise<Awaited<TResponse>>\n}\n\nexport type FetcherBaseOptions = {\n  headers?: HeadersInit\n  signal?: AbortSignal\n}\n\nexport interface OptionalFetcherDataOptions<TMiddlewares, TInputValidator>\n  extends FetcherBaseOptions {\n  data?: Expand<IntersectAllValidatorInputs<TMiddlewares, TInputValidator>>\n}\n\nexport interface RequiredFetcherDataOptions<TMiddlewares, TInputValidator>\n  extends FetcherBaseOptions {\n  data: Expand<IntersectAllValidatorInputs<TMiddlewares, TInputValidator>>\n}\n\nexport type RscStream<T> = {\n  __cacheState: T\n}\n\nexport type Method = 'GET' | 'POST'\n\nexport type ServerFnReturnType<TRegister, TResponse> =\n  TResponse extends PromiseLike<infer U>\n    ? Promise<ServerFnReturnType<TRegister, U>>\n    : TResponse extends Response\n      ? TResponse\n      : ValidateSerializableInput<TRegister, TResponse>\n\nexport type ServerFn<\n  TRegister,\n  TMethod,\n  TMiddlewares,\n  TInputValidator,\n  TResponse,\n> = (\n  ctx: ServerFnCtx<TRegister, TMiddlewares, TInputValidator>,\n) => ServerFnReturnType<TRegister, TResponse>\n\nexport interface ServerFnCtx<TRegister, TMiddlewares, TInputValidator> {\n  data: Expand<IntersectAllValidatorOutputs<TMiddlewares, TInputValidator>>\n  context: Expand<AssignAllServerFnContext<TRegister, TMiddlewares, {}>>\n  signal: AbortSignal\n}\n\nexport type CompiledFetcherFn<TRegister, TResponse> = {\n  (\n    opts: CompiledFetcherFnOptions & ServerFnBaseOptions<TRegister, Method>,\n  ): Promise<TResponse>\n  url: string\n}\n\nexport type ServerFnBaseOptions<\n  TRegister,\n  TMethod extends Method = 'GET',\n  TResponse = unknown,\n  TMiddlewares = unknown,\n  TInputValidator = unknown,\n> = {\n  method: TMethod\n  middleware?: Constrain<\n    TMiddlewares,\n    ReadonlyArray<AnyFunctionMiddleware | AnyRequestMiddleware>\n  >\n  inputValidator?: ConstrainValidator<TRegister, TMethod, TInputValidator>\n  extractedFn?: CompiledFetcherFn<TRegister, TResponse>\n  serverFn?: ServerFn<\n    TRegister,\n    TMethod,\n    TMiddlewares,\n    TInputValidator,\n    TResponse\n  >\n  functionId: string\n}\n\nexport type ValidateValidatorInput<\n  TRegister,\n  TMethod extends Method,\n  TInputValidator,\n> = TMethod extends 'POST'\n  ? ResolveValidatorInput<TInputValidator> extends FormData\n    ? ResolveValidatorInput<TInputValidator>\n    : ValidateSerializable<\n        ResolveValidatorInput<TInputValidator>,\n        RegisteredSerializableInput<TRegister>\n      >\n  : ValidateSerializable<\n      ResolveValidatorInput<TInputValidator>,\n      RegisteredSerializableInput<TRegister>\n    >\n\nexport type ValidateValidator<\n  TRegister,\n  TMethod extends Method,\n  TInputValidator,\n> =\n  ValidateValidatorInput<\n    TRegister,\n    TMethod,\n    TInputValidator\n  > extends infer TInput\n    ? Validator<TInput, any>\n    : never\n\nexport type ConstrainValidator<\n  TRegister,\n  TMethod extends Method,\n  TInputValidator,\n> =\n  | (unknown extends TInputValidator\n      ? TInputValidator\n      : ResolveValidatorInput<TInputValidator> extends ValidateValidator<\n            TRegister,\n            TMethod,\n            TInputValidator\n          >\n        ? TInputValidator\n        : never)\n  | ValidateValidator<TRegister, TMethod, TInputValidator>\n\nexport type AppendMiddlewares<TMiddlewares, TNewMiddlewares> =\n  TMiddlewares extends ReadonlyArray<any>\n    ? TNewMiddlewares extends ReadonlyArray<any>\n      ? readonly [...TMiddlewares, ...TNewMiddlewares]\n      : TMiddlewares\n    : TNewMiddlewares\n\nexport interface ServerFnMiddleware<\n  TRegister,\n  TMethod extends Method,\n  TMiddlewares,\n  TInputValidator,\n> {\n  middleware: <const TNewMiddlewares>(\n    middlewares: Constrain<\n      TNewMiddlewares,\n      ReadonlyArray<AnyFunctionMiddleware | AnyRequestMiddleware | AnyServerFn>\n    >,\n  ) => ServerFnAfterMiddleware<\n    TRegister,\n    TMethod,\n    AppendMiddlewares<TMiddlewares, TNewMiddlewares>,\n    TInputValidator\n  >\n}\n\nexport interface ServerFnAfterMiddleware<\n  TRegister,\n  TMethod extends Method,\n  TMiddlewares,\n  TInputValidator,\n> extends ServerFnWithTypes<\n      TRegister,\n      TMethod,\n      TMiddlewares,\n      TInputValidator,\n      undefined\n    >,\n    ServerFnMiddleware<TRegister, TMethod, TMiddlewares, undefined>,\n    ServerFnValidator<TRegister, TMethod, TMiddlewares>,\n    ServerFnHandler<TRegister, TMethod, TMiddlewares, TInputValidator> {\n  <TNewMethod extends Method = TMethod>(options?: {\n    method?: TNewMethod\n  }): ServerFnAfterMiddleware<\n    TRegister,\n    TNewMethod,\n    TMiddlewares,\n    TInputValidator\n  >\n}\n\nexport type ValidatorFn<TRegister, TMethod extends Method, TMiddlewares> = <\n  TInputValidator,\n>(\n  inputValidator: ConstrainValidator<TRegister, TMethod, TInputValidator>,\n) => ServerFnAfterValidator<TRegister, TMethod, TMiddlewares, TInputValidator>\n\nexport interface ServerFnValidator<\n  TRegister,\n  TMethod extends Method,\n  TMiddlewares,\n> {\n  inputValidator: ValidatorFn<TRegister, TMethod, TMiddlewares>\n}\n\nexport interface ServerFnAfterValidator<\n  TRegister,\n  TMethod extends Method,\n  TMiddlewares,\n  TInputValidator,\n> extends ServerFnWithTypes<\n      TRegister,\n      TMethod,\n      TMiddlewares,\n      TInputValidator,\n      undefined\n    >,\n    ServerFnMiddleware<TRegister, TMethod, TMiddlewares, TInputValidator>,\n    ServerFnHandler<TRegister, TMethod, TMiddlewares, TInputValidator> {}\n\nexport interface ServerFnAfterTyper<\n  TRegister,\n  TMethod extends Method,\n  TMiddlewares,\n  TInputValidator,\n> extends ServerFnWithTypes<\n      TRegister,\n      TMethod,\n      TMiddlewares,\n      TInputValidator,\n      undefined\n    >,\n    ServerFnHandler<TRegister, TMethod, TMiddlewares, TInputValidator> {}\n\n// Handler\nexport interface ServerFnHandler<\n  TRegister,\n  TMethod extends Method,\n  TMiddlewares,\n  TInputValidator,\n> {\n  handler: <TNewResponse>(\n    fn?: ServerFn<\n      TRegister,\n      TMethod,\n      TMiddlewares,\n      TInputValidator,\n      TNewResponse\n    >,\n  ) => Fetcher<TMiddlewares, TInputValidator, TNewResponse>\n}\n\nexport interface ServerFnBuilder<TRegister, TMethod extends Method = 'GET'>\n  extends ServerFnWithTypes<\n      TRegister,\n      TMethod,\n      undefined,\n      undefined,\n      undefined\n    >,\n    ServerFnMiddleware<TRegister, TMethod, undefined, undefined>,\n    ServerFnValidator<TRegister, TMethod, undefined>,\n    ServerFnHandler<TRegister, TMethod, undefined, undefined> {\n  options: ServerFnBaseOptions<\n    TRegister,\n    TMethod,\n    unknown,\n    undefined,\n    undefined\n  >\n}\n\nexport interface ServerFnWithTypes<\n  in out TRegister,\n  in out TMethod extends Method,\n  in out TMiddlewares,\n  in out TInputValidator,\n  in out TResponse,\n> {\n  '~types': ServerFnTypes<\n    TRegister,\n    TMethod,\n    TMiddlewares,\n    TInputValidator,\n    TResponse\n  >\n  options: ServerFnBaseOptions<\n    TRegister,\n    TMethod,\n    unknown,\n    undefined,\n    undefined\n  >\n  [TSS_SERVER_FUNCTION_FACTORY]: true\n}\n\nexport type AnyServerFn = ServerFnWithTypes<any, any, any, any, any>\n\nexport interface ServerFnTypes<\n  in out TRegister,\n  in out TMethod extends Method,\n  in out TMiddlewares,\n  in out TInputValidator,\n  in out TResponse,\n> {\n  method: TMethod\n  middlewares: TMiddlewares\n  inputValidator: TInputValidator\n  response: TResponse\n  allServerContext: AssignAllServerFnContext<TRegister, TMiddlewares>\n  allInput: IntersectAllValidatorInputs<TMiddlewares, TInputValidator>\n  allOutput: IntersectAllValidatorOutputs<TMiddlewares, TInputValidator>\n}\n\nexport function flattenMiddlewares<\n  T extends AnyFunctionMiddleware | AnyRequestMiddleware,\n>(middlewares: Array<T>, maxDepth: number = 100): Array<T> {\n  const seen = new Set<T>()\n  const flattened: Array<T> = []\n\n  const recurse = (middleware: Array<T>, depth: number) => {\n    if (depth > maxDepth) {\n      throw new Error(\n        `Middleware nesting depth exceeded maximum of ${maxDepth}. Check for circular references.`,\n      )\n    }\n    middleware.forEach((m) => {\n      if (m.options.middleware) {\n        recurse(m.options.middleware as Array<T>, depth + 1)\n      }\n\n      if (!seen.has(m)) {\n        seen.add(m)\n        flattened.push(m)\n      }\n    })\n  }\n\n  recurse(middlewares, 0)\n\n  return flattened\n}\n\nexport type ServerFnMiddlewareOptions = {\n  method: Method\n  data: any\n  headers?: HeadersInit\n  signal?: AbortSignal\n  sendContext?: any\n  context?: any\n  functionId: string\n}\n\nexport type ServerFnMiddlewareResult = ServerFnMiddlewareOptions & {\n  result?: unknown\n  error?: unknown\n}\n\nexport type NextFn = (\n  ctx: ServerFnMiddlewareResult,\n) => Promise<ServerFnMiddlewareResult>\n\nexport type MiddlewareFn = (\n  ctx: ServerFnMiddlewareOptions & {\n    next: NextFn\n  },\n) => Promise<ServerFnMiddlewareResult>\n\nexport async function execValidator(\n  validator: AnyValidator,\n  input: unknown,\n): Promise<unknown> {\n  if (validator == null) return {}\n\n  if ('~standard' in validator) {\n    const result = await validator['~standard'].validate(input)\n\n    if (result.issues)\n      throw new Error(JSON.stringify(result.issues, undefined, 2))\n\n    return result.value\n  }\n\n  if ('parse' in validator) {\n    return validator.parse(input)\n  }\n\n  if (typeof validator === 'function') {\n    return validator(input)\n  }\n\n  throw new Error('Invalid validator type!')\n}\n\nfunction serverFnBaseToMiddleware(\n  options: ServerFnBaseOptions<any, any, any, any, any>,\n): AnyFunctionMiddleware {\n  return {\n    '~types': undefined!,\n    options: {\n      inputValidator: options.inputValidator,\n      client: async ({ next, sendContext, ...ctx }) => {\n        const payload = {\n          ...ctx,\n          // switch the sendContext over to context\n          context: sendContext,\n        } as any\n\n        // Execute the extracted function\n        // but not before serializing the context\n        const res = await options.extractedFn?.(payload)\n\n        return next(res) as unknown as FunctionMiddlewareClientFnResult<\n          any,\n          any,\n          any\n        >\n      },\n      server: async ({ next, ...ctx }) => {\n        // Execute the server function\n        const result = await options.serverFn?.(ctx as TODO)\n\n        return next({\n          ...ctx,\n          result,\n        } as any) as unknown as FunctionMiddlewareServerFnResult<\n          any,\n          any,\n          any,\n          any,\n          any\n        >\n      },\n    },\n  }\n}\n"],"names":["res","options"],"mappings":"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"}