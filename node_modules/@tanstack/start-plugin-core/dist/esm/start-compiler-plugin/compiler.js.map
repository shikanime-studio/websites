{"version":3,"file":"compiler.js","sources":["../../../src/start-compiler-plugin/compiler.ts"],"sourcesContent":["/* eslint-disable import/no-commonjs */\nimport crypto from 'node:crypto'\nimport * as t from '@babel/types'\nimport { generateFromAst, parseAst } from '@tanstack/router-utils'\nimport babel from '@babel/core'\nimport {\n  deadCodeElimination,\n  findReferencedIdentifiers,\n} from 'babel-dead-code-elimination'\nimport { handleCreateServerFn } from './handleCreateServerFn'\nimport { handleCreateMiddleware } from './handleCreateMiddleware'\nimport { handleCreateIsomorphicFn } from './handleCreateIsomorphicFn'\nimport { handleEnvOnlyFn } from './handleEnvOnly'\nimport { handleClientOnlyJSX } from './handleClientOnlyJSX'\nimport type {\n  CompilationContext,\n  MethodChainPaths,\n  RewriteCandidate,\n  ServerFn,\n} from './types'\nimport type { CompileStartFrameworkOptions } from '../types'\n\ntype Binding =\n  | {\n      type: 'import'\n      source: string\n      importedName: string\n      resolvedKind?: Kind\n    }\n  | {\n      type: 'var'\n      init: t.Expression | null\n      resolvedKind?: Kind\n    }\n\ntype Kind = 'None' | `Root` | `Builder` | LookupKind\n\nexport type LookupKind =\n  | 'ServerFn'\n  | 'Middleware'\n  | 'IsomorphicFn'\n  | 'ServerOnlyFn'\n  | 'ClientOnlyFn'\n  | 'ClientOnlyJSX'\n\n// Detection strategy for each kind\ntype MethodChainSetup = {\n  type: 'methodChain'\n  candidateCallIdentifier: Set<string>\n}\ntype DirectCallSetup = {\n  type: 'directCall'\n  // The factory function name used to create this kind (e.g., 'createServerOnlyFn')\n  factoryName: string\n}\ntype JSXSetup = { type: 'jsx'; componentName: string }\n\nconst LookupSetup: Record<\n  LookupKind,\n  MethodChainSetup | DirectCallSetup | JSXSetup\n> = {\n  ServerFn: {\n    type: 'methodChain',\n    candidateCallIdentifier: new Set(['handler']),\n  },\n  Middleware: {\n    type: 'methodChain',\n    candidateCallIdentifier: new Set(['server', 'client', 'createMiddlewares']),\n  },\n  IsomorphicFn: {\n    type: 'methodChain',\n    candidateCallIdentifier: new Set(['server', 'client']),\n  },\n  ServerOnlyFn: { type: 'directCall', factoryName: 'createServerOnlyFn' },\n  ClientOnlyFn: { type: 'directCall', factoryName: 'createClientOnlyFn' },\n  ClientOnlyJSX: { type: 'jsx', componentName: 'ClientOnly' },\n}\n\n// Single source of truth for detecting which kinds are present in code\n// These patterns are used for:\n// 1. Pre-scanning code to determine which kinds to look for (before AST parsing)\n// 2. Deriving the plugin's transform code filter\nexport const KindDetectionPatterns: Record<LookupKind, RegExp> = {\n  ServerFn: /\\bcreateServerFn\\b|\\.\\s*handler\\s*\\(/,\n  Middleware: /createMiddleware/,\n  IsomorphicFn: /createIsomorphicFn/,\n  ServerOnlyFn: /createServerOnlyFn/,\n  ClientOnlyFn: /createClientOnlyFn/,\n  ClientOnlyJSX: /<ClientOnly|import\\s*\\{[^}]*\\bClientOnly\\b/,\n}\n\n// Which kinds are valid for each environment\nexport const LookupKindsPerEnv: Record<'client' | 'server', Set<LookupKind>> = {\n  client: new Set([\n    'Middleware',\n    'ServerFn',\n    'IsomorphicFn',\n    'ServerOnlyFn',\n    'ClientOnlyFn',\n  ] as const),\n  server: new Set([\n    'ServerFn',\n    'IsomorphicFn',\n    'ServerOnlyFn',\n    'ClientOnlyFn',\n    'ClientOnlyJSX', // Only transform on server to remove children\n  ] as const),\n}\n\n/**\n * Handler type for processing candidates of a specific kind.\n * The kind is passed as the third argument to allow shared handlers (like handleEnvOnlyFn).\n */\ntype KindHandler = (\n  candidates: Array<RewriteCandidate>,\n  context: CompilationContext,\n  kind: LookupKind,\n) => void\n\n/**\n * Registry mapping each LookupKind to its handler function.\n * When adding a new kind, add its handler here.\n */\nconst KindHandlers: Record<\n  Exclude<LookupKind, 'ClientOnlyJSX'>,\n  KindHandler\n> = {\n  ServerFn: handleCreateServerFn,\n  Middleware: handleCreateMiddleware,\n  IsomorphicFn: handleCreateIsomorphicFn,\n  ServerOnlyFn: handleEnvOnlyFn,\n  ClientOnlyFn: handleEnvOnlyFn,\n  // ClientOnlyJSX is handled separately via JSX traversal, not here\n}\n\n// All lookup kinds as an array for iteration with proper typing\nconst AllLookupKinds = Object.keys(LookupSetup) as Array<LookupKind>\n\n/**\n * Detects which LookupKinds are present in the code using string matching.\n * This is a fast pre-scan before AST parsing to limit the work done during compilation.\n */\nexport function detectKindsInCode(\n  code: string,\n  env: 'client' | 'server',\n): Set<LookupKind> {\n  const detected = new Set<LookupKind>()\n  const validForEnv = LookupKindsPerEnv[env]\n\n  for (const kind of AllLookupKinds) {\n    if (validForEnv.has(kind) && KindDetectionPatterns[kind].test(code)) {\n      detected.add(kind)\n    }\n  }\n\n  return detected\n}\n\n// Pre-computed map: identifier name -> Set<LookupKind> for fast candidate detection (method chain only)\n// Multiple kinds can share the same identifier (e.g., 'server' and 'client' are used by both Middleware and IsomorphicFn)\nconst IdentifierToKinds = new Map<string, Set<LookupKind>>()\nfor (const kind of AllLookupKinds) {\n  const setup = LookupSetup[kind]\n  if (setup.type === 'methodChain') {\n    for (const id of setup.candidateCallIdentifier) {\n      let kinds = IdentifierToKinds.get(id)\n      if (!kinds) {\n        kinds = new Set()\n        IdentifierToKinds.set(id, kinds)\n      }\n      kinds.add(kind)\n    }\n  }\n}\n\n// Factory function names for direct call patterns.\n// Used to filter nested candidates - we only want to include actual factory calls,\n// not invocations of already-created functions (e.g., `myServerFn()` should NOT be a candidate)\nconst DirectCallFactoryNames = new Set<string>()\nfor (const kind of AllLookupKinds) {\n  const setup = LookupSetup[kind]\n  if (setup.type === 'directCall') {\n    DirectCallFactoryNames.add(setup.factoryName)\n  }\n}\n\nexport type LookupConfig = {\n  libName: string\n  rootExport: string\n  kind: LookupKind | 'Root' // 'Root' for builder pattern, LookupKind for direct call\n}\n\ninterface ModuleInfo {\n  id: string\n  bindings: Map<string, Binding>\n  // Maps exported name → local binding name\n  exports: Map<string, string>\n  // Track `export * from './module'` declarations for re-export resolution\n  reExportAllSources: Array<string>\n}\n\n/**\n * Computes whether any file kinds need direct-call candidate detection.\n * This applies to directCall types (ServerOnlyFn, ClientOnlyFn).\n */\nfunction needsDirectCallDetection(kinds: Set<LookupKind>): boolean {\n  for (const kind of kinds) {\n    if (LookupSetup[kind].type === 'directCall') {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Checks if all kinds in the set are guaranteed to be top-level only.\n * Only ServerFn is always declared at module level (must be assigned to a variable).\n * Middleware, IsomorphicFn, ServerOnlyFn, ClientOnlyFn can be nested inside functions.\n * When all kinds are top-level-only, we can use a fast scan instead of full traversal.\n */\nfunction areAllKindsTopLevelOnly(kinds: Set<LookupKind>): boolean {\n  return kinds.size === 1 && kinds.has('ServerFn')\n}\n\n/**\n * Checks if we need to detect JSX elements (e.g., <ClientOnly>).\n */\nfunction needsJSXDetection(kinds: Set<LookupKind>): boolean {\n  for (const kind of kinds) {\n    if (LookupSetup[kind].type === 'jsx') {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Checks if a CallExpression is a direct-call candidate for NESTED detection.\n * Returns true if the callee is a known factory function name.\n * This is stricter than top-level detection because we need to filter out\n * invocations of existing server functions (e.g., `myServerFn()`).\n */\nfunction isNestedDirectCallCandidate(node: t.CallExpression): boolean {\n  let calleeName: string | undefined\n  if (t.isIdentifier(node.callee)) {\n    calleeName = node.callee.name\n  } else if (\n    t.isMemberExpression(node.callee) &&\n    t.isIdentifier(node.callee.property)\n  ) {\n    calleeName = node.callee.property.name\n  }\n  return calleeName !== undefined && DirectCallFactoryNames.has(calleeName)\n}\n\n/**\n * Checks if a CallExpression path is a top-level direct-call candidate.\n * Top-level means the call is the init of a VariableDeclarator at program level.\n * We accept any simple identifier call or namespace call at top level\n * (e.g., `createServerOnlyFn()`, `TanStackStart.createServerOnlyFn()`) and let\n * resolution verify it. This handles renamed imports.\n */\nfunction isTopLevelDirectCallCandidate(\n  path: babel.NodePath<t.CallExpression>,\n): boolean {\n  const node = path.node\n\n  // Must be a simple identifier call or namespace call\n  const isSimpleCall =\n    t.isIdentifier(node.callee) ||\n    (t.isMemberExpression(node.callee) &&\n      t.isIdentifier(node.callee.object) &&\n      t.isIdentifier(node.callee.property))\n\n  if (!isSimpleCall) {\n    return false\n  }\n\n  // Must be top-level: VariableDeclarator -> VariableDeclaration -> Program\n  const parent = path.parent\n  if (!t.isVariableDeclarator(parent) || parent.init !== node) {\n    return false\n  }\n  const grandParent = path.parentPath.parent\n  if (!t.isVariableDeclaration(grandParent)) {\n    return false\n  }\n  return t.isProgram(path.parentPath.parentPath?.parent)\n}\n\nexport class StartCompiler {\n  private moduleCache = new Map<string, ModuleInfo>()\n  private initialized = false\n  private validLookupKinds: Set<LookupKind>\n  private resolveIdCache = new Map<string, string | null>()\n  private exportResolutionCache = new Map<\n    string,\n    Map<string, { moduleInfo: ModuleInfo; binding: Binding } | null>\n  >()\n  // Fast lookup for direct imports from known libraries (e.g., '@tanstack/react-start')\n  // Maps: libName → (exportName → Kind)\n  // This allows O(1) resolution for the common case without async resolveId calls\n  private knownRootImports = new Map<string, Map<string, Kind>>()\n\n  // For generating unique function IDs in production builds\n  private entryIdToFunctionId = new Map<string, string>()\n  private functionIds = new Set<string>()\n\n  // Cached root path with trailing slash for dev mode function ID generation\n  private _rootWithTrailingSlash: string | undefined\n\n  constructor(\n    private options: {\n      env: 'client' | 'server'\n      envName: string\n      root: string\n      lookupConfigurations: Array<LookupConfig>\n      lookupKinds: Set<LookupKind>\n      loadModule: (id: string) => Promise<void>\n      resolveId: (id: string, importer?: string) => Promise<string | null>\n      /**\n       * In 'build' mode, resolution results are cached for performance.\n       * In 'dev' mode (default), caching is disabled to avoid invalidation complexity with HMR.\n       */\n      mode?: 'dev' | 'build'\n      /**\n       * The framework being used (e.g., 'react', 'solid').\n       */\n      framework: CompileStartFrameworkOptions\n      /**\n       * The Vite environment name for the server function provider.\n       */\n      providerEnvName: string\n      /**\n       * Custom function ID generator (optional, defaults to hash-based).\n       */\n      generateFunctionId?: (opts: {\n        filename: string\n        functionName: string\n      }) => string | undefined\n      /**\n       * Callback when server functions are discovered.\n       * Called after each file is compiled with its new functions.\n       */\n      onServerFnsById?: (d: Record<string, ServerFn>) => void\n      /**\n       * Returns the currently known server functions from previous builds.\n       * Used by server callers to look up canonical extracted filenames.\n       */\n      getKnownServerFns?: () => Record<string, ServerFn>\n    },\n  ) {\n    this.validLookupKinds = options.lookupKinds\n  }\n\n  /**\n   * Generates a unique function ID for a server function.\n   * In dev mode, uses a base64-encoded JSON with file path and export name.\n   * In build mode, uses SHA256 hash or custom generator.\n   */\n  private generateFunctionId(opts: {\n    filename: string\n    functionName: string\n    extractedFilename: string\n  }): string {\n    if (this.mode === 'dev') {\n      // In dev, encode the file path and export name for direct lookup\n      let file = opts.extractedFilename\n      if (opts.extractedFilename.startsWith(this.rootWithTrailingSlash)) {\n        file = opts.extractedFilename.slice(this.rootWithTrailingSlash.length)\n      }\n      file = `/@id/${file}`\n\n      const serverFn = {\n        file,\n        export: opts.functionName,\n      }\n      return Buffer.from(JSON.stringify(serverFn), 'utf8').toString('base64url')\n    }\n\n    // Production build: use custom generator or hash\n    const entryId = `${opts.filename}--${opts.functionName}`\n    let functionId = this.entryIdToFunctionId.get(entryId)\n    if (functionId === undefined) {\n      if (this.options.generateFunctionId) {\n        functionId = this.options.generateFunctionId({\n          filename: opts.filename,\n          functionName: opts.functionName,\n        })\n      }\n      if (!functionId) {\n        functionId = crypto.createHash('sha256').update(entryId).digest('hex')\n      }\n      // Deduplicate in case the generated id conflicts with an existing id\n      if (this.functionIds.has(functionId)) {\n        let deduplicatedId\n        let iteration = 0\n        do {\n          deduplicatedId = `${functionId}_${++iteration}`\n        } while (this.functionIds.has(deduplicatedId))\n        functionId = deduplicatedId\n      }\n      this.entryIdToFunctionId.set(entryId, functionId)\n      this.functionIds.add(functionId)\n    }\n    return functionId\n  }\n\n  private get mode(): 'dev' | 'build' {\n    return this.options.mode ?? 'dev'\n  }\n\n  private get rootWithTrailingSlash(): string {\n    if (this._rootWithTrailingSlash === undefined) {\n      this._rootWithTrailingSlash = this.options.root.endsWith('/')\n        ? this.options.root\n        : `${this.options.root}/`\n    }\n    return this._rootWithTrailingSlash\n  }\n\n  private async resolveIdCached(id: string, importer?: string) {\n    if (this.mode === 'dev') {\n      return this.options.resolveId(id, importer)\n    }\n\n    const cacheKey = importer ? `${importer}::${id}` : id\n    const cached = this.resolveIdCache.get(cacheKey)\n    if (cached !== undefined) {\n      return cached\n    }\n    const resolved = await this.options.resolveId(id, importer)\n    this.resolveIdCache.set(cacheKey, resolved)\n    return resolved\n  }\n\n  private getExportResolutionCache(moduleId: string) {\n    let cache = this.exportResolutionCache.get(moduleId)\n    if (!cache) {\n      cache = new Map()\n      this.exportResolutionCache.set(moduleId, cache)\n    }\n    return cache\n  }\n\n  private async init() {\n    // Register internal stub package exports for recognition.\n    // These don't need module resolution - only the knownRootImports fast path.\n    this.knownRootImports.set(\n      '@tanstack/start-fn-stubs',\n      new Map<string, Kind>([\n        ['createIsomorphicFn', 'IsomorphicFn'],\n        ['createServerOnlyFn', 'ServerOnlyFn'],\n        ['createClientOnlyFn', 'ClientOnlyFn'],\n      ]),\n    )\n\n    await Promise.all(\n      this.options.lookupConfigurations.map(async (config) => {\n        // Populate the fast lookup map for direct imports (by package name)\n        // This allows O(1) recognition of imports from known packages.\n        let libExports = this.knownRootImports.get(config.libName)\n        if (!libExports) {\n          libExports = new Map()\n          this.knownRootImports.set(config.libName, libExports)\n        }\n        libExports.set(config.rootExport, config.kind)\n\n        // For JSX lookups (e.g., ClientOnlyJSX), we only need the knownRootImports\n        // fast path to verify imports. Skip module resolution which may fail if\n        // the package isn't a direct dependency (e.g., @tanstack/react-router from\n        // within start-plugin-core).\n        if (config.kind !== 'Root') {\n          const setup = LookupSetup[config.kind]\n          if (setup.type === 'jsx') {\n            return\n          }\n        }\n\n        const libId = await this.resolveIdCached(config.libName)\n        if (!libId) {\n          throw new Error(`could not resolve \"${config.libName}\"`)\n        }\n        let rootModule = this.moduleCache.get(libId)\n        if (!rootModule) {\n          // insert root binding\n          rootModule = {\n            bindings: new Map(),\n            exports: new Map(),\n            id: libId,\n            reExportAllSources: [],\n          }\n          this.moduleCache.set(libId, rootModule)\n        }\n\n        rootModule.exports.set(config.rootExport, config.rootExport)\n        rootModule.exports.set('*', config.rootExport)\n        rootModule.bindings.set(config.rootExport, {\n          type: 'var',\n          init: null, // Not needed since resolvedKind is set\n          resolvedKind: config.kind satisfies Kind,\n        })\n        this.moduleCache.set(libId, rootModule)\n      }),\n    )\n\n    this.initialized = true\n  }\n\n  /**\n   * Extracts bindings and exports from an already-parsed AST.\n   * This is the core logic shared by ingestModule and ingestModuleFromAst.\n   */\n  private extractModuleInfo(\n    ast: ReturnType<typeof parseAst>,\n    id: string,\n  ): ModuleInfo {\n    const bindings = new Map<string, Binding>()\n    const exports = new Map<string, string>()\n    const reExportAllSources: Array<string> = []\n\n    // we are only interested in top-level bindings, hence we don't traverse the AST\n    // instead we only iterate over the program body\n    for (const node of ast.program.body) {\n      if (t.isImportDeclaration(node)) {\n        const source = node.source.value\n        for (const s of node.specifiers) {\n          if (t.isImportSpecifier(s)) {\n            const importedName = t.isIdentifier(s.imported)\n              ? s.imported.name\n              : s.imported.value\n            bindings.set(s.local.name, { type: 'import', source, importedName })\n          } else if (t.isImportDefaultSpecifier(s)) {\n            bindings.set(s.local.name, {\n              type: 'import',\n              source,\n              importedName: 'default',\n            })\n          } else if (t.isImportNamespaceSpecifier(s)) {\n            bindings.set(s.local.name, {\n              type: 'import',\n              source,\n              importedName: '*',\n            })\n          }\n        }\n      } else if (t.isVariableDeclaration(node)) {\n        for (const decl of node.declarations) {\n          if (t.isIdentifier(decl.id)) {\n            bindings.set(decl.id.name, {\n              type: 'var',\n              init: decl.init ?? null,\n            })\n          }\n        }\n      } else if (t.isExportNamedDeclaration(node)) {\n        // export const foo = ...\n        if (node.declaration) {\n          if (t.isVariableDeclaration(node.declaration)) {\n            for (const d of node.declaration.declarations) {\n              if (t.isIdentifier(d.id)) {\n                exports.set(d.id.name, d.id.name)\n                bindings.set(d.id.name, { type: 'var', init: d.init ?? null })\n              }\n            }\n          }\n        }\n        for (const sp of node.specifiers) {\n          if (t.isExportNamespaceSpecifier(sp)) {\n            exports.set(sp.exported.name, sp.exported.name)\n          }\n          // export { local as exported }\n          else if (t.isExportSpecifier(sp)) {\n            const local = sp.local.name\n            const exported = t.isIdentifier(sp.exported)\n              ? sp.exported.name\n              : sp.exported.value\n            exports.set(exported, local)\n\n            // When re-exporting from another module (export { foo } from './module'),\n            // create an import binding so the server function can be resolved\n            if (node.source) {\n              bindings.set(local, {\n                type: 'import',\n                source: node.source.value,\n                importedName: local,\n              })\n            }\n          }\n        }\n      } else if (t.isExportDefaultDeclaration(node)) {\n        const d = node.declaration\n        if (t.isIdentifier(d)) {\n          exports.set('default', d.name)\n        } else {\n          const synth = '__default_export__'\n          bindings.set(synth, { type: 'var', init: d as t.Expression })\n          exports.set('default', synth)\n        }\n      } else if (t.isExportAllDeclaration(node)) {\n        // Handle `export * from './module'` syntax\n        // Track the source so we can look up exports from it when needed\n        reExportAllSources.push(node.source.value)\n      }\n    }\n\n    const info: ModuleInfo = {\n      id,\n      bindings,\n      exports,\n      reExportAllSources,\n    }\n    this.moduleCache.set(id, info)\n    return info\n  }\n\n  public ingestModule({ code, id }: { code: string; id: string }) {\n    const ast = parseAst({ code })\n    const info = this.extractModuleInfo(ast, id)\n    return { info, ast }\n  }\n\n  public invalidateModule(id: string) {\n    // Note: Resolution caches (resolveIdCache, exportResolutionCache) are only\n    // used in build mode where there's no HMR. In dev mode, caching is disabled,\n    // so we only need to invalidate the moduleCache here.\n    return this.moduleCache.delete(id)\n  }\n\n  public async compile({\n    code,\n    id,\n    detectedKinds,\n  }: {\n    code: string\n    id: string\n    /** Pre-detected kinds present in this file. If not provided, all valid kinds are checked. */\n    detectedKinds?: Set<LookupKind>\n  }) {\n    if (!this.initialized) {\n      await this.init()\n    }\n\n    // Use detected kinds if provided, otherwise fall back to all valid kinds for this env\n    const fileKinds = detectedKinds\n      ? new Set([...detectedKinds].filter((k) => this.validLookupKinds.has(k)))\n      : this.validLookupKinds\n\n    // Early exit if no kinds to process\n    if (fileKinds.size === 0) {\n      return null\n    }\n\n    const checkDirectCalls = needsDirectCallDetection(fileKinds)\n    // Optimization: ServerFn is always a top-level declaration (must be assigned to a variable).\n    // If the file only has ServerFn, we can skip full AST traversal and only visit\n    // the specific top-level declarations that have candidates.\n    const canUseFastPath = areAllKindsTopLevelOnly(fileKinds)\n\n    // Always parse and extract module info upfront.\n    // This ensures the module is cached for import resolution even if no candidates are found.\n    const { ast } = this.ingestModule({ code, id })\n\n    // Single-pass traversal to:\n    // 1. Collect candidate paths (only candidates, not all CallExpressions)\n    // 2. Build a map for looking up paths of nested calls in method chains\n    const candidatePaths: Array<babel.NodePath<t.CallExpression>> = []\n    // Map for nested chain lookup - only populated for CallExpressions that are\n    // part of a method chain (callee.object is a CallExpression)\n    const chainCallPaths = new Map<\n      t.CallExpression,\n      babel.NodePath<t.CallExpression>\n    >()\n\n    // JSX candidates (e.g., <ClientOnly>)\n    const jsxCandidatePaths: Array<babel.NodePath<t.JSXElement>> = []\n    const checkJSX = needsJSXDetection(fileKinds)\n    // Get module info that was just cached by ingestModule\n    const moduleInfo = this.moduleCache.get(id)!\n\n    if (canUseFastPath) {\n      // Fast path: only visit top-level statements that have potential candidates\n\n      // Collect indices of top-level statements that contain candidates\n      const candidateIndices: Array<number> = []\n      for (let i = 0; i < ast.program.body.length; i++) {\n        const node = ast.program.body[i]!\n        let declarations: Array<t.VariableDeclarator> | undefined\n\n        if (t.isVariableDeclaration(node)) {\n          declarations = node.declarations\n        } else if (t.isExportNamedDeclaration(node) && node.declaration) {\n          if (t.isVariableDeclaration(node.declaration)) {\n            declarations = node.declaration.declarations\n          }\n        }\n\n        if (declarations) {\n          for (const decl of declarations) {\n            if (decl.init && t.isCallExpression(decl.init)) {\n              if (isMethodChainCandidate(decl.init, fileKinds)) {\n                candidateIndices.push(i)\n                break // Only need to mark this statement once\n              }\n            }\n          }\n        }\n      }\n\n      // Early exit: no potential candidates found at top level\n      if (candidateIndices.length === 0) {\n        return null\n      }\n\n      // Targeted traversal: only visit the specific statements that have candidates\n      // This is much faster than traversing the entire AST\n      babel.traverse(ast, {\n        Program(programPath) {\n          const bodyPaths = programPath.get('body')\n          for (const idx of candidateIndices) {\n            const stmtPath = bodyPaths[idx]\n            if (!stmtPath) continue\n\n            // Traverse only this statement's subtree\n            stmtPath.traverse({\n              CallExpression(path) {\n                const node = path.node\n                const parent = path.parent\n\n                // Check if this call is part of a larger chain (inner call)\n                if (\n                  t.isMemberExpression(parent) &&\n                  t.isCallExpression(path.parentPath.parent)\n                ) {\n                  chainCallPaths.set(node, path)\n                  return\n                }\n\n                // Method chain pattern\n                if (isMethodChainCandidate(node, fileKinds)) {\n                  candidatePaths.push(path)\n                }\n              },\n            })\n          }\n          // Stop traversal after processing Program\n          programPath.stop()\n        },\n      })\n    } else {\n      // Normal path: full traversal for non-fast-path kinds\n      babel.traverse(ast, {\n        CallExpression: (path) => {\n          const node = path.node\n          const parent = path.parent\n\n          // Check if this call is part of a larger chain (inner call)\n          // If so, store it for method chain lookup but don't treat as candidate\n          if (\n            t.isMemberExpression(parent) &&\n            t.isCallExpression(path.parentPath.parent)\n          ) {\n            // This is an inner call in a chain - store for later lookup\n            chainCallPaths.set(node, path)\n            return\n          }\n\n          // Pattern 1: Method chain pattern (.handler(), .server(), .client(), etc.)\n          if (isMethodChainCandidate(node, fileKinds)) {\n            candidatePaths.push(path)\n            return\n          }\n\n          // Pattern 2: Direct call pattern\n          if (checkDirectCalls) {\n            if (isTopLevelDirectCallCandidate(path)) {\n              candidatePaths.push(path)\n            } else if (isNestedDirectCallCandidate(node)) {\n              candidatePaths.push(path)\n            }\n          }\n        },\n        // Pattern 3: JSX element pattern (e.g., <ClientOnly>)\n        // Collect JSX elements where the component is imported from a known package\n        // and resolves to a JSX kind (e.g., ClientOnly from @tanstack/react-router)\n        JSXElement: (path) => {\n          if (!checkJSX) return\n\n          const openingElement = path.node.openingElement\n          const nameNode = openingElement.name\n\n          // Only handle simple identifier names (not namespaced or member expressions)\n          if (!t.isJSXIdentifier(nameNode)) return\n\n          const componentName = nameNode.name\n          const binding = moduleInfo.bindings.get(componentName)\n\n          // Must be an import binding from a known package\n          if (!binding || binding.type !== 'import') return\n\n          // Verify the import source is a known TanStack router package\n          const knownExports = this.knownRootImports.get(binding.source)\n          if (!knownExports) return\n\n          // Verify the imported name resolves to a JSX kind (e.g., ClientOnlyJSX)\n          const kind = knownExports.get(binding.importedName)\n          if (kind !== 'ClientOnlyJSX') return\n\n          jsxCandidatePaths.push(path)\n        },\n      })\n    }\n\n    if (candidatePaths.length === 0 && jsxCandidatePaths.length === 0) {\n      return null\n    }\n\n    // Resolve all candidates in parallel to determine their kinds\n    const resolvedCandidates = await Promise.all(\n      candidatePaths.map(async (path) => ({\n        path,\n        kind: await this.resolveExprKind(path.node, id),\n      })),\n    )\n\n    // Filter to valid candidates\n    const validCandidates = resolvedCandidates.filter(({ kind }) =>\n      this.validLookupKinds.has(kind as Exclude<LookupKind, 'ClientOnlyJSX'>),\n    ) as Array<{\n      path: babel.NodePath<t.CallExpression>\n      kind: Exclude<LookupKind, 'ClientOnlyJSX'>\n    }>\n\n    if (validCandidates.length === 0 && jsxCandidatePaths.length === 0) {\n      return null\n    }\n\n    // Process valid candidates to collect method chains\n    const pathsToRewrite: Array<{\n      path: babel.NodePath<t.CallExpression>\n      kind: Exclude<LookupKind, 'ClientOnlyJSX'>\n      methodChain: MethodChainPaths\n    }> = []\n\n    for (const { path, kind } of validCandidates) {\n      const node = path.node\n\n      // Collect method chain paths by walking DOWN from root through the chain\n      const methodChain: MethodChainPaths = {\n        middleware: null,\n        inputValidator: null,\n        handler: null,\n        server: null,\n        client: null,\n      }\n\n      // Walk down the call chain using nodes, look up paths from map\n      let currentNode: t.CallExpression = node\n      let currentPath: babel.NodePath<t.CallExpression> = path\n\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      while (true) {\n        const callee = currentNode.callee\n        if (!t.isMemberExpression(callee)) {\n          break\n        }\n\n        // Record method chain path if it's a known method\n        if (t.isIdentifier(callee.property)) {\n          const name = callee.property.name as keyof MethodChainPaths\n          if (name in methodChain) {\n            // Get first argument path\n            const args = currentPath.get('arguments')\n            const firstArgPath =\n              Array.isArray(args) && args.length > 0 ? (args[0] ?? null) : null\n            methodChain[name] = {\n              callPath: currentPath,\n              firstArgPath,\n            }\n          }\n        }\n\n        // Move to the inner call (the object of the member expression)\n        if (!t.isCallExpression(callee.object)) {\n          break\n        }\n        currentNode = callee.object\n        // Look up path from chain map, or use candidate path if not found\n        const nextPath = chainCallPaths.get(currentNode)\n        if (!nextPath) {\n          break\n        }\n        currentPath = nextPath\n      }\n\n      pathsToRewrite.push({ path, kind, methodChain })\n    }\n\n    const refIdents = findReferencedIdentifiers(ast)\n\n    const context: CompilationContext = {\n      ast,\n      id,\n      code,\n      env: this.options.env,\n      envName: this.options.envName,\n      root: this.options.root,\n      framework: this.options.framework,\n      providerEnvName: this.options.providerEnvName,\n\n      generateFunctionId: (opts) => this.generateFunctionId(opts),\n      getKnownServerFns: () => this.options.getKnownServerFns?.() ?? {},\n      onServerFnsById: this.options.onServerFnsById,\n    }\n\n    // Group candidates by kind for batch processing\n    const candidatesByKind = new Map<\n      Exclude<LookupKind, 'ClientOnlyJSX'>,\n      Array<RewriteCandidate>\n    >()\n\n    for (const { path: candidatePath, kind, methodChain } of pathsToRewrite) {\n      const candidate: RewriteCandidate = { path: candidatePath, methodChain }\n      const existing = candidatesByKind.get(kind)\n      if (existing) {\n        existing.push(candidate)\n      } else {\n        candidatesByKind.set(kind, [candidate])\n      }\n    }\n\n    // Process each kind using its registered handler\n    for (const [kind, candidates] of candidatesByKind) {\n      const handler = KindHandlers[kind]\n      handler(candidates, context, kind)\n    }\n\n    // Handle JSX candidates (e.g., <ClientOnly>)\n    // Validation was already done during traversal - just call the handler\n    for (const jsxPath of jsxCandidatePaths) {\n      handleClientOnlyJSX(jsxPath, { env: 'server' })\n    }\n\n    deadCodeElimination(ast, refIdents)\n\n    return generateFromAst(ast, {\n      sourceMaps: true,\n      sourceFileName: id,\n      filename: id,\n    })\n  }\n\n  private async resolveIdentifierKind(\n    ident: string,\n    id: string,\n    visited = new Set<string>(),\n  ): Promise<Kind> {\n    const info = await this.getModuleInfo(id)\n\n    const binding = info.bindings.get(ident)\n    if (!binding) {\n      return 'None'\n    }\n    if (binding.resolvedKind) {\n      return binding.resolvedKind\n    }\n\n    // TODO improve cycle detection? should we throw here instead of returning 'None'?\n    // prevent cycles\n    const vKey = `${id}:${ident}`\n    if (visited.has(vKey)) {\n      return 'None'\n    }\n    visited.add(vKey)\n\n    const resolvedKind = await this.resolveBindingKind(binding, id, visited)\n    binding.resolvedKind = resolvedKind\n    return resolvedKind\n  }\n\n  /**\n   * Recursively find an export in a module, following `export * from` chains.\n   * Returns the module info and binding if found, or undefined if not found.\n   */\n  private async findExportInModule(\n    moduleInfo: ModuleInfo,\n    exportName: string,\n    visitedModules = new Set<string>(),\n  ): Promise<{ moduleInfo: ModuleInfo; binding: Binding } | undefined> {\n    const isBuildMode = this.mode === 'build'\n\n    // Check cache first (only for top-level calls in build mode)\n    if (isBuildMode && visitedModules.size === 0) {\n      const moduleCache = this.exportResolutionCache.get(moduleInfo.id)\n      if (moduleCache) {\n        const cached = moduleCache.get(exportName)\n        if (cached !== undefined) {\n          return cached ?? undefined\n        }\n      }\n    }\n\n    // Prevent infinite loops in circular re-exports\n    if (visitedModules.has(moduleInfo.id)) {\n      return undefined\n    }\n    visitedModules.add(moduleInfo.id)\n\n    // First check direct exports\n    const localBindingName = moduleInfo.exports.get(exportName)\n    if (localBindingName) {\n      const binding = moduleInfo.bindings.get(localBindingName)\n      if (binding) {\n        const result = { moduleInfo, binding }\n        // Cache the result (build mode only)\n        if (isBuildMode) {\n          this.getExportResolutionCache(moduleInfo.id).set(exportName, result)\n        }\n        return result\n      }\n    }\n\n    // If not found, recursively check re-export-all sources in parallel\n    // Valid code won't have duplicate exports across chains, so first match wins\n    if (moduleInfo.reExportAllSources.length > 0) {\n      const results = await Promise.all(\n        moduleInfo.reExportAllSources.map(async (reExportSource) => {\n          const reExportTarget = await this.resolveIdCached(\n            reExportSource,\n            moduleInfo.id,\n          )\n\n          if (reExportTarget) {\n            const reExportModule = await this.getModuleInfo(reExportTarget)\n            return this.findExportInModule(\n              reExportModule,\n              exportName,\n              visitedModules,\n            )\n          }\n          return undefined\n        }),\n      )\n      // Return the first valid result\n      for (const result of results) {\n        if (result) {\n          // Cache the result (build mode only)\n          if (isBuildMode) {\n            this.getExportResolutionCache(moduleInfo.id).set(exportName, result)\n          }\n          return result\n        }\n      }\n    }\n\n    // Cache negative result (build mode only)\n    if (isBuildMode) {\n      this.getExportResolutionCache(moduleInfo.id).set(exportName, null)\n    }\n    return undefined\n  }\n\n  private async resolveBindingKind(\n    binding: Binding,\n    fileId: string,\n    visited = new Set<string>(),\n  ): Promise<Kind> {\n    if (binding.resolvedKind) {\n      return binding.resolvedKind\n    }\n    if (binding.type === 'import') {\n      // Fast path: check if this is a direct import from a known library\n      // (e.g., import { createServerFn } from '@tanstack/react-start')\n      // This avoids async resolveId calls for the common case\n      const knownExports = this.knownRootImports.get(binding.source)\n      if (knownExports) {\n        const kind = knownExports.get(binding.importedName)\n        if (kind) {\n          binding.resolvedKind = kind\n          return kind\n        }\n      }\n\n      // Slow path: resolve through the module graph\n      const target = await this.resolveIdCached(binding.source, fileId)\n      if (!target) {\n        return 'None'\n      }\n\n      const importedModule = await this.getModuleInfo(target)\n\n      // Find the export, recursively searching through export * from chains\n      const found = await this.findExportInModule(\n        importedModule,\n        binding.importedName,\n      )\n\n      if (!found) {\n        return 'None'\n      }\n\n      const { moduleInfo: foundModule, binding: foundBinding } = found\n\n      if (foundBinding.resolvedKind) {\n        return foundBinding.resolvedKind\n      }\n\n      const resolvedKind = await this.resolveBindingKind(\n        foundBinding,\n        foundModule.id,\n        visited,\n      )\n      foundBinding.resolvedKind = resolvedKind\n      return resolvedKind\n    }\n\n    const resolvedKind = await this.resolveExprKind(\n      binding.init,\n      fileId,\n      visited,\n    )\n    binding.resolvedKind = resolvedKind\n    return resolvedKind\n  }\n\n  /**\n   * Checks if an identifier is a direct import from a known factory library.\n   * Returns true for imports like `import { createServerOnlyFn } from '@tanstack/react-start'`\n   * or renamed imports like `import { createServerOnlyFn as myFn } from '...'`.\n   * Returns false for local variables that hold the result of calling a factory.\n   */\n  private async isKnownFactoryImport(\n    identName: string,\n    fileId: string,\n  ): Promise<boolean> {\n    const info = await this.getModuleInfo(fileId)\n    const binding = info.bindings.get(identName)\n\n    if (!binding || binding.type !== 'import') {\n      return false\n    }\n\n    // Check if it's imported from a known library\n    const knownExports = this.knownRootImports.get(binding.source)\n    return knownExports !== undefined && knownExports.has(binding.importedName)\n  }\n\n  private async resolveExprKind(\n    expr: t.Expression | null,\n    fileId: string,\n    visited = new Set<string>(),\n  ): Promise<Kind> {\n    if (!expr) {\n      return 'None'\n    }\n\n    // Unwrap common TypeScript/parenthesized wrappers first for efficiency\n    while (\n      t.isTSAsExpression(expr) ||\n      t.isTSNonNullExpression(expr) ||\n      t.isParenthesizedExpression(expr)\n    ) {\n      expr = expr.expression\n    }\n\n    let result: Kind = 'None'\n\n    if (t.isCallExpression(expr)) {\n      if (!t.isExpression(expr.callee)) {\n        return 'None'\n      }\n      const calleeKind = await this.resolveCalleeKind(\n        expr.callee,\n        fileId,\n        visited,\n      )\n      if (calleeKind === 'Root' || calleeKind === 'Builder') {\n        return 'Builder'\n      }\n      // For method chain patterns (callee is MemberExpression like .server() or .client()),\n      // return the resolved kind if valid\n      if (t.isMemberExpression(expr.callee)) {\n        if (this.validLookupKinds.has(calleeKind as LookupKind)) {\n          return calleeKind\n        }\n      }\n      // For direct calls (callee is Identifier), only return the kind if the\n      // callee is a direct import from a known library (e.g., createServerOnlyFn).\n      // Calling a local variable that holds an already-built function (e.g., myServerOnlyFn())\n      // should NOT be treated as a transformation candidate.\n      if (t.isIdentifier(expr.callee)) {\n        const isFactoryImport = await this.isKnownFactoryImport(\n          expr.callee.name,\n          fileId,\n        )\n        if (\n          isFactoryImport &&\n          this.validLookupKinds.has(calleeKind as LookupKind)\n        ) {\n          return calleeKind\n        }\n      }\n    } else if (t.isMemberExpression(expr) && t.isIdentifier(expr.property)) {\n      result = await this.resolveCalleeKind(expr.object, fileId, visited)\n    }\n\n    if (result === 'None' && t.isIdentifier(expr)) {\n      result = await this.resolveIdentifierKind(expr.name, fileId, visited)\n    }\n\n    return result\n  }\n\n  private async resolveCalleeKind(\n    callee: t.Expression,\n    fileId: string,\n    visited = new Set<string>(),\n  ): Promise<Kind> {\n    if (t.isIdentifier(callee)) {\n      return this.resolveIdentifierKind(callee.name, fileId, visited)\n    }\n\n    if (t.isMemberExpression(callee) && t.isIdentifier(callee.property)) {\n      const prop = callee.property.name\n\n      // Check if this property matches any method chain pattern\n      const possibleKinds = IdentifierToKinds.get(prop)\n      if (possibleKinds) {\n        // Resolve base expression ONCE and reuse for all pattern checks\n        const base = await this.resolveExprKind(callee.object, fileId, visited)\n\n        // Check each possible kind that uses this identifier\n        for (const kind of possibleKinds) {\n          if (!this.validLookupKinds.has(kind)) continue\n\n          if (kind === 'ServerFn') {\n            if (base === 'Root' || base === 'Builder') {\n              return 'ServerFn'\n            }\n          } else if (kind === 'Middleware') {\n            if (\n              base === 'Root' ||\n              base === 'Builder' ||\n              base === 'Middleware'\n            ) {\n              return 'Middleware'\n            }\n          } else if (kind === 'IsomorphicFn') {\n            if (\n              base === 'Root' ||\n              base === 'Builder' ||\n              base === 'IsomorphicFn'\n            ) {\n              return 'IsomorphicFn'\n            }\n          }\n        }\n      }\n\n      // Check if the object is a namespace import\n      if (t.isIdentifier(callee.object)) {\n        const info = await this.getModuleInfo(fileId)\n        const binding = info.bindings.get(callee.object.name)\n        if (\n          binding &&\n          binding.type === 'import' &&\n          binding.importedName === '*'\n        ) {\n          // resolve the property from the target module\n          const targetModuleId = await this.resolveIdCached(\n            binding.source,\n            fileId,\n          )\n          if (targetModuleId) {\n            const targetModule = await this.getModuleInfo(targetModuleId)\n            const localBindingName = targetModule.exports.get(\n              callee.property.name,\n            )\n            if (localBindingName) {\n              const exportedBinding =\n                targetModule.bindings.get(localBindingName)\n              if (exportedBinding) {\n                return await this.resolveBindingKind(\n                  exportedBinding,\n                  targetModule.id,\n                  visited,\n                )\n              }\n            }\n          } else {\n            return 'None'\n          }\n        }\n      }\n      return this.resolveExprKind(callee.object, fileId, visited)\n    }\n\n    // handle nested expressions\n    return this.resolveExprKind(callee, fileId, visited)\n  }\n\n  private async getModuleInfo(id: string) {\n    let cached = this.moduleCache.get(id)\n    if (cached) {\n      return cached\n    }\n\n    await this.options.loadModule(id)\n\n    cached = this.moduleCache.get(id)\n    if (!cached) {\n      throw new Error(`could not load module info for ${id}`)\n    }\n    return cached\n  }\n}\n\n/**\n * Checks if a CallExpression has a method chain pattern that matches any of the lookup kinds.\n * E.g., `.handler()`, `.server()`, `.client()`, `.createMiddlewares()`\n */\nfunction isMethodChainCandidate(\n  node: t.CallExpression,\n  lookupKinds: Set<LookupKind>,\n): boolean {\n  const callee = node.callee\n  if (!t.isMemberExpression(callee) || !t.isIdentifier(callee.property)) {\n    return false\n  }\n\n  // Use pre-computed map for O(1) lookup\n  // IdentifierToKinds maps identifier -> Set<LookupKind> to handle shared identifiers\n  const possibleKinds = IdentifierToKinds.get(callee.property.name)\n  if (possibleKinds) {\n    // Check if any of the possible kinds are in the valid lookup kinds\n    for (const kind of possibleKinds) {\n      if (lookupKinds.has(kind)) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n"],"names":["resolvedKind"],"mappings":"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"}