{"version":3,"file":"plugin.js","sources":["../../../src/start-compiler-plugin/plugin.ts"],"sourcesContent":["import { VIRTUAL_MODULES } from '@tanstack/start-server-core'\nimport { TRANSFORM_ID_REGEX, VITE_ENVIRONMENT_NAMES } from '../constants'\nimport {\n  KindDetectionPatterns,\n  LookupKindsPerEnv,\n  StartCompiler,\n  detectKindsInCode,\n} from './compiler'\nimport { cleanId } from './utils'\nimport type { CompileStartFrameworkOptions } from '../types'\nimport type { LookupConfig, LookupKind } from './compiler'\nimport type { GenerateFunctionIdFnOptional, ServerFn } from './types'\nimport type { PluginOption } from 'vite'\n\n// Derive transform code filter from KindDetectionPatterns (single source of truth)\nfunction getTransformCodeFilterForEnv(env: 'client' | 'server'): Array<RegExp> {\n  const validKinds = LookupKindsPerEnv[env]\n  const patterns: Array<RegExp> = []\n  for (const [kind, pattern] of Object.entries(KindDetectionPatterns) as Array<\n    [LookupKind, RegExp]\n  >) {\n    if (validKinds.has(kind)) {\n      patterns.push(pattern)\n    }\n  }\n  return patterns\n}\n\nconst getLookupConfigurationsForEnv = (\n  env: 'client' | 'server',\n  framework: CompileStartFrameworkOptions,\n): Array<LookupConfig> => {\n  // Common configs for all environments\n  const commonConfigs: Array<LookupConfig> = [\n    {\n      libName: `@tanstack/${framework}-start`,\n      rootExport: 'createServerFn',\n      kind: 'Root',\n    },\n    {\n      libName: `@tanstack/${framework}-start`,\n      rootExport: 'createIsomorphicFn',\n      kind: 'IsomorphicFn',\n    },\n    {\n      libName: `@tanstack/${framework}-start`,\n      rootExport: 'createServerOnlyFn',\n      kind: 'ServerOnlyFn',\n    },\n    {\n      libName: `@tanstack/${framework}-start`,\n      rootExport: 'createClientOnlyFn',\n      kind: 'ClientOnlyFn',\n    },\n  ]\n\n  if (env === 'client') {\n    return [\n      {\n        libName: `@tanstack/${framework}-start`,\n        rootExport: 'createMiddleware',\n        kind: 'Root',\n      },\n      {\n        libName: `@tanstack/${framework}-start`,\n        rootExport: 'createStart',\n        kind: 'Root',\n      },\n      ...commonConfigs,\n    ]\n  } else {\n    // Server-only: add ClientOnly JSX component lookup\n    return [\n      ...commonConfigs,\n      {\n        libName: `@tanstack/${framework}-router`,\n        rootExport: 'ClientOnly',\n        kind: 'ClientOnlyJSX',\n      },\n    ]\n  }\n}\nconst SERVER_FN_LOOKUP = 'server-fn-module-lookup'\n\nfunction resolveViteId(id: string) {\n  return `\\0${id}`\n}\n\nconst validateServerFnIdVirtualModule = `virtual:tanstack-start-validate-server-fn-id`\n\nfunction parseIdQuery(id: string): {\n  filename: string\n  query: {\n    [k: string]: string\n  }\n} {\n  if (!id.includes('?')) return { filename: id, query: {} }\n  const [filename, rawQuery] = id.split(`?`, 2) as [string, string]\n  const query = Object.fromEntries(new URLSearchParams(rawQuery))\n  return { filename, query }\n}\n\n/**\n * Generates the manifest module code for server functions.\n * @param serverFnsById - Map of function IDs to their server function info\n * @param includeClientReferencedCheck - Whether to include isClientReferenced flag and runtime check.\n *   This is needed when SSR is NOT the provider, so server-only-referenced functions in the manifest\n *   can be blocked from client HTTP requests.\n */\nfunction generateManifestModule(\n  serverFnsById: Record<string, ServerFn>,\n  includeClientReferencedCheck: boolean,\n): string {\n  const manifestEntries = Object.entries(serverFnsById)\n    .map(([id, fn]) => {\n      const baseEntry = `'${id}': {\n                functionName: '${fn.functionName}',\n        importer: () => import(${JSON.stringify(fn.extractedFilename)})${\n          includeClientReferencedCheck\n            ? `,\n        isClientReferenced: ${fn.isClientReferenced ?? true}`\n            : ''\n        }\n      }`\n      return baseEntry\n    })\n    .join(',')\n\n  const getServerFnByIdParams = includeClientReferencedCheck ? 'id, opts' : 'id'\n  const clientReferencedCheck = includeClientReferencedCheck\n    ? `\n      // If called from client, only allow client-referenced functions\n      if (opts?.fromClient && !serverFnInfo.isClientReferenced) {\n        throw new Error('Server function not accessible from client: ' + id)\n      }\n`\n    : ''\n\n  return `\n    const manifest = {${manifestEntries}}\n\n    export async function getServerFnById(${getServerFnByIdParams}) {\n              const serverFnInfo = manifest[id]\n              if (!serverFnInfo) {\n                throw new Error('Server function info not found for ' + id)\n              }\n${clientReferencedCheck}\n              const fnModule = await serverFnInfo.importer()\n\n              if (!fnModule) {\n                console.info('serverFnInfo', serverFnInfo)\n                throw new Error('Server function module not resolved for ' + id)\n              }\n\n              const action = fnModule[serverFnInfo.functionName]\n\n              if (!action) {\n                  console.info('serverFnInfo', serverFnInfo)\n                  console.info('fnModule', fnModule)\n\n                throw new Error(\n                  \\`Server function module export not resolved for serverFn ID: \\${id}\\`,\n                )\n              }\n              return action\n            }\n          `\n}\n\nexport interface StartCompilerPluginOptions {\n  framework: CompileStartFrameworkOptions\n  environments: Array<{ name: string; type: 'client' | 'server' }>\n  /**\n   * Custom function ID generator (optional).\n   */\n  generateFunctionId?: GenerateFunctionIdFnOptional\n  /**\n   * The Vite environment name for the server function provider.\n   */\n  providerEnvName: string\n}\n\nexport function startCompilerPlugin(\n  opts: StartCompilerPluginOptions,\n): PluginOption {\n  const compilers: Record<string /* envName */, StartCompiler> = {}\n\n  // Shared registry of server functions across all environments\n  const serverFnsById: Record<string, ServerFn> = {}\n\n  const onServerFnsById = (d: Record<string, ServerFn>) => {\n    Object.assign(serverFnsById, d)\n  }\n\n  let root = process.cwd()\n  let command: 'build' | 'serve' = 'build'\n\n  const resolvedResolverVirtualImportId = resolveViteId(\n    VIRTUAL_MODULES.serverFnResolver,\n  )\n\n  // Determine which environments need the resolver (getServerFnById)\n  // SSR environment always needs the resolver for server-side calls\n  // Provider environment needs it for the actual implementation\n  const ssrEnvName = VITE_ENVIRONMENT_NAMES.server\n\n  // SSR is the provider when the provider environment is the default server environment\n  const ssrIsProvider = opts.providerEnvName === ssrEnvName\n\n  // Environments that need the resolver: SSR (for server calls) and provider (for implementation)\n  const appliedResolverEnvironments = new Set(\n    ssrIsProvider ? [opts.providerEnvName] : [ssrEnvName, opts.providerEnvName],\n  )\n\n  function perEnvServerFnPlugin(environment: {\n    name: string\n    type: 'client' | 'server'\n  }): PluginOption {\n    // Derive transform code filter from KindDetectionPatterns (single source of truth)\n    const transformCodeFilter = getTransformCodeFilterForEnv(environment.type)\n\n    return {\n      name: `tanstack-start-core::server-fn:${environment.name}`,\n      enforce: 'pre',\n      applyToEnvironment(env) {\n        return env.name === environment.name\n      },\n      configResolved(config) {\n        root = config.root\n        command = config.command\n      },\n      transform: {\n        filter: {\n          id: {\n            exclude: new RegExp(`${SERVER_FN_LOOKUP}$`),\n            include: TRANSFORM_ID_REGEX,\n          },\n          code: {\n            include: transformCodeFilter,\n          },\n        },\n        async handler(code, id) {\n          let compiler = compilers[this.environment.name]\n          if (!compiler) {\n            // Default to 'dev' mode for unknown environments (conservative: no caching)\n            const mode = this.environment.mode === 'build' ? 'build' : 'dev'\n            compiler = new StartCompiler({\n              env: environment.type,\n              envName: environment.name,\n              root,\n              lookupKinds: LookupKindsPerEnv[environment.type],\n              lookupConfigurations: getLookupConfigurationsForEnv(\n                environment.type,\n                opts.framework,\n              ),\n              mode,\n              framework: opts.framework,\n              providerEnvName: opts.providerEnvName,\n              generateFunctionId: opts.generateFunctionId,\n              onServerFnsById,\n              getKnownServerFns: () => serverFnsById,\n              loadModule: async (id: string) => {\n                if (this.environment.mode === 'build') {\n                  const loaded = await this.load({ id })\n                  // Handle modules with no runtime code (e.g., type-only exports).\n                  // After TypeScript compilation, these become empty modules.\n                  // Create an empty module info instead of throwing.\n                  const code = loaded.code ?? ''\n                  compiler!.ingestModule({ code, id })\n                } else if (this.environment.mode === 'dev') {\n                  /**\n                   * in dev, vite does not return code from `ctx.load()`\n                   * so instead, we need to take a different approach\n                   * we must force vite to load the module and run it through the vite plugin pipeline\n                   * we can do this by using the `fetchModule` method\n                   * the `captureServerFnModuleLookupPlugin` captures the module code via its transform hook and invokes analyzeModuleAST\n                   */\n                  await this.environment.fetchModule(\n                    id + '?' + SERVER_FN_LOOKUP,\n                  )\n                } else {\n                  throw new Error(\n                    `could not load module ${id}: unknown environment mode ${this.environment.mode}`,\n                  )\n                }\n              },\n              resolveId: async (source: string, importer?: string) => {\n                const r = await this.resolve(source, importer)\n                if (r) {\n                  if (!r.external) {\n                    return cleanId(r.id)\n                  }\n                }\n                return null\n              },\n            })\n            compilers[this.environment.name] = compiler\n          }\n\n          // Detect which kinds are present in this file before parsing\n          const detectedKinds = detectKindsInCode(code, environment.type)\n\n          const result = await compiler.compile({\n            id,\n            code,\n            detectedKinds,\n          })\n          return result\n        },\n      },\n\n      hotUpdate(ctx) {\n        const compiler = compilers[this.environment.name]\n\n        ctx.modules.forEach((m) => {\n          if (m.id) {\n            const deleted = compiler?.invalidateModule(m.id)\n            if (deleted) {\n              m.importers.forEach((importer) => {\n                if (importer.id) {\n                  compiler?.invalidateModule(importer.id)\n                }\n              })\n            }\n          }\n        })\n      },\n    }\n  }\n\n  return [\n    ...opts.environments.map(perEnvServerFnPlugin),\n    {\n      name: 'tanstack-start-core:capture-server-fn-module-lookup',\n      // we only need this plugin in dev mode\n      apply: 'serve',\n      applyToEnvironment(env) {\n        return !!opts.environments.find((e) => e.name === env.name)\n      },\n      transform: {\n        filter: {\n          id: new RegExp(`${SERVER_FN_LOOKUP}$`),\n        },\n        handler(code, id) {\n          const compiler = compilers[this.environment.name]\n          compiler?.ingestModule({ code, id: cleanId(id) })\n        },\n      },\n    },\n    // Validate server function ID in dev mode\n    {\n      name: 'tanstack-start-core:validate-server-fn-id',\n      apply: 'serve',\n      load: {\n        filter: {\n          id: new RegExp(resolveViteId(validateServerFnIdVirtualModule)),\n        },\n        handler(id) {\n          const parsed = parseIdQuery(id)\n          if (parsed.query.id && serverFnsById[parsed.query.id]) {\n            return `export {}`\n          }\n          this.error(`Invalid server function ID: ${parsed.query.id}`)\n        },\n      },\n    },\n    // Manifest plugin for server environments\n    {\n      name: 'tanstack-start-core:server-fn-resolver',\n      enforce: 'pre',\n      applyToEnvironment: (env) => {\n        return appliedResolverEnvironments.has(env.name)\n      },\n      configResolved(config) {\n        root = config.root\n        command = config.command\n      },\n      resolveId: {\n        filter: { id: new RegExp(VIRTUAL_MODULES.serverFnResolver) },\n        handler() {\n          return resolvedResolverVirtualImportId\n        },\n      },\n      load: {\n        filter: { id: new RegExp(resolvedResolverVirtualImportId) },\n        handler() {\n          // When SSR is not the provider, SSR callers need to use HTTP to call server functions\n          // since they can't directly import from the provider environment\n          if (this.environment.name !== opts.providerEnvName) {\n            // SSR caller: use HTTP-based getServerFnById\n            // This re-exports from the start-server-core package which handles HTTP calls\n            return `export { getServerFnById } from '@tanstack/start-server-core/server-fn-ssr-caller'`\n          }\n\n          if (this.environment.mode !== 'build') {\n            const mod = `\n            export async function getServerFnById(id) {\n              const validateIdImport = ${JSON.stringify(validateServerFnIdVirtualModule)} + '?id=' + id\n              await import(/* @vite-ignore */ '/@id/__x00__' + validateIdImport)\n              const decoded = Buffer.from(id, 'base64url').toString('utf8')\n              const devServerFn = JSON.parse(decoded)\n              const mod = await import(/* @vite-ignore */ devServerFn.file)\n              return mod[devServerFn.export]\n            }\n            `\n            return mod\n          }\n\n          // When SSR is the provider, server-only-referenced functions aren't in the manifest,\n          // so no isClientReferenced check is needed.\n          // When SSR is NOT the provider (custom provider env), server-only-referenced\n          // functions ARE in the manifest and need the isClientReferenced check to\n          // block direct client HTTP requests to server-only-referenced functions.\n          const includeClientReferencedCheck = !ssrIsProvider\n          return generateManifestModule(\n            serverFnsById,\n            includeClientReferencedCheck,\n          )\n        },\n      },\n    },\n  ]\n}\n"],"names":["id","code"],"mappings":"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"}