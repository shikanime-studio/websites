{"version":3,"file":"prerender.js","sources":["../../src/prerender.ts"],"sourcesContent":["import { promises as fsp } from 'node:fs'\nimport os from 'node:os'\nimport path from 'pathe'\nimport { joinURL, withBase, withTrailingSlash, withoutBase } from 'ufo'\nimport { VITE_ENVIRONMENT_NAMES } from './constants'\nimport { createLogger } from './utils'\nimport { Queue } from './queue'\nimport type { PreviewServer, ResolvedConfig, ViteBuilder } from 'vite'\nimport type { Page, TanStackStartOutputConfig } from './schema'\n\nexport async function prerender({\n  startConfig,\n  builder,\n}: {\n  startConfig: TanStackStartOutputConfig\n  builder: ViteBuilder\n}) {\n  const logger = createLogger('prerender')\n  logger.info('Prerendering pages...')\n\n  // If prerender is enabled\n  if (startConfig.prerender?.enabled) {\n    // default to root page if no pages are defined\n    let pages = startConfig.pages.length ? startConfig.pages : [{ path: '/' }]\n\n    if (startConfig.prerender.autoStaticPathsDiscovery ?? true) {\n      // merge discovered static pages with user-defined pages\n      const pagesMap = new Map(pages.map((item) => [item.path, item]))\n      const discoveredPages = globalThis.TSS_PRERENDABLE_PATHS || []\n\n      for (const page of discoveredPages) {\n        if (!pagesMap.has(page.path)) {\n          pagesMap.set(page.path, page)\n        }\n      }\n\n      pages = Array.from(pagesMap.values())\n    }\n\n    startConfig.pages = pages\n  }\n\n  const serverEnv = builder.environments[VITE_ENVIRONMENT_NAMES.server]\n\n  if (!serverEnv) {\n    throw new Error(\n      `Vite's \"${VITE_ENVIRONMENT_NAMES.server}\" environment not found`,\n    )\n  }\n\n  const clientEnv = builder.environments[VITE_ENVIRONMENT_NAMES.client]\n  if (!clientEnv) {\n    throw new Error(\n      `Vite's \"${VITE_ENVIRONMENT_NAMES.client}\" environment not found`,\n    )\n  }\n\n  const outputDir = clientEnv.config.build.outDir\n\n  process.env.TSS_PRERENDERING = 'true'\n\n  // Start Vite preview server instead of importing module\n  const previewServer = await startPreviewServer(serverEnv.config)\n  const baseUrl = getResolvedUrl(previewServer)\n\n  const isRedirectResponse = (res: Response) => {\n    return res.status >= 300 && res.status < 400 && res.headers.get('location')\n  }\n  async function localFetch(\n    path: string,\n    options?: RequestInit,\n    maxRedirects: number = 5,\n  ): Promise<Response> {\n    const url = new URL(path, baseUrl)\n    const request = new Request(url, options)\n    const response = await fetch(request)\n\n    if (isRedirectResponse(response) && maxRedirects > 0) {\n      const location = response.headers.get('location')!\n      if (location.startsWith('http://localhost') || location.startsWith('/')) {\n        const newUrl = location.replace('http://localhost', '')\n        return localFetch(newUrl, options, maxRedirects - 1)\n      } else {\n        logger.warn(`Skipping redirect to external location: ${location}`)\n      }\n    }\n\n    return response\n  }\n\n  try {\n    // Crawl all pages\n    const pages = await prerenderPages({ outputDir })\n\n    logger.info(`Prerendered ${pages.length} pages:`)\n    pages.forEach((page) => {\n      logger.info(`- ${page}`)\n    })\n  } catch (error) {\n    logger.error(error)\n  } finally {\n    await previewServer.close()\n  }\n\n  function extractLinks(html: string): Array<string> {\n    const linkRegex = /<a[^>]+href=[\"']([^\"']+)[\"'][^>]*>/g\n    const links: Array<string> = []\n    let match\n\n    while ((match = linkRegex.exec(html)) !== null) {\n      const href = match[1]\n      if (href && (href.startsWith('/') || href.startsWith('./'))) {\n        links.push(href)\n      }\n    }\n\n    return links\n  }\n\n  async function prerenderPages({ outputDir }: { outputDir: string }) {\n    const seen = new Set<string>()\n    const prerendered = new Set<string>()\n    const retriesByPath = new Map<string, number>()\n    const concurrency = startConfig.prerender?.concurrency ?? os.cpus().length\n    logger.info(`Concurrency: ${concurrency}`)\n    const queue = new Queue({ concurrency })\n    const routerBasePath = joinURL('/', startConfig.router.basepath ?? '')\n\n    startConfig.pages.forEach((page) => addCrawlPageTask(page))\n\n    await queue.start()\n\n    return Array.from(prerendered)\n\n    function addCrawlPageTask(page: Page) {\n      // Was the page already seen?\n      if (seen.has(page.path)) return\n\n      // Add the page to the seen set\n      seen.add(page.path)\n\n      if (page.fromCrawl) {\n        startConfig.pages.push(page)\n      }\n\n      // If not enabled, skip\n      if (!(page.prerender?.enabled ?? true)) return\n\n      // If there is a filter link, check if the page should be prerendered\n      if (startConfig.prerender?.filter && !startConfig.prerender.filter(page))\n        return\n\n      // Resolve the merged default and page-specific prerender options\n      const prerenderOptions = {\n        ...startConfig.prerender,\n        ...page.prerender,\n      }\n\n      // Add the task\n      queue.add(async () => {\n        logger.info(`Crawling: ${page.path}`)\n        const retries = retriesByPath.get(page.path) || 0\n        try {\n          // Fetch the route\n\n          const res = await localFetch(\n            withTrailingSlash(withBase(page.path, routerBasePath)),\n            {\n              headers: {\n                ...(prerenderOptions.headers ?? {}),\n              },\n            },\n            prerenderOptions.maxRedirects,\n          )\n\n          if (!res.ok) {\n            if (isRedirectResponse(res)) {\n              logger.warn(`Max redirects reached for ${page.path}`)\n            }\n            throw new Error(`Failed to fetch ${page.path}: ${res.statusText}`, {\n              cause: res,\n            })\n          }\n\n          const cleanPagePath = (\n            prerenderOptions.outputPath || page.path\n          ).split(/[?#]/)[0]!\n\n          // Guess route type and populate fileName\n          const contentType = res.headers.get('content-type') || ''\n          const isImplicitHTML =\n            !cleanPagePath.endsWith('.html') && contentType.includes('html')\n\n          const routeWithIndex = cleanPagePath.endsWith('/')\n            ? cleanPagePath + 'index'\n            : cleanPagePath\n\n          const isSpaShell =\n            startConfig.spa?.prerender.outputPath === cleanPagePath\n\n          let htmlPath: string\n          if (isSpaShell) {\n            // For SPA shell, ignore autoSubfolderIndex option\n            htmlPath = cleanPagePath + '.html'\n          } else {\n            if (\n              cleanPagePath.endsWith('/') ||\n              (prerenderOptions.autoSubfolderIndex ?? true)\n            ) {\n              htmlPath = joinURL(cleanPagePath, 'index.html')\n            } else {\n              htmlPath = cleanPagePath + '.html'\n            }\n          }\n\n          const filename = withoutBase(\n            isImplicitHTML ? htmlPath : routeWithIndex,\n            routerBasePath,\n          )\n\n          const html = await res.text()\n\n          const filepath = path.join(outputDir, filename)\n\n          await fsp.mkdir(path.dirname(filepath), {\n            recursive: true,\n          })\n\n          await fsp.writeFile(filepath, html)\n\n          prerendered.add(page.path)\n\n          const newPage = await prerenderOptions.onSuccess?.({ page, html })\n\n          if (newPage) {\n            Object.assign(page, newPage)\n          }\n\n          // Find new links\n          if (prerenderOptions.crawlLinks ?? true) {\n            const links = extractLinks(html)\n            for (const link of links) {\n              addCrawlPageTask({ path: link, fromCrawl: true })\n            }\n          }\n        } catch (error) {\n          if (retries < (prerenderOptions.retryCount ?? 0)) {\n            logger.warn(`Encountered error, retrying: ${page.path} in 500ms`)\n            await new Promise((resolve) =>\n              setTimeout(resolve, prerenderOptions.retryDelay),\n            )\n            retriesByPath.set(page.path, retries + 1)\n            addCrawlPageTask(page)\n          } else {\n            if (prerenderOptions.failOnError ?? true) {\n              throw error\n            }\n          }\n        }\n      })\n    }\n  }\n}\n\nasync function startPreviewServer(\n  viteConfig: ResolvedConfig,\n): Promise<PreviewServer> {\n  const vite = await import('vite')\n\n  try {\n    return await vite.preview({\n      configFile: viteConfig.configFile,\n      preview: {\n        port: 0,\n        open: false,\n      },\n    })\n  } catch (error) {\n    throw new Error(\n      'Failed to start the Vite preview server for prerendering',\n      {\n        cause: error,\n      },\n    )\n  }\n}\n\nfunction getResolvedUrl(previewServer: PreviewServer): URL {\n  const baseUrl = previewServer.resolvedUrls?.local[0]\n\n  if (!baseUrl) {\n    throw new Error('No resolved URL is available from the Vite preview server')\n  }\n\n  return new URL(baseUrl)\n}\n"],"names":["path","outputDir","fsp"],"mappings":"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"}