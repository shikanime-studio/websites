{"version":3,"file":"plugin.js","sources":["../../../src/start-manifest-plugin/plugin.ts"],"sourcesContent":["import { joinURL } from 'ufo'\nimport { rootRouteId } from '@tanstack/router-core'\nimport { VIRTUAL_MODULES } from '@tanstack/start-server-core'\nimport { tsrSplit } from '@tanstack/router-plugin'\nimport { resolveViteId } from '../utils'\nimport { ENTRY_POINTS } from '../constants'\nimport type { GetConfigFn } from '../types'\nimport type { PluginOption, Rollup } from 'vite'\nimport type { Manifest, RouterManagedTag } from '@tanstack/router-core'\n\nconst getCSSRecursively = (\n  chunk: Rollup.OutputChunk,\n  chunksByFileName: Map<string, Rollup.OutputChunk>,\n  basePath: string,\n  cache: Map<Rollup.OutputChunk, Array<RouterManagedTag>>,\n  visited = new Set<Rollup.OutputChunk>(),\n) => {\n  if (visited.has(chunk)) {\n    return []\n  }\n  visited.add(chunk)\n  const cachedResult = cache.get(chunk)\n  if (cachedResult) {\n    return cachedResult\n  }\n  const result: Array<RouterManagedTag> = []\n\n  // Get all css imports from the file\n  for (const cssFile of chunk.viteMetadata?.importedCss ?? []) {\n    result.push({\n      tag: 'link',\n      attrs: {\n        rel: 'stylesheet',\n        href: joinURL(basePath, cssFile),\n        type: 'text/css',\n      },\n    })\n  }\n\n  // Recursively get CSS from imports\n  for (const importedFileName of chunk.imports) {\n    const importedChunk = chunksByFileName.get(importedFileName)\n    if (importedChunk) {\n      result.push(\n        ...getCSSRecursively(\n          importedChunk,\n          chunksByFileName,\n          basePath,\n          cache,\n          visited,\n        ),\n      )\n    }\n  }\n\n  cache.set(chunk, result)\n  return result\n}\n\nconst resolvedModuleId = resolveViteId(VIRTUAL_MODULES.startManifest)\nexport function startManifestPlugin(opts: {\n  getClientBundle: () => Rollup.OutputBundle\n  getConfig: GetConfigFn\n}): PluginOption {\n  return {\n    name: 'tanstack-start:start-manifest-plugin',\n    enforce: 'pre',\n    resolveId: {\n      filter: { id: new RegExp(VIRTUAL_MODULES.startManifest) },\n      handler(id) {\n        if (id === VIRTUAL_MODULES.startManifest) {\n          return resolvedModuleId\n        }\n        return undefined\n      },\n    },\n    load: {\n      filter: {\n        id: new RegExp(resolvedModuleId),\n      },\n      handler(id) {\n        const { resolvedStartConfig } = opts.getConfig()\n        if (id === resolvedModuleId) {\n          if (\n            this.environment.name !== resolvedStartConfig.serverFnProviderEnv\n          ) {\n            // this will ultimately fail the build if the plugin is used outside the provider environment\n            // TODO: do we need special handling for `serve`?\n            return `export default {}`\n          }\n\n          // If we're in development, return a dummy manifest\n          if (this.environment.config.command === 'serve') {\n            return `export const tsrStartManifest = () => ({\n            routes: {},\n            clientEntry: '${joinURL(resolvedStartConfig.viteAppBase, '@id', ENTRY_POINTS.client)}',\n          })`\n          }\n\n          // This the manifest pulled from the generated route tree and later used by the Router.\n          // i.e what's located in `src/routeTree.gen.ts`\n          const routeTreeRoutes = globalThis.TSS_ROUTES_MANIFEST\n\n          const cssPerChunkCache = new Map<\n            Rollup.OutputChunk,\n            Array<RouterManagedTag>\n          >()\n\n          // This is where hydration will start, from when the SSR'd page reaches the browser.\n          let entryFile: Rollup.OutputChunk | undefined\n\n          const clientBundle = opts.getClientBundle()\n          const chunksByFileName = new Map<string, Rollup.OutputChunk>()\n\n          const routeChunks: Record<\n            string /** fullPath of route file **/,\n            Array<Rollup.OutputChunk>\n          > = {}\n          for (const bundleEntry of Object.values(clientBundle)) {\n            if (bundleEntry.type === 'chunk') {\n              chunksByFileName.set(bundleEntry.fileName, bundleEntry)\n              if (bundleEntry.isEntry) {\n                if (entryFile) {\n                  throw new Error(\n                    `multiple entries detected: ${entryFile.fileName} ${bundleEntry.fileName}`,\n                  )\n                }\n                entryFile = bundleEntry\n              }\n              const routePieces = bundleEntry.moduleIds.flatMap((m) => {\n                const [id, query] = m.split('?')\n                if (id === undefined) {\n                  throw new Error('expected id to be defined')\n                }\n                if (query === undefined) {\n                  return []\n                }\n                const searchParams = new URLSearchParams(query)\n                const split = searchParams.get(tsrSplit)\n\n                if (split !== null) {\n                  return {\n                    id,\n                    split,\n                  }\n                }\n                return []\n              })\n              if (routePieces.length > 0) {\n                routePieces.forEach((r) => {\n                  let array = routeChunks[r.id]\n                  if (array === undefined) {\n                    array = []\n                    routeChunks[r.id] = array\n                  }\n                  array.push(bundleEntry)\n                })\n              }\n            }\n          }\n\n          const manifest: Manifest = { routes: {} }\n          // Add preloads to the routes from the vite manifest\n          Object.entries(routeTreeRoutes).forEach(([routeId, v]) => {\n            if (!v.filePath) {\n              throw new Error(`expected filePath to be set for ${routeId}`)\n            }\n            const chunks = routeChunks[v.filePath]\n            if (chunks) {\n              chunks.forEach((chunk) => {\n                // Map the relevant imports to their route paths,\n                // so that it can be imported in the browser.\n                const preloads = chunk.imports.map((d) => {\n                  const preloadPath = joinURL(\n                    resolvedStartConfig.viteAppBase,\n                    d,\n                  )\n                  return preloadPath\n                })\n\n                // Since this is the most important JS entry for the route,\n                // it should be moved to the front of the preloads so that\n                // it has the best chance of being loaded first.\n                preloads.unshift(\n                  joinURL(resolvedStartConfig.viteAppBase, chunk.fileName),\n                )\n\n                const assets = getCSSRecursively(\n                  chunk,\n                  chunksByFileName,\n                  resolvedStartConfig.viteAppBase,\n                  cssPerChunkCache,\n                )\n\n                manifest.routes[routeId] = {\n                  ...v,\n                  assets,\n                  preloads,\n                }\n              })\n            } else {\n              manifest.routes[routeId] = v\n            }\n          })\n\n          if (!entryFile) {\n            throw new Error('No entry file found')\n          }\n\n          manifest.routes[rootRouteId] = manifest.routes[rootRouteId] || {}\n          manifest.routes[rootRouteId].preloads = [\n            joinURL(resolvedStartConfig.viteAppBase, entryFile.fileName),\n            ...entryFile.imports.map((d) =>\n              joinURL(resolvedStartConfig.viteAppBase, d),\n            ),\n          ]\n\n          // Gather all the CSS files from the entry file in\n          // the `css` key and add them to the root route\n          const entryCssAssetsList = getCSSRecursively(\n            entryFile,\n            chunksByFileName,\n            resolvedStartConfig.viteAppBase,\n            cssPerChunkCache,\n          )\n\n          manifest.routes[rootRouteId].assets = [\n            ...(manifest.routes[rootRouteId].assets || []),\n            ...entryCssAssetsList,\n          ]\n\n          const recurseRoute = (\n            route: {\n              preloads?: Array<string>\n              children?: Array<any>\n            },\n            seenPreloads = {} as Record<string, true>,\n          ) => {\n            route.preloads = route.preloads?.filter((preload) => {\n              if (seenPreloads[preload]) {\n                return false\n              }\n              seenPreloads[preload] = true\n              return true\n            })\n\n            if (route.children) {\n              route.children.forEach((child) => {\n                const childRoute = manifest.routes[child]!\n                recurseRoute(childRoute, { ...seenPreloads })\n              })\n            }\n          }\n\n          recurseRoute(manifest.routes[rootRouteId])\n\n          // Filter out routes that have neither assets nor preloads\n          Object.keys(manifest.routes).forEach((routeId) => {\n            const route = manifest.routes[routeId]!\n            const hasAssets = route.assets && route.assets.length > 0\n            const hasPreloads = route.preloads && route.preloads.length > 0\n            if (!hasAssets && !hasPreloads) {\n              delete routeTreeRoutes[routeId]\n            }\n          })\n\n          const startManifest = {\n            routes: manifest.routes,\n            clientEntry: joinURL(\n              resolvedStartConfig.viteAppBase,\n              entryFile.fileName,\n            ),\n          }\n\n          return `export const tsrStartManifest = () => (${JSON.stringify(startManifest)})`\n        }\n\n        return undefined\n      },\n    },\n  }\n}\n"],"names":["id"],"mappings":"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"}