{"version":3,"file":"frame-protocol.js","sources":["../../src/frame-protocol.ts"],"sourcesContent":["/**\n * Binary frame protocol for multiplexing JSON and raw streams over HTTP.\n *\n * Frame format: [type:1][streamId:4][length:4][payload:length]\n * - type: 1 byte - frame type (JSON, CHUNK, END, ERROR)\n * - streamId: 4 bytes big-endian uint32 - stream identifier\n * - length: 4 bytes big-endian uint32 - payload length\n * - payload: variable length bytes\n */\n\n// Re-export constants from shared location\nimport { FRAME_HEADER_SIZE, FrameType } from '@tanstack/start-client-core'\n\nexport {\n  FRAME_HEADER_SIZE,\n  FrameType,\n  TSS_CONTENT_TYPE_FRAMED,\n  TSS_CONTENT_TYPE_FRAMED_VERSIONED,\n  TSS_FRAMED_PROTOCOL_VERSION,\n} from '@tanstack/start-client-core'\n\n/** Cached TextEncoder for frame encoding */\nconst textEncoder = new TextEncoder()\n\n/** Shared empty payload for END frames - avoids allocation per call */\nconst EMPTY_PAYLOAD = new Uint8Array(0)\n\n/**\n * Encodes a single frame with header and payload.\n */\nexport function encodeFrame(\n  type: FrameType,\n  streamId: number,\n  payload: Uint8Array,\n): Uint8Array {\n  const frame = new Uint8Array(FRAME_HEADER_SIZE + payload.length)\n  // Write header bytes directly to avoid DataView allocation per frame\n  // Frame format: [type:1][streamId:4 BE][length:4 BE]\n  frame[0] = type\n  frame[1] = (streamId >>> 24) & 0xff\n  frame[2] = (streamId >>> 16) & 0xff\n  frame[3] = (streamId >>> 8) & 0xff\n  frame[4] = streamId & 0xff\n  frame[5] = (payload.length >>> 24) & 0xff\n  frame[6] = (payload.length >>> 16) & 0xff\n  frame[7] = (payload.length >>> 8) & 0xff\n  frame[8] = payload.length & 0xff\n  frame.set(payload, FRAME_HEADER_SIZE)\n  return frame\n}\n\n/**\n * Encodes a JSON frame (type 0, streamId 0).\n */\nexport function encodeJSONFrame(json: string): Uint8Array {\n  return encodeFrame(FrameType.JSON, 0, textEncoder.encode(json))\n}\n\n/**\n * Encodes a raw stream chunk frame.\n */\nexport function encodeChunkFrame(\n  streamId: number,\n  chunk: Uint8Array,\n): Uint8Array {\n  return encodeFrame(FrameType.CHUNK, streamId, chunk)\n}\n\n/**\n * Encodes a raw stream end frame.\n */\nexport function encodeEndFrame(streamId: number): Uint8Array {\n  return encodeFrame(FrameType.END, streamId, EMPTY_PAYLOAD)\n}\n\n/**\n * Encodes a raw stream error frame.\n */\nexport function encodeErrorFrame(streamId: number, error: unknown): Uint8Array {\n  const message =\n    error instanceof Error ? error.message : String(error ?? 'Unknown error')\n  return encodeFrame(FrameType.ERROR, streamId, textEncoder.encode(message))\n}\n\n/**\n * Creates a multiplexed ReadableStream from JSON stream and raw streams.\n *\n * The JSON stream emits NDJSON lines (from seroval's toCrossJSONStream).\n * Raw streams are pumped concurrently, interleaved with JSON frames.\n *\n * @param jsonStream Stream of JSON strings (each string is one NDJSON line)\n * @param rawStreams Map of stream IDs to raw binary streams\n */\nexport function createMultiplexedStream(\n  jsonStream: ReadableStream<string>,\n  rawStreams: Map<number, ReadableStream<Uint8Array>>,\n): ReadableStream<Uint8Array> {\n  // Track active pumps for completion\n  let activePumps = 1 + rawStreams.size // 1 for JSON + raw streams\n  let controllerRef: ReadableStreamDefaultController<Uint8Array> | null = null\n  let cancelled = false as boolean\n  const cancelReaders: Array<() => void> = []\n\n  const safeEnqueue = (chunk: Uint8Array) => {\n    if (cancelled || !controllerRef) return\n    try {\n      controllerRef.enqueue(chunk)\n    } catch {\n      // Ignore enqueue after close/cancel\n    }\n  }\n\n  const safeError = (err: unknown) => {\n    if (cancelled || !controllerRef) return\n    try {\n      controllerRef.error(err)\n    } catch {\n      // Ignore\n    }\n  }\n\n  const safeClose = () => {\n    if (cancelled || !controllerRef) return\n    try {\n      controllerRef.close()\n    } catch {\n      // Ignore\n    }\n  }\n\n  const checkComplete = () => {\n    activePumps--\n    if (activePumps === 0) {\n      safeClose()\n    }\n  }\n\n  return new ReadableStream<Uint8Array>({\n    start(controller) {\n      controllerRef = controller\n      cancelReaders.length = 0\n\n      // Pump JSON stream (streamId 0)\n      const pumpJSON = async () => {\n        const reader = jsonStream.getReader()\n        cancelReaders.push(() => {\n          // Catch async rejection - reader may already be released\n          reader.cancel().catch(() => {})\n        })\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          while (true) {\n            const { done, value } = await reader.read()\n            // Check cancelled after await - flag may have changed while waiting\n            if (cancelled) break\n            if (done) break\n            safeEnqueue(encodeJSONFrame(value))\n          }\n        } catch (error) {\n          // JSON stream error - fatal, error the whole response\n          safeError(error)\n        } finally {\n          reader.releaseLock()\n          checkComplete()\n        }\n      }\n\n      // Pump a single raw stream with its streamId\n      const pumpRawStream = async (\n        streamId: number,\n        stream: ReadableStream<Uint8Array>,\n      ) => {\n        const reader = stream.getReader()\n        cancelReaders.push(() => {\n          // Catch async rejection - reader may already be released\n          reader.cancel().catch(() => {})\n        })\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          while (true) {\n            const { done, value } = await reader.read()\n            // Check cancelled after await - flag may have changed while waiting\n            if (cancelled) break\n            if (done) {\n              safeEnqueue(encodeEndFrame(streamId))\n              break\n            }\n            safeEnqueue(encodeChunkFrame(streamId, value))\n          }\n        } catch (error) {\n          // Stream error - send ERROR frame (non-fatal, other streams continue)\n          safeEnqueue(encodeErrorFrame(streamId, error))\n        } finally {\n          reader.releaseLock()\n          checkComplete()\n        }\n      }\n\n      // Start all pumps concurrently\n      pumpJSON()\n      for (const [streamId, stream] of rawStreams) {\n        pumpRawStream(streamId, stream)\n      }\n    },\n\n    cancel() {\n      cancelled = true\n      controllerRef = null\n      // Proactively cancel all underlying readers to stop work quickly.\n      for (const cancelReader of cancelReaders) {\n        cancelReader()\n      }\n      cancelReaders.length = 0\n    },\n  })\n}\n"],"names":[],"mappings":"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"}