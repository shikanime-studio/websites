{"version":3,"file":"utils.js","sources":["../../src/utils.ts"],"sourcesContent":["import fs from 'node:fs/promises'\nimport { normalizePath } from 'vite'\nimport type { Connect } from 'vite'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport type { PackageJson } from '@tanstack/devtools-client'\n\nexport const handleDevToolsViteRequest = (\n  req: Connect.IncomingMessage,\n  res: ServerResponse<IncomingMessage>,\n  next: Connect.NextFunction,\n  cb: (data: any) => void,\n) => {\n  if (req.url?.includes('__tsd/open-source')) {\n    const searchParams = new URLSearchParams(req.url.split('?')[1])\n\n    const source = searchParams.get('source')\n    if (!source) {\n      return\n    }\n\n    const parsed = parseOpenSourceParam(source)\n    if (!parsed) {\n      return\n    }\n    const { file, line, column } = parsed\n\n    cb({\n      type: 'open-source',\n      routine: 'open-source',\n      data: {\n        source: file ? normalizePath(`${process.cwd()}/${file}`) : undefined,\n        line,\n        column,\n      },\n    })\n    res.setHeader('Content-Type', 'text/html')\n    res.write(`<script> window.close(); </script>`)\n    res.end()\n    return\n  }\n  if (!req.url?.includes('__tsd')) {\n    return next()\n  }\n\n  const chunks: Array<any> = []\n  req.on('data', (chunk) => {\n    chunks.push(chunk)\n  })\n  req.on('end', () => {\n    const dataToParse = Buffer.concat(chunks)\n    try {\n      const parsedData = JSON.parse(dataToParse.toString())\n      cb(parsedData)\n    } catch (e) {}\n    res.write('OK')\n  })\n}\n\nexport const parseOpenSourceParam = (source: string) => {\n  // Capture everything up to the last two colon-separated numeric parts as the file.\n  // This supports filenames that may themselves contain colons.\n  const parts = source.match(/^(.+):(\\d+):(\\d+)$/)\n\n  if (!parts) return null\n\n  const [, file, line, column] = parts\n  return { file, line, column }\n}\n\nconst tryReadFile = async (filePath: string) => {\n  try {\n    const data = await fs.readFile(filePath, 'utf-8')\n    return data\n  } catch (error) {\n    return null\n  }\n}\n\nexport const tryParseJson = <T extends any>(\n  jsonString: string | null | undefined,\n) => {\n  if (!jsonString) {\n    return null\n  }\n  try {\n    const result = JSON.parse(jsonString)\n    return result as T\n  } catch (error) {\n    return null\n  }\n}\n\nexport const readPackageJson = async () =>\n  tryParseJson<PackageJson>(await tryReadFile(process.cwd() + '/package.json'))\n"],"names":[],"mappings":";;AAMO,MAAM,4BAA4B,CACvC,KACA,KACA,MACA,OACG;AACH,MAAI,IAAI,KAAK,SAAS,mBAAmB,GAAG;AAC1C,UAAM,eAAe,IAAI,gBAAgB,IAAI,IAAI,MAAM,GAAG,EAAE,CAAC,CAAC;AAE9D,UAAM,SAAS,aAAa,IAAI,QAAQ;AACxC,QAAI,CAAC,QAAQ;AACX;AAAA,IACF;AAEA,UAAM,SAAS,qBAAqB,MAAM;AAC1C,QAAI,CAAC,QAAQ;AACX;AAAA,IACF;AACA,UAAM,EAAE,MAAM,MAAM,OAAA,IAAW;AAE/B,OAAG;AAAA,MACD,MAAM;AAAA,MACN,SAAS;AAAA,MACT,MAAM;AAAA,QACJ,QAAQ,OAAO,cAAc,GAAG,QAAQ,KAAK,IAAI,IAAI,EAAE,IAAI;AAAA,QAC3D;AAAA,QACA;AAAA,MAAA;AAAA,IACF,CACD;AACD,QAAI,UAAU,gBAAgB,WAAW;AACzC,QAAI,MAAM,qCAAoC;AAC9C,QAAI,IAAA;AACJ;AAAA,EACF;AACA,MAAI,CAAC,IAAI,KAAK,SAAS,OAAO,GAAG;AAC/B,WAAO,KAAA;AAAA,EACT;AAEA,QAAM,SAAqB,CAAA;AAC3B,MAAI,GAAG,QAAQ,CAAC,UAAU;AACxB,WAAO,KAAK,KAAK;AAAA,EACnB,CAAC;AACD,MAAI,GAAG,OAAO,MAAM;AAClB,UAAM,cAAc,OAAO,OAAO,MAAM;AACxC,QAAI;AACF,YAAM,aAAa,KAAK,MAAM,YAAY,UAAU;AACpD,SAAG,UAAU;AAAA,IACf,SAAS,GAAG;AAAA,IAAC;AACb,QAAI,MAAM,IAAI;AAAA,EAChB,CAAC;AACH;AAEO,MAAM,uBAAuB,CAAC,WAAmB;AAGtD,QAAM,QAAQ,OAAO,MAAM,oBAAoB;AAE/C,MAAI,CAAC,MAAO,QAAO;AAEnB,QAAM,GAAG,MAAM,MAAM,MAAM,IAAI;AAC/B,SAAO,EAAE,MAAM,MAAM,OAAA;AACvB;AAEA,MAAM,cAAc,OAAO,aAAqB;AAC9C,MAAI;AACF,UAAM,OAAO,MAAM,GAAG,SAAS,UAAU,OAAO;AAChD,WAAO;AAAA,EACT,SAAS,OAAO;AACd,WAAO;AAAA,EACT;AACF;AAEO,MAAM,eAAe,CAC1B,eACG;AACH,MAAI,CAAC,YAAY;AACf,WAAO;AAAA,EACT;AACA,MAAI;AACF,UAAM,SAAS,KAAK,MAAM,UAAU;AACpC,WAAO;AAAA,EACT,SAAS,OAAO;AACd,WAAO;AAAA,EACT;AACF;AAEO,MAAM,kBAAkB,YAC7B,aAA0B,MAAM,YAAY,QAAQ,IAAA,IAAQ,eAAe,CAAC;"}